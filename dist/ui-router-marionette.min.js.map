{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///ui-router-marionette.min.js","webpack:///webpack/bootstrap 89dbb5e3bbf8d99bad2e?2c6d","webpack:///./src/index.coffee?3d3c","webpack:///external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}?8e93","webpack:///./~/ui-router-core/lib/index.js?eb25","webpack:///./~/ui-router-core/lib/common/index.js?0a2c","webpack:///./~/ui-router-core/lib/common/common.js?cf4d","webpack:///./~/ui-router-core/lib/common/predicates.js?d043","webpack:///./~/ui-router-core/lib/common/hof.js?f100","webpack:///./~/ui-router-core/lib/common/coreservices.js?cdcd","webpack:///./~/ui-router-core/lib/common/glob.js?6b30","webpack:///./~/ui-router-core/lib/common/queue.js?d4a0","webpack:///./~/ui-router-core/lib/common/strings.js?311e","webpack:///./~/ui-router-core/lib/transition/rejectFactory.js?f278","webpack:///./~/ui-router-core/lib/transition/transition.js?cb73","webpack:///./~/ui-router-core/lib/common/trace.js?439e","webpack:///./~/ui-router-core/lib/transition/interface.js?90d0","webpack:///./~/ui-router-core/lib/transition/transitionHook.js?f358","webpack:///./~/ui-router-core/lib/state/targetState.js?a35d","webpack:///./~/ui-router-core/lib/transition/hookRegistry.js?e1c9","webpack:///./~/ui-router-core/lib/transition/hookBuilder.js?a5b9","webpack:///./~/ui-router-core/lib/path/node.js?8b12","webpack:///./~/ui-router-core/lib/params/param.js?ed16","webpack:///./~/ui-router-core/lib/params/paramType.js?33d4","webpack:///./~/ui-router-core/lib/path/pathFactory.js?a7a1","webpack:///./~/ui-router-core/lib/resolve/resolvable.js?1f09","webpack:///./~/ui-router-core/lib/resolve/resolveContext.js?1544","webpack:///./~/ui-router-core/lib/resolve/interface.js?a665","webpack:///./~/ui-router-core/lib/router.js?8102","webpack:///./~/ui-router-core/lib/url/urlMatcherFactory.js?891b","webpack:///./~/ui-router-core/lib/url/urlMatcher.js?d438","webpack:///./~/ui-router-core/lib/params/paramTypes.js?9d59","webpack:///./~/ui-router-core/lib/url/urlRouter.js?3a6c","webpack:///./~/ui-router-core/lib/url/urlRule.js?c28b","webpack:///./~/ui-router-core/lib/state/stateObject.js?c26a","webpack:///./~/ui-router-core/lib/transition/transitionService.js?3f7a","webpack:///./~/ui-router-core/lib/hooks/resolve.js?2c64","webpack:///./~/ui-router-core/lib/hooks/views.js?e195","webpack:///./~/ui-router-core/lib/hooks/url.js?b25f","webpack:///./~/ui-router-core/lib/hooks/redirectTo.js?5ea3","webpack:///./~/ui-router-core/lib/hooks/onEnterExitRetain.js?34a6","webpack:///./~/ui-router-core/lib/hooks/lazyLoad.js?7404","webpack:///./~/ui-router-core/lib/transition/transitionEventType.js?45f4","webpack:///./~/ui-router-core/lib/view/view.js?9313","webpack:///./~/ui-router-core/lib/state/stateRegistry.js?6ad5","webpack:///./~/ui-router-core/lib/state/stateMatcher.js?30f3","webpack:///./~/ui-router-core/lib/state/stateBuilder.js?a704","webpack:///./~/ui-router-core/lib/state/stateQueueManager.js?a439","webpack:///./~/ui-router-core/lib/state/stateService.js?0391","webpack:///./~/ui-router-core/lib/globals.js?0b2e","webpack:///./~/ui-router-core/lib/params/stateParams.js?da15","webpack:///./~/ui-router-core/lib/url/urlService.js?242b","webpack:///./~/ui-router-core/lib/params/index.js?06e6","webpack:///./~/ui-router-core/lib/path/index.js?c60f","webpack:///./~/ui-router-core/lib/resolve/index.js?785f","webpack:///./~/ui-router-core/lib/state/index.js?f8ea","webpack:///./~/ui-router-core/lib/transition/index.js?5aa5","webpack:///./~/ui-router-core/lib/url/index.js?33c0","webpack:///./~/ui-router-core/lib/view/index.js?03f5","webpack:///./~/ui-router-core/lib/interface.js?70a6","webpack:///./src/router.coffee?5584","webpack:///./src/state_views_builder.coffee?56f9","webpack:///./~/ui-router-core/lib/vanilla.js?67d6","webpack:///./~/ui-router-core/lib/vanilla/index.js?6019","webpack:///./~/ui-router-core/lib/vanilla/$q.js?b905","webpack:///./~/ui-router-core/lib/vanilla/$injector.js?e177","webpack:///./~/ui-router-core/lib/vanilla/baseLocationService.js?6a47","webpack:///./~/ui-router-core/lib/vanilla/utils.js?762f","webpack:///./~/ui-router-core/lib/vanilla/hashLocationService.js?8c71","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationService.js?f52a","webpack:///./~/ui-router-core/lib/vanilla/pushStateLocationService.js?25c4","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationConfig.js?ea76","webpack:///./~/ui-router-core/lib/vanilla/browserLocationConfig.js?3d33","webpack:///./~/ui-router-core/lib/vanilla/plugins.js?4ce6","webpack:///./src/uiview.coffee?2999","webpack:///external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}?4413","webpack:///./src/hook_builder.coffee?cd0c","webpack:///./src/marionette/behaviors.coffee?4f4a","webpack:///./src/ui_layout_mn2.coffee?372c"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_74__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","$q","Router","UILayoutMn2","UISref","UISrefActive","UIViewMarionette","_","ref","ref1","extend","__export","hasOwnProperty","createProxyFunctions","source","target","bind","fnNames","latebind","bindFunction","fnName","makeLateRebindFn","apply","arguments","Object","keys","reduce","acc","name","_inArray","array","obj","indexOf","_removeFrom","idx","splice","_pushTo","arr","val","push","defaults","opts","defaultsList","_i","length","merge","concat","pick","dst","objs","forEach","value","key","ancestors","first","second","path","n","pickOmitImpl","predicate","objCopy","inArray","restArgs","omit","notInArray","item","pluck","collection","propName","map","hof_1","prop","filter","callback","predicates_1","isArray","result","accept","x","i","find","pushR","assertFn","predicateOrMap","errMsg","Error","isFunction","arrayTuples","arrayArgs","min","Math","Array","ignored","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_copyProps","to","from","_extend","toObj","identity","_equals","o1","o2","t1","t2","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","predicates","any","b","fn","a1","a2","t","coreservices_1","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","equals","noop","inherit","parent","extra","prototype","args","slice","curry","removeFrom","pushTo","deregAll","functions","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","uniqR","token","unnest","flatten","assertPredicate","assertMap","pairs","sortBy","propFn","checkFn","a","composeSort","sortFns","prev","silenceUncaughtInPromise","promise","catch","e","silentRejection","error","services","reject","isInjectable","head","not","toStr","tis","isUndefined","isDefined","isNull","o","isNullOrUndefined","or","isNumber","isObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","start","funcs","reverse","fn1","fn2","invoke","pattern","struct","propEq","split","is","ctor","constructor","eq","other","v","notImplemented","fnname","$injector","Glob","text","glob","regexpString","seg","join","regexp","RegExp","matches","test","fromString","Queue","_items","_limit","enqueue","items","shift","dequeue","size","clear","current","remove","peekTail","peekHead","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","splitOnDelim","delim","re","common_1","joinNeighborsR","rejectFactory_1","transition_1","resolvable_1","stringifyPatternFn","isTransitionRejectionPromise","Rejection","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","RejectType","strings_1","type","message","detail","detailString","d","toPromise","then","superseded","options","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","errored","ERROR","trace_1","interface_1","transitionHook_1","hookRegistry_1","hookBuilder_1","node_1","pathFactory_1","targetState_1","param_1","resolveContext_1","router_1","stateSelf","fromPath","targetState","router","_deferred","defer","_registeredHooks","isActive","_options","_targetState","valid","$id","transitionService","_transitionCount","toPath","PathFactory","buildToPath","_treeChanges","treeChanges","reloadState","createTransitionHookRegFns","onCreateHooks","hookBuilder","buildHooksForPhase","TransitionHookPhase","CREATE","TransitionHook","runAllHooks","applyViewConfigs","applyRootResolvables","onBefore","criteria","onStart","onExit","onRetain","onEnter","onFinish","onSuccess","onError","_pluginapi","_getEvents","hookPhase","makeEvent","getHooks","hookName","enteringStates","entering","node","state","$view","rootResolvables","UIRouter","params","rootNode","context","ResolveContext","addResolvables","$from","$to","self","compare","matchState","pathname","freeze","injector","pathName","subPath","getResolveTokens","getTokens","addResolvable","resolvable","stateName","topath","targetNode","resolveContext","redirectedFrom","originalTransition","rf","exiting","retained","views","redirect","redirects","trans","redirectOpts","location","newOptions","TargetState","identifier","$state","newTransition","create","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","includes","matchingEnteringNodes","PathNode","matching","resolvables","_changedParams","tc","reload","pathsDiffer","tuple","nodeSchemas","paramSchema","_a","paramValues","toValues","fromValues","tuples","schema","toVals","fromVals","Param","changed","dynamic","changes","HookBuilder","run","globals","transitionHistory","onBeforeHooks","BEFORE","syncResult","runOnBeforeHooks","rejectReason","trace","traceTransitionIgnored","transitionSuccess","traceSuccess","success","resolve","onSuccessHooks","SUCCESS","transitionError","reason","traceError","_error","onErrorHooks","traceTransitionStart","appendHookToChain","nextHook","invokeHook","asyncHooks","ASYNC","abstract","validates","parameters","fromStateOrName","toStateOrName","avoidEmptyHash","fromParams","toValid","toParams","diToken","uiViewString","viewData","creationContext","fqn","normalizedCat","input","Category","viewConfigString","viewConfig","viewDecl","$context","$uiViewName","$uiViewContextAnchor","Trace","_enabled","approximateDigests","_set","enabled","categories","k","parseInt","isNaN","category","enable","disable","TRANSITION","tid","transitionStr","console","log","traceHookInvocation","step","HOOK","event","registeredHook","traceHookResult","hookResult","transitionOptions","hookResultStr","traceResolvePath","when","RESOLVE","pathStr","traceResolvableResolved","resolvableStr","data","finalState","traceUIViewEvent","UIVIEW","traceUIViewConfigUpdated","traceUIViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUIViewEvent","TransitionHookScope","defaultOptions","transition","traceData","stateContext","stateService","rejectIfSuperseded","eventType","hook","_deregistered","errorHandler","getErrorHandler","resultHandler","getResultHandler","handleHookResult","isTargetState","hooks","results","hooks_1","chain","HANDLE_RESULT","IGNORE_RESULT","LOG_ERROR","defaultErrorHandler","REJECT_ERROR","THROW_ERROR","_identifier","_definition","_params","exists","base","relative","isDef","criterion","matchGlobs","_state","globStrings","toMatch","glob_1","matchFn","registry","hookRegistrationFn","matchObject","RegisteredHook","tranSvc","matchCriteria","priority","_matchingNodes","nodes","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","paths","mn","pathtype","isStateHook","scope","STATE","allMatched","every","tupleSort","reverseDepthSort","l","r","factor","depthDelta","toState","fromState","$transitions","baseHookOptions","phase","buildHooks","hookType","matchingHooks","getMatchingHooks","makeTransitionHooks","matchingNodes","criteriaMatchPath","transitionHook","sort","reverseSort","isCreate","registries","reg","stateOrPath","res","clone","applyRawParams","getParamVal","paramDef","pDef","parameter","paramValsEq","pathA","pathB","ignoreDynamicParams","changedParams","param","unwrapShorthand","cfg","isShorthand","$$fn","getType","urlType","paramTypes","DefType","CONFIG","PATH","SEARCH","paramType_1","ParamType","getSquashPolicy","config","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","hasOwn","urlMatcherFactory","getArrayMode","arrayDefaults","arrayParamNomenclature","$asArray","raw","defaultSquashPolicy","isDefaultValue","$$getDefaultValue","defaultValue","$replace","replacement","$normalize","isSearch","normalized","encoded","encode","exec","values1","values2","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","$arrayMode","def","decode","$subPattern","sub","makeTargetState","buildPath","inheritParams","states","viewDecls","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","applyToParams","retainedNode","cloned","keep","staticParams","nodesMatch","node1","node2","retainedWithToParams","elementIdx","defaultResolvePolicy","async","arg1","resolveFn","deps","policy","resolved","literal","getPolicy","thisPolicy","statePolicy","resolvePolicy","getResolvableDependencies","getDependencies","get","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","cache","take","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","fromData","resolvePolicies","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","getResolvable","subContext","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","promises","nodeResolvables","nowait","wait","getResult","_injector","UIInjectorImpl","availableResolvables","getDependency","fromInjector","getNative","native","getAsync","WAIT","NOWAIT","RXWAIT","urlMatcherFactory_1","urlRouter_1","transitionService_1","view_1","stateRegistry_1","stateService_1","globals_1","urlService_1","_routerInstance","locationService","locationConfig","UrlService","locationServiceStub","locationConfigStub","viewService","ViewService","TransitionService","Globals","UrlMatcherFactory","urlRouter","UrlRouter","stateRegistry","StateRegistry","StateService","urlService","_disposables","_plugins","_rootViewContext","$current","disposable","dispose","plugin","pluginInstance","getPlugin","pluginName","urlMatcher_1","paramTypes_1","ParamTypes","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strict","caseInsensitive","paramFactory","fromConfig","fromSearch","UrlMatcher","strictMode","compile","isMatcher","object","definition","definitionFn","$get","_flushTypeQueue","quoteRegExp","string","surroundPattern","memoizeTo","_cache","_children","_segments","_compiled","paramMap","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","makeRegexpType","substring","index","lastIndex","search","append","url","isRoot","hash","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","j","validParamVal","getDetails","urlMatchers","pathSegmentsAndParams","queryParams","pathString","encodeDashes","encodeURIComponent","queryString","charCodeAt","toUpperCase","matcher","staticSegments","splitOnSlash","segments","aSegments","bSegments","weight","cmp","weightPair","initDefaultTypes","makeDefaultType","valToString","defaultTypeBase","String","query","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","json","typeQueue","defaultTypes","makeType","types","appendBasePath","isHtml5","absolute","baseHref","defaultRuleSortFn","urlRule_1","getMatcher","URLMATCHER","REGEXP","RAW","OTHER","_sortFn","_rules","interceptDeferred","_id","_router","urlRuleFactory","UrlRuleFactory","listen","_otherwiseFn","compareFn","rules","best","checkRule","rule","matchPriority","sync","evt","defaultPrevented","$url","applyResult","newurl","go","handler","_stopFn","onChange","update","read","urlMatcher","href","html5Mode","hashPrefix","slash","port","protocol","host","isUrlRule","removeRule","otherwise","handlerFn","deferIntercept","stateObject_1","what","makeRule","_what","fromUrlMatcher","State","fromRegExp","BaseUrlRule","optional","matched","_handler","details","transitionTo","global","sticky","redirectUrlTo","Number","matchingKeys","inherited","resolve_1","views_1","url_1","redirectTo_1","onEnterExitRetain_1","lazyLoad_1","transitionEventType_1","defaultTransOpts","notify","custom","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineDefaultPaths","_defineDefaultEvents","_registerDefaultTransitionHooks","onCreate","hooksArray","Phase","TH","_defineEvent","_definePathType","hookOrder","TransitionEventType","transitionHookTypes","cmpByPhase","hookScope","fns","redirectTo","registerRedirectToHook","registerOnExitHook","registerOnRetainHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","loadViews","registerLoadEnteringViews","activateViews","registerActivateViews","updateUrl","registerUpdateUrl","lazyLoad","registerLazyLoadHook","eagerResolvePath","lazyResolveState","loadEnteringViews","enteringViews","load","exitingViews","vc","deactivateViewConfig","activateViewConfig","$urlRouter","navigable","urlOptions","redirectToHook","handleResult","makeEnterExitRetainHook","hookFn","onExitHook","onRetainHook","onEnterHook","lazyLoadState","updateStateRegistry","register","lazyLoadFn","$$state","err","lazyLoadHook","retryTransition","orig","parts","_uiViews","_viewConfigs","_viewConfigFactories","_viewConfigFactory","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","decl","cfgFactory","$type","cfgs","uiViewDepth","uiView","viewConfigDepth","count","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","configUpdated","registerUIView","uiViews","fqnMatches","available","active","normalizeUIViewTarget","rawViewName","viewAtContext","uiViewName","uiViewContextAnchor","relativeViewNameSugar","charAt","relativeMatch","anchor","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","stateMatcher_1","stateBuilder_1","stateQueueManager_1","listeners","StateMatcher","builder","StateBuilder","stateQueue","StateQueueManager","_registerRoot","rootStateDef","#","_root","deregister","onStatesChanged","listener","stateDefinition","_deregisterTree","s","getChildren","children","deregistered","$ur","stateOrName","deregisteredStates","found","decorator","func","_states","isRelative","isStr","baseState","splitName","pathLength","relName","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","objects2Tuples","resolveObj","annotate","strictDi","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","parseUrl","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","parsed","paramConfig","reloadOnSearch","getNavigableBuilder","getParamsBuilder","makeConfigParam","urlParams","nonUrlParams","parentBuilder","parentName","builders","build","parentFn","lastSegment","pop","$registry","queue","flush","registered","orphans","previousQueueLength","orphanIdx","existingState","attachRoute","queue_1","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","defineProperty","enumerable","configurable","_handleInvalidTargetState","invokeNextCallback","nextCallback","callbackQueue","callbackResult","checkForRedirect","latestThing","latest","onInvalid","defautGoOpts","transOpts","getCurrentPath","latestSuccess","successfulTransitions","rootPath","transHistory","currentPath","rejectedTransitionHandler","transitionToPromise","include","defaultHrefOpts","lossy","$inherit","nav","stateParams_1","StateParams","beforeNewTransition","$transition$","updateGlobalState","clearCurrentTransition","newParams","parentParams","parents","inheritList","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","lateBind","locationServices","umf","urlParts","UIRouterPluginBase","MnViewConfig","UIRouterMarionette","getStateHookBuilder","hashLocationPlugin","mnViewsBuilder","routerInstance","servicesPlugin","viewConfigFactory","child","hasProp","__super__","superClass","_started","getInstance","addState","rootRegion","beforeBackboneRoute","beforeRouteCallback","originalRoute","uiRouter","Backbone","route","originalCallback","bbRouter","wrappedCallback","routeParams","hasAnyKey","viewConfigId","viewsObject","$default","each","len","resolveAs","$name","warn","index_1","Promise","deferred","wait4","STRIP_COMMENTS","ARGUMENT_NAMES","has","locals","ensureExist","$inject","utils_1","BaseLocationServices","fireAfterUpdate","_listener","_listeners","_get","getParams","_location","_history","history","evt_1","Event","buildUrl","orEmptyString","splitHash","beforehash","_b","splitQuery","locationPluginFactory","serviceClass","configurationClass","service","configuration","splitEqual","trimHashVal","keyValsToObjectR","accum","loc","searchObject","vals","__extends","__","baseLocationService_1","HashLocationService","_super","addEventListener","title","removeEventListener","MemoryLocationService","_url","PushStateLocationService","_config","fullUrl","replaceState","pushState","MemoryLocationConfig","_baseHref","_port","_protocol","_host","_hashPrefix","newval","BrowserLocationConfig","_isHtml5","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","_injector_1","_q_1","browserLocationConfig_1","hashLocationService_1","pushStateLocationService_1","memoryLocationService_1","memoryLocationConfig_1","pushStateLocationPlugin","memoryLocationPlugin","Mn","initialize","mnLayout","mnRegion","mnRegionName","parentContext","parentFqn","ref2","ref3","ref4","ref5","ref6","listenTo","destroy","activeUIView","onConfigUpdated","newConfig","clearPreviousConfig","updateView","controller","getResolved","getView","getController","show","triggerMethod","listenToOnce","registerEventCallbacks","viewOptions","controllerOptions","registerExitCallback","component","deregisterFn","uiCanExit","on","empty","onBeforeDestroy","getLocals","tokens","waitPolicy","decoratedHook","ui","sref","events","click @ui.ref","onClickLink","onAttach","$","attr","click","button","which","shiftKey","metaKey","altKey","ctrlKey","preventDefault","Behavior","activeClasses","applyToRoot","modelStateField","onStateChange","onRender","classFn","compareState","getOption","model","$el","el","removeListeners","off","onAttachUI","onBeforeDestroyUI","regions","me","parentRegion","region","regionName","LayoutView"],"mappings":"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","file":"ui-router-marionette.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, Router, UILayoutMn2, UISref, UISrefActive, UIViewMarionette, _, ref, ref1;\n\t\n\t_ = __webpack_require__(2);\n\t\n\t$q = __webpack_require__(3).$q;\n\t\n\tref = __webpack_require__(59), UIViewMarionette = ref.UIViewMarionette, Router = ref.Router;\n\t\n\tref1 = __webpack_require__(76), UISref = ref1.UISref, UISrefActive = ref1.UISrefActive;\n\t\n\tUILayoutMn2 = __webpack_require__(77);\n\t\n\t_.extend(exports, {\n\t  Router: Router,\n\t  UISref: UISref,\n\t  UISrefActive: UISrefActive,\n\t  UILayoutMn2: UILayoutMn2,\n\t  UIViewMarionette: UIViewMarionette,\n\t  $q: $q\n\t});\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module common\n\t */ /** */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(4));\n\t__export(__webpack_require__(51));\n\t__export(__webpack_require__(52));\n\t__export(__webpack_require__(53));\n\t__export(__webpack_require__(54));\n\t__export(__webpack_require__(55));\n\t__export(__webpack_require__(56));\n\t__export(__webpack_require__(57));\n\t__export(__webpack_require__(48));\n\t__export(__webpack_require__(27));\n\t__export(__webpack_require__(58));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module common */ /** for typedoc */\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(14));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * These functions are exported, but are subject to change without notice.\n\t *\n\t * @preferred\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\texports.copy = angular.copy || _copy;\n\texports.forEach = angular.forEach || _forEach;\n\texports.extend = angular.extend || _extend;\n\texports.equals = angular.equals || _equals;\n\texports.identity = function (x) { return x; };\n\texports.noop = function () { return undefined; };\n\t/**\n\t * Builds proxy functions on the `to` object which pass through to the `from` object.\n\t *\n\t * For each key in `fnNames`, creates a proxy function on the `to` object.\n\t * The proxy function calls the real function on the `from` object.\n\t *\n\t *\n\t * #### Example:\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * ```js\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * #### Example:\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param source A function that returns the source object which contains the original functions to be bound\n\t * @param target A function that returns the target object which will receive the bound functions\n\t * @param bind A function that returns the object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n\t */\n\tfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n\t    if (latebind === void 0) { latebind = false; }\n\t    var bindFunction = function (fnName) {\n\t        return source()[fnName].bind(bind());\n\t    };\n\t    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n\t        target[fnName] = bindFunction(fnName);\n\t        return target[fnName].apply(null, arguments);\n\t    }; };\n\t    fnNames = fnNames || Object.keys(source());\n\t    return fnNames.reduce(function (acc, name) {\n\t        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n\t        return acc;\n\t    }, target);\n\t}\n\texports.createProxyFunctions = createProxyFunctions;\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\texports.inherit = function (parent, extra) {\n\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t};\n\t/**\n\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t * This is similar to es6 rest parameters.\n\t *\n\t * Optionally, the argument at index idx may itself already be an array.\n\t *\n\t * For example,\n\t * given either:\n\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t * or:\n\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t * then:\n\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t *\n\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t *\n\t * given:\n\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t * then:\n\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t */\n\tvar restArgs = function (args, idx) {\n\t    if (idx === void 0) { idx = 0; }\n\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\texports.inArray = hof_1.curry(_inArray);\n\tfunction _inArray(array, obj) {\n\t    return array.indexOf(obj) !== -1;\n\t}\n\texports._inArray = _inArray;\n\t/**\n\t * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n\t * The same array is returned\n\t */\n\texports.removeFrom = hof_1.curry(_removeFrom);\n\tfunction _removeFrom(array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t}\n\texports._removeFrom = _removeFrom;\n\t/** pushes a values to an array and returns the value */\n\texports.pushTo = hof_1.curry(_pushTo);\n\tfunction _pushTo(arr, val) {\n\t    return (arr.push(val), val);\n\t}\n\texports._pushTo = _pushTo;\n\t/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\n\texports.deregAll = function (functions) {\n\t    return functions.slice().forEach(function (fn) {\n\t        typeof fn === 'function' && fn();\n\t        exports.removeFrom(functions, fn);\n\t    });\n\t};\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    if (opts === void 0) { opts = {}; }\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t}\n\texports.defaults = defaults;\n\t/**\n\t * Merges properties from the list of objects to the destination object.\n\t * If a property already exists in the destination object, then it is not overwritten.\n\t */\n\tfunction merge(dst) {\n\t    var objs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        objs[_i - 1] = arguments[_i];\n\t    }\n\t    exports.forEach(objs, function (obj) {\n\t        exports.forEach(obj, function (value, key) {\n\t            if (!dst.hasOwnProperty(key))\n\t                dst[key] = value;\n\t        });\n\t    });\n\t    return dst;\n\t}\n\texports.merge = merge;\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\texports.ancestors = ancestors;\n\tfunction pickOmitImpl(predicate, obj) {\n\t    var keys = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        keys[_i - 2] = arguments[_i];\n\t    }\n\t    var objCopy = {};\n\t    for (var key in obj) {\n\t        if (predicate(keys, key))\n\t            objCopy[key] = obj[key];\n\t    }\n\t    return objCopy;\n\t}\n\t/** Return a copy of the object only containing the whitelisted properties. */\n\tfunction pick(obj) {\n\t    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n\t}\n\texports.pick = pick;\n\t/** Return a copy of the object omitting the blacklisted properties. */\n\tfunction omit(obj) {\n\t    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n\t    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n\t}\n\texports.omit = omit;\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, hof_1.prop(propName));\n\t}\n\texports.pluck = pluck;\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    exports.forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\texports.filter = filter;\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    exports.forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\texports.find = find;\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\texports.mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\texports.map = map;\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\texports.values = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return obj[key]; });\n\t};\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flattenR = function (memo, elem) {\n\t    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n\t};\n\t/**\n\t * Reduce function that pushes an object to an array, then returns the array.\n\t * Mostly just for [[flattenR]] and [[uniqR]]\n\t */\n\tfunction pushR(arr, obj) {\n\t    arr.push(obj);\n\t    return arr;\n\t}\n\texports.pushR = pushR;\n\t/** Reduce function that filters out duplicates */\n\texports.uniqR = function (acc, token) {\n\t    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n\t};\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\texports.assertPredicate = assertFn;\n\t/**\n\t * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n\t * @example\n\t * ```\n\t *\n\t * var data = { foo: 1, bar: 2 };\n\t *\n\t * let keys = [ 'foo', 'bar' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // values is [1, 2]\n\t *\n\t * let keys = [ 'foo', 'bar', 'baz' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // throws Error(\"Key not found\")\n\t * ```\n\t */\n\texports.assertMap = assertFn;\n\tfunction assertFn(predicateOrMap, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        var result = predicateOrMap(obj);\n\t        if (!result) {\n\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.assertFn = assertFn;\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\texports.pairs = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n\t};\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var arrayArgs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        arrayArgs[_i] = arguments[_i];\n\t    }\n\t    if (arrayArgs.length === 0)\n\t        return [];\n\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t}\n\texports.arrayTuples = arrayTuples;\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (predicates_1.isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!predicates_1.isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\texports.applyPairs = applyPairs;\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\texports.tail = tail;\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return exports.extend(dest, src);\n\t}\n\t/** Naive forEach implementation works with Objects or Arrays */\n\tfunction _forEach(obj, cb, _this) {\n\t    if (predicates_1.isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _copyProps(to, from) {\n\t    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n\t    return to;\n\t}\n\tfunction _extend(toObj) {\n\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t/**\n\t * Create a sort function\n\t *\n\t * Creates a sort function which sorts by a numeric property.\n\t *\n\t * The `propFn` should return the property as a number which can be sorted.\n\t *\n\t * #### Example:\n\t * This example returns the `priority` prop.\n\t * ```js\n\t * var sortfn = sortBy(obj => obj.priority)\n\t * // equivalent to:\n\t * var longhandSortFn = (a, b) => a.priority - b.priority;\n\t * ```\n\t *\n\t * #### Example:\n\t * This example uses [[prop]]\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'))\n\t * ```\n\t *\n\t * The `checkFn` can be used to exclude objects from sorting.\n\t *\n\t * #### Example:\n\t * This example only sorts objects with type === 'FOO'\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n\t * ```\n\t *\n\t * @param propFn a function that returns the property (as a number)\n\t * @param checkFn a predicate\n\t *\n\t * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n\t */\n\texports.sortBy = function (propFn, checkFn) {\n\t    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n\t    return function (a, b) {\n\t        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n\t    };\n\t};\n\t/**\n\t * Composes a list of sort functions\n\t *\n\t * Creates a sort function composed of multiple sort functions.\n\t * Each sort function is invoked in series.\n\t * The first sort function to return non-zero \"wins\".\n\t *\n\t * @param sortFns list of sort functions\n\t */\n\texports.composeSort = function () {\n\t    var sortFns = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sortFns[_i] = arguments[_i];\n\t    }\n\t    return function (a, b) {\n\t        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n\t    };\n\t};\n\t// issue #2676\n\texports.silenceUncaughtInPromise = function (promise) {\n\t    return promise.catch(function (e) { return 0; }) && promise;\n\t};\n\texports.silentRejection = function (error) {\n\t    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n\t};\n\t//# sourceMappingURL=common.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** Predicates\n\t *\n\t * These predicates return true/false based on the input.\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_predicates\n\t */ /** */\n\tvar hof_1 = __webpack_require__(7);\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\texports.isUndefined = tis('undefined');\n\texports.isDefined = hof_1.not(exports.isUndefined);\n\texports.isNull = function (o) { return o === null; };\n\texports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\n\texports.isFunction = tis('function');\n\texports.isNumber = tis('number');\n\texports.isString = tis('string');\n\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\texports.isArray = Array.isArray;\n\texports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\n\texports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val) {\n\t    if (exports.isArray(val) && val.length) {\n\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t    }\n\t    return exports.isFunction(val);\n\t}\n\texports.isInjectable = isInjectable;\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\t//# sourceMappingURL=predicates.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Higher order functions\n\t *\n\t * These utility functions are exported, but are subject to change without notice.\n\t *\n\t * @module common_hof\n\t */ /** */\n\t\"use strict\";\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\texports.curry = curry;\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\texports.compose = compose;\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\texports.pipe = pipe;\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\texports.prop = function (name) {\n\t    return function (obj) { return obj && obj[name]; };\n\t};\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\texports.parse = function (name) {\n\t    return pipe.apply(null, name.split(\".\").map(exports.prop));\n\t};\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\texports.not = function (fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return !fn.apply(null, args);\n\t    };\n\t};\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\texports.and = and;\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\texports.or = or;\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\texports.all = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n\t};\n\texports.any = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n\t};\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\texports.is = function (ctor) {\n\t    return function (obj) {\n\t        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n\t    };\n\t};\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\texports.eq = function (val) { return function (other) {\n\t    return val === other;\n\t}; };\n\t/** Given a value, returns a function which returns the value */\n\texports.val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) {\n\t        return obj[fnName].apply(obj, args);\n\t    };\n\t}\n\texports.invoke = invoke;\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\texports.pattern = pattern;\n\t//# sourceMappingURL=hof.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t};\n\texports.services = services;\n\t//# sourceMappingURL=coreservices.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */\n\t/**\n\t * Matches state names using glob-like pattern strings.\n\t *\n\t * Globs can be used in specific APIs including:\n\t *\n\t * - [[StateService.is]]\n\t * - [[StateService.includes]]\n\t * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n\t *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n\t *\n\t * A `Glob` string is a pattern which matches state names.\n\t * Nested state names are split into segments (separated by a dot) when processing.\n\t * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n\t *\n\t * Globs work according to the following rules:\n\t *\n\t * ### Exact match:\n\t *\n\t * The glob `'A.B'` matches the state named exactly `'A.B'`.\n\t *\n\t * | Glob        |Matches states named|Does not match state named|\n\t * |:------------|:--------------------|:---------------------|\n\t * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n\t * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n\t * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n\t *\n\t * ### Single star (`*`)\n\t *\n\t * A single star (`*`) is a wildcard that matches exactly one segment.\n\t *\n\t * | Glob        |Matches states named  |Does not match state named |\n\t * |:------------|:---------------------|:--------------------------|\n\t * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n\t * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n\t * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n\t *\n\t * ### Double star (`**`)\n\t *\n\t * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n\t *\n\t * | Glob        |Matches states named                           |Does not match state named         |\n\t * |:------------|:----------------------------------------------|:----------------------------------|\n\t * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n\t * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n\t * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n\t * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n\t *\n\t */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t        var regexpString = this.text.split('.')\n\t            .map(function (seg) {\n\t            if (seg === '**')\n\t                return '(?:|(?:\\\\.[^.]*)*)';\n\t            if (seg === '*')\n\t                return '\\\\.[^.]*';\n\t            return '\\\\.' + seg;\n\t        }).join('');\n\t        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        return this.regexp.test('.' + name);\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.is = function (text) {\n\t        return text.indexOf('*') > -1;\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.fromString = function (text) {\n\t        if (!this.is(text))\n\t            return null;\n\t        return new Glob(text);\n\t    };\n\t    return Glob;\n\t}());\n\texports.Glob = Glob;\n\t//# sourceMappingURL=glob.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\texports.Queue = Queue;\n\t//# sourceMappingURL=queue.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Functions that manipulate strings\n\t *\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_strings\n\t */ /** */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(6);\n\tvar rejectFactory_1 = __webpack_require__(12);\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar transition_1 = __webpack_require__(13);\n\tvar resolvable_1 = __webpack_require__(24);\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\texports.maxLength = maxLength;\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\texports.padString = padString;\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\texports.kebobString = kebobString;\n\tfunction _toJson(obj) {\n\t    return JSON.stringify(obj);\n\t}\n\tfunction _fromJson(json) {\n\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t}\n\tfunction promiseToString(p) {\n\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t    var fnName = fn['name'] || \"\";\n\t    if (fnName && toStr.match(/function \\(/)) {\n\t        return 'function ' + fnName + toStr.substr(9);\n\t    }\n\t    return toStr;\n\t}\n\texports.functionToString = functionToString;\n\tfunction fnToString(fn) {\n\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\texports.fnToString = fnToString;\n\tvar stringifyPatternFn = null;\n\tvar stringifyPattern = function (value) {\n\t    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\t    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n\t        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t        [predicates_1.isNull, hof_1.val(\"null\")],\n\t        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n\t        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t        [predicates_1.isInjectable, functionToString],\n\t        [hof_1.val(true), common_1.identity]\n\t    ]);\n\t    return stringifyPatternFn(value);\n\t};\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val) {\n\t        if (predicates_1.isObject(val)) {\n\t            if (seen.indexOf(val) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val);\n\t        }\n\t        return stringifyPattern(val);\n\t    }\n\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t}\n\texports.stringify = stringify;\n\t/** Returns a function that splits a string on a character or substring */\n\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\t/**\n\t * Splits on a delimiter, but returns the delimiters in the array\n\t *\n\t * #### Example:\n\t * ```js\n\t * var splitOnSlashes = splitOnDelim('/');\n\t * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n\t * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n\t * ```\n\t */\n\tfunction splitOnDelim(delim) {\n\t    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n\t    return function (str) {\n\t        return str.split(re).filter(common_1.identity);\n\t    };\n\t}\n\texports.splitOnDelim = splitOnDelim;\n\t;\n\t/**\n\t * Reduce fn that joins neighboring strings\n\t *\n\t * Given an array of strings, returns a new array\n\t * where all neighboring strings have been joined.\n\t *\n\t * #### Example:\n\t * ```js\n\t * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n\t * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n\t * ```\n\t */\n\tfunction joinNeighborsR(acc, x) {\n\t    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n\t        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n\t    return common_1.pushR(acc, x);\n\t}\n\texports.joinNeighborsR = joinNeighborsR;\n\t;\n\t//# sourceMappingURL=strings.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar strings_1 = __webpack_require__(11);\n\tvar RejectType;\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n\t})(RejectType = exports.RejectType || (exports.RejectType = {}));\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) {\n\t            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n\t        };\n\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition\";\n\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a TransitionRejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid\";\n\t        return new Rejection(RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored\";\n\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition has been aborted\";\n\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.errored = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition errored\";\n\t        return new Rejection(RejectType.ERROR, message, detail);\n\t    };\n\t    return Rejection;\n\t}());\n\texports.Rejection = Rejection;\n\t//# sourceMappingURL=rejectFactory.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar trace_1 = __webpack_require__(14);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(15);\n\tvar transitionHook_1 = __webpack_require__(16);\n\tvar hookRegistry_1 = __webpack_require__(18);\n\tvar hookBuilder_1 = __webpack_require__(19);\n\tvar node_1 = __webpack_require__(20);\n\tvar pathFactory_1 = __webpack_require__(23);\n\tvar targetState_1 = __webpack_require__(17);\n\tvar param_1 = __webpack_require__(21);\n\tvar resolvable_1 = __webpack_require__(24);\n\tvar rejectFactory_1 = __webpack_require__(12);\n\tvar resolveContext_1 = __webpack_require__(25);\n\tvar router_1 = __webpack_require__(27);\n\t/** @hidden */\n\tvar stateSelf = hof_1.prop(\"self\");\n\t/**\n\t * Represents a transition between two states.\n\t *\n\t * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n\t *\n\t * This object contains all contextual information about the to/from states, parameters, resolves.\n\t * It has information about all states being entered and exited as a result of the transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param router The [[UIRouter]] instance\n\t     */\n\t    function Transition(fromPath, targetState, router) {\n\t        var _this = this;\n\t        /** @hidden */\n\t        this._deferred = coreservices_1.services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\t        this._registeredHooks = {};\n\t        /**\n\t         * Checks if this transition is currently active/running.\n\t         */\n\t        this.isActive = function () { return _this === _this._options.current(); };\n\t        this.router = router;\n\t        this._targetState = targetState;\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t        this.$id = router.transitionService._transitionCount++;\n\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        this.createTransitionHookRegFns();\n\t        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n\t        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n\t        this.applyViewConfigs(router);\n\t        this.applyRootResolvables(router);\n\t    }\n\t    /** @hidden */\n\t    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onError = function (criteria, callback, options) { return; };\n\t    /** @hidden\n\t     * Creates the transition-level hook registration functions\n\t     * (which can then be used to register hooks)\n\t     */\n\t    Transition.prototype.createTransitionHookRegFns = function () {\n\t        var _this = this;\n\t        this.router.transitionService._pluginapi._getEvents()\n\t            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n\t            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n\t    };\n\t    /** @internalapi */\n\t    Transition.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    Transition.prototype.applyViewConfigs = function (router) {\n\t        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n\t        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n\t    };\n\t    Transition.prototype.applyRootResolvables = function (router) {\n\t        var _this = this;\n\t        var rootResolvables = [\n\t            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n\t            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n\t        ];\n\t        var rootNode = this._treeChanges.to[0];\n\t        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n\t        context.addResolvables(rootResolvables, rootNode.state);\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal from [State] object\n\t     */\n\t    Transition.prototype.$from = function () {\n\t        return common_1.tail(this._treeChanges.from).state;\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal to [State] object\n\t     */\n\t    Transition.prototype.$to = function () {\n\t        return common_1.tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * Returns the state that the transition is coming *from*.\n\t     *\n\t     * @returns The state declaration object for the Transition's (\"from state\").\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * Returns the state that the transition is going *to*.\n\t     *\n\t     * @returns The state declaration object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Gets the Target State\n\t     *\n\t     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n\t     *\n\t     * @returns the [[TargetState]] of this Transition\n\t     */\n\t    Transition.prototype.targetState = function () {\n\t        return this._targetState;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n\t    };\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    /**\n\t     * Creates a [[UIInjector]] Dependency Injector\n\t     *\n\t     * Returns a Dependency Injector for the Transition's target state (to state).\n\t     * The injector provides resolve values which the target state has access to.\n\t     *\n\t     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ entering: 'myState' }, trans => {\n\t     *   var myResolveValue = trans.injector().get('myResolve');\n\t     *   // Inject a global service from the global/native injector (if it exists)\n\t     *   var MyService = trans.injector().get('MyService');\n\t     * })\n\t     * ```\n\t     *\n\t     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n\t     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n\t     * #### Example:\n\t     * ```js\n\t     * .onBefore({}, trans => {\n\t     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n\t     *     return myResolveValue !== 'ABORT';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n\t     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ to: 'foo.bar' }, trans => {\n\t     *   // returns result of `foo` state's `data` resolve\n\t     *   // even though `foo.bar` also has a `data` resolve\n\t     *   var fooData = trans.injector('foo').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n\t     * The resolve data from the `from` path will be returned.\n\t     * #### Example:\n\t     * ```js\n\t     * .onExit({ exiting: 'foo.bar' }, trans => {\n\t     *   // Gets the resolve value of `data` from the exiting state.\n\t     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n\t     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n\t     *\n\t     * @returns a [[UIInjector]]\n\t     */\n\t    Transition.prototype.injector = function (state, pathName) {\n\t        if (pathName === void 0) { pathName = \"to\"; }\n\t        var path = this._treeChanges[pathName];\n\t        if (state)\n\t            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n\t        return new resolveContext_1.ResolveContext(path).injector();\n\t    };\n\t    /**\n\t     * Gets all available resolve tokens (keys)\n\t     *\n\t     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n\t     * available to the Transition.\n\t     *\n\t     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n\t     * in the Transition's [[TreeChanges.to]] path.\n\t     *\n\t     * #### Example:\n\t     * This example logs all resolve values\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n\t     * ```\n\t     *\n\t     * #### Example:\n\t     * This example creates promises for each resolve value.\n\t     * This triggers fetches of resolves (if any have not yet been fetched).\n\t     * When all promises have all settled, it logs the resolve values.\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * let promise = tokens.map(token => trans.injector().getAsync(token));\n\t     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n\t     * ```\n\t     *\n\t     * Note: Angular 1 users whould use `$q.all()`\n\t     *\n\t     * @param pathname resolve context's path name (e.g., `to` or `from`)\n\t     *\n\t     * @returns an array of resolve tokens (keys)\n\t     */\n\t    Transition.prototype.getResolveTokens = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n\t    };\n\t    /**\n\t     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * transitionService.onBefore({}, transition => {\n\t     *   transition.addResolvable({\n\t     *     token: 'myResolve',\n\t     *     deps: ['MyService'],\n\t     *     resolveFn: myService => myService.getData()\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n\t     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolvable = function (resolvable, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t        var resolveContext = new resolveContext_1.ResolveContext(topath);\n\t        resolveContext.addResolvables([resolvable], targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the transition from which this transition was redirected.\n\t     *\n\t     * If the current transition is a redirect, this method returns the transition that was redirected.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let transitionA = $state.go('A').transition\n\t     * transitionA.onStart({}, () => $state.target('B'));\n\t     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n\t     *   trans.to().name === 'B'; // true\n\t     *   trans.redirectedFrom() === transitionA; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.redirectedFrom = function () {\n\t        return this._options.redirectedFrom || null;\n\t    };\n\t    /**\n\t     * Gets the original transition in a redirect chain\n\t     *\n\t     * A transition might belong to a long chain of multiple redirects.\n\t     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * // states\n\t     * registry.register({ name: 'A', redirectTo: 'B' });\n\t     * registry.register({ name: 'B', redirectTo: 'C' });\n\t     * registry.register({ name: 'C', redirectTo: 'D' });\n\t     * registry.register({ name: 'D' });\n\t     *\n\t     * let transitionA = $state.go('A').transition\n\t     *\n\t     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n\t     *   trans.to().name === 'D'; // true\n\t     *   trans.redirectedFrom().to().name === 'C'; // true\n\t     *   trans.originalTransition() === transitionA; // true\n\t     *   trans.originalTransition().to().name === 'A'; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The original Transition that started a redirect chain\n\t     */\n\t    Transition.prototype.originalTransition = function () {\n\t        var rf = this.redirectedFrom();\n\t        return (rf && rf.originalTransition()) || this;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t    };\n\t    Transition.prototype.treeChanges = function (pathname) {\n\t        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n\t    };\n\t    /**\n\t     * Creates a new transition that is a redirection of the current one.\n\t     *\n\t     * This transition can be returned from a [[TransitionService]] hook to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns Returns a new [[Transition]] instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var redirects = 1, trans = this;\n\t        while ((trans = trans.redirectedFrom()) != null) {\n\t            if (++redirects > 20)\n\t                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n\t        }\n\t        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n\t        // If the original transition was caused by URL sync, then use { location: 'replace' }\n\t        // on the new transition (unless  the target state explicitly specifies location)\n\t        if (this.options().source === 'url') {\n\t            redirectOpts.location = 'replace';\n\t        }\n\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n\t        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n\t        var originalEnteringNodes = this._treeChanges.entering;\n\t        var redirectEnteringNodes = newTransition._treeChanges.entering;\n\t        // --- Re-use resolve data from original transition ---\n\t        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n\t        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n\t        // redirected transition.\n\t        //\n\t        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n\t        // You can wait for the resolve, then redirect to a child state based on the result.\n\t        // The redirected transition does not have to re-fetch the resolve.\n\t        // ---------------------------------------------------------\n\t        var nodeIsReloading = function (reloadState) { return function (node) {\n\t            return reloadState && node.state.includes[reloadState.name];\n\t        }; };\n\t        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\t        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n\t            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n\t        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\t        matchingEnteringNodes.forEach(function (node, idx) {\n\t            node.resolvables = originalEnteringNodes[idx].resolvables;\n\t        });\n\t        return newTransition;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var tc = this._treeChanges;\n\t        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n\t        // If user explicitly wants a reload\n\t        if (this._options.reload)\n\t            return undefined;\n\t        // If any states are exiting or entering\n\t        if (tc.exiting.length || tc.entering.length)\n\t            return undefined;\n\t        // If to/from path lengths differ\n\t        if (tc.to.length !== tc.from.length)\n\t            return undefined;\n\t        // If the to/from paths are different\n\t        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n\t            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n\t            .reduce(common_1.anyTrueR, false);\n\t        if (pathsDiffer)\n\t            return undefined;\n\t        // Find any parameter values that differ\n\t        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n\t        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return param_1.Param.changed(schema, toVals, fromVals);\n\t        }).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.length === 0;\n\t    };\n\t    /**\n\t     * @hidden\n\t     */\n\t    Transition.prototype.hookBuilder = function () {\n\t        return new hookBuilder_1.HookBuilder(this);\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n\t        var hookBuilder = this.hookBuilder();\n\t        var globals = this.router.globals;\n\t        globals.transitionHistory.enqueue(this);\n\t        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n\t        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t            var rejectReason = syncResult._transitionRejection;\n\t            this._deferred.reject(rejectReason);\n\t            return this.promise;\n\t        }\n\t        if (!this.valid()) {\n\t            var error = new Error(this.error());\n\t            this._deferred.reject(error);\n\t            return this.promise;\n\t        }\n\t        if (this.ignored()) {\n\t            trace_1.trace.traceTransitionIgnored(this);\n\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t            return this.promise;\n\t        }\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var transitionSuccess = function () {\n\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this.to());\n\t            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n\t            runAllHooks(onSuccessHooks);\n\t        };\n\t        var transitionError = function (reason) {\n\t            trace_1.trace.traceError(reason, _this);\n\t            _this.success = false;\n\t            _this._deferred.reject(reason);\n\t            _this._error = reason;\n\t            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n\t            runAllHooks(onErrorHooks);\n\t        };\n\t        trace_1.trace.traceTransitionStart(this);\n\t        // Chain the next hook off the previous\n\t        var appendHookToChain = function (prev, nextHook) {\n\t            return prev.then(function () { return nextHook.invokeHook(); });\n\t        };\n\t        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n\t        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n\t        asyncHooks.reduce(appendHookToChain, syncResult)\n\t            .then(transitionSuccess, transitionError);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error() || this.success !== undefined;\n\t    };\n\t    /**\n\t     * The Transition error reason.\n\t     *\n\t     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n\t     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n\t     *\n\t     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self.abstract)\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        if (!param_1.Param.validates(state.parameters(), this.params()))\n\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t        if (this.success === false)\n\t            return this._error;\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    return Transition;\n\t}());\n\t/** @hidden */\n\tTransition.diToken = Transition;\n\texports.Transition = Transition;\n\t//# sourceMappingURL=transition.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * # Transition tracing (debug)\n\t *\n\t * Enable transition tracing to print transition information to the console,\n\t * in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n\t *\n\t * ### ES6\n\t * ```js\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * ### CJS\n\t * ```js\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * ### Globals\n\t * ```js\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * ### Angular 1:\n\t * ```js\n\t * app.run($trace => $trace.enable());\n\t * ```\n\t *\n\t * @coreapi\n\t * @module trace\n\t */ /** for typedoc */\n\tvar hof_1 = __webpack_require__(7);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(11);\n\t/** @hidden */\n\tfunction uiViewString(viewData) {\n\t    if (!viewData)\n\t        return 'ui-view (defunct)';\n\t    return \"[ui-view#\" + viewData.id + \" tag \" +\n\t        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n\t        (\"fqn: '\" + viewData.fqn + \"', \") +\n\t        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t}\n\t/**\n\t * Trace categories Enum\n\t *\n\t * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\tvar Category;\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n\t})(Category = exports.Category || (exports.Category = {}));\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    /** @hidden */\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(Category)\n\t                .map(function (k) { return parseInt(k, 10); })\n\t                .filter(function (k) { return !isNaN(k); })\n\t                .map(function (key) { return Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    /**\n\t     * Enables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enable(\"TRANSITION\");\n\t     * ```\n\t     *\n\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    /**\n\t     * Disables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.disable(\"VIEWCONFIG\");\n\t     * ```\n\t     *\n\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, when, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceError = function (reason, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewFill = function (viewData, html) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\texports.Trace = Trace;\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * #### Example:\n\t * ```js\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\texports.trace = trace;\n\t//# sourceMappingURL=trace.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar TransitionHookPhase;\n\t(function (TransitionHookPhase) {\n\t    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n\t    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n\t})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\tvar TransitionHookScope;\n\t(function (TransitionHookScope) {\n\t    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n\t    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n\t})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar strings_1 = __webpack_require__(11);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(7);\n\tvar trace_1 = __webpack_require__(14);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar rejectFactory_1 = __webpack_require__(12);\n\tvar targetState_1 = __webpack_require__(17);\n\tvar defaultOptions = {\n\t    current: common_1.noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null\n\t};\n\t/** @hidden */\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(transition, stateContext, registeredHook, options) {\n\t        var _this = this;\n\t        this.transition = transition;\n\t        this.stateContext = stateContext;\n\t        this.registeredHook = registeredHook;\n\t        this.options = options;\n\t        this.stateService = function () { return _this.transition.router.stateService; };\n\t        this.rejectIfSuperseded = function () {\n\t            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n\t        };\n\t        this.options = common_1.defaults(options, defaultOptions);\n\t    }\n\t    TransitionHook.prototype.invokeHook = function () {\n\t        var hook = this.registeredHook;\n\t        if (hook._deregistered)\n\t            return;\n\t        var options = this.options;\n\t        trace_1.trace.traceHookInvocation(this, this.transition, options);\n\t        if (this.rejectIfSuperseded()) {\n\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t        }\n\t        var cb = hook.callback;\n\t        var bind = this.options.bind;\n\t        var trans = this.transition;\n\t        var state = this.stateContext;\n\t        var errorHandler = hook.eventType.getErrorHandler(this);\n\t        var resultHandler = hook.eventType.getResultHandler(this);\n\t        resultHandler = resultHandler || common_1.identity;\n\t        if (!errorHandler) {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        try {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        catch (error) {\n\t            return errorHandler(error);\n\t        }\n\t    };\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false (cancel), a TargetState (redirect),\n\t     * or a promise (which may later resolve to false or a redirect)\n\t     *\n\t     * This also handles \"transition superseded\" -- when a new transition\n\t     * was started while the hook was still running\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (result) {\n\t        // This transition is no longer current.\n\t        // Another transition started while this hook was still running.\n\t        if (this.rejectIfSuperseded()) {\n\t            // Abort this transition\n\t            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n\t        }\n\t        // Hook returned a promise\n\t        if (predicates_1.isPromise(result)) {\n\t            // Wait for the promise, then reprocess the resolved value\n\t            return result.then(this.handleHookResult.bind(this));\n\t        }\n\t        trace_1.trace.traceHookResult(result, this.transition, this.options);\n\t        // Hook returned false\n\t        if (result === false) {\n\t            // Abort this Transition\n\t            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n\t        }\n\t        var isTargetState = hof_1.is(targetState_1.TargetState);\n\t        // hook returned a TargetState\n\t        if (isTargetState(result)) {\n\t            // Halt the current Transition and start a redirected Transition (to the TargetState).\n\t            return rejectFactory_1.Rejection.redirected(result).toPromise();\n\t        }\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t    };\n\t    /**\n\t     * Run all TransitionHooks, ignoring their return value.\n\t     */\n\t    TransitionHook.runAllHooks = function (hooks) {\n\t        hooks.forEach(function (hook) { return hook.invokeHook(); });\n\t    };\n\t    /**\n\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n\t     *\n\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t     */\n\t    TransitionHook.runOnBeforeHooks = function (hooks) {\n\t        var results = [];\n\t        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n\t            var hook = hooks_1[_i];\n\t            var hookResult = hook.invokeHook();\n\t            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n\t                // Break on first thrown error or false/TargetState\n\t                return hookResult;\n\t            }\n\t            results.push(hookResult);\n\t        }\n\t        return results\n\t            .filter(predicates_1.isPromise)\n\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t    };\n\t    return TransitionHook;\n\t}());\n\tTransitionHook.HANDLE_RESULT = function (hook) {\n\t    return function (result) {\n\t        return hook.handleHookResult(result);\n\t    };\n\t};\n\tTransitionHook.IGNORE_RESULT = function (hook) {\n\t    return function (result) { return undefined; };\n\t};\n\tTransitionHook.LOG_ERROR = function (hook) {\n\t    return function (error) {\n\t        return (hook.stateService().defaultErrorHandler()(error), undefined);\n\t    };\n\t};\n\tTransitionHook.REJECT_ERROR = function (hook) {\n\t    return function (error) {\n\t        return rejectFactory_1.Rejection.errored(error).toPromise();\n\t    };\n\t};\n\tTransitionHook.THROW_ERROR = function (hook) {\n\t    return undefined;\n\t};\n\texports.TransitionHook = TransitionHook;\n\t//# sourceMappingURL=transitionHook.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\t/**\n\t * Encapsulate the target (destination) state/params/options of a [[Transition]].\n\t *\n\t * This class is frequently used to redirect a transition to a new destination.\n\t *\n\t * See:\n\t *\n\t * - [[HookResult]]\n\t * - [[TransitionHookFn]]\n\t * - [[TransitionService.onStart]]\n\t *\n\t * To create a `TargetState`, use [[StateService.target]].\n\t *\n\t * ---\n\t *\n\t * This class wraps:\n\t *\n\t * 1) an identifier for a state\n\t * 2) a set of parameters\n\t * 3) and transition options\n\t * 4) the registered state object (the [[StateDeclaration]])\n\t *\n\t * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n\t * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n\t * The `TargetState` class normalizes those options.\n\t *\n\t * A `TargetState` may be valid (the state being targeted exists in the registry)\n\t * or invalid (the state being targeted is not registered).\n\t */\n\tvar TargetState = (function () {\n\t    /**\n\t     * The TargetState constructor\n\t     *\n\t     * Note: Do not construct a `TargetState` manually.\n\t     * To create a `TargetState`, use the [[StateService.target]] factory method.\n\t     *\n\t     * @param _identifier An identifier for a state.\n\t     *    Either a fully-qualified state name, or the object used to define the state.\n\t     * @param _definition The internal state representation, if exists.\n\t     * @param _params Parameters for the target state\n\t     * @param _options Transition options.\n\t     *\n\t     * @internalapi\n\t     */\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    /** The name of the state this object targets */\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    /** The identifier used when creating this TargetState */\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    /** The target parameter values */\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    /** The internal state object (if it was found) */\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    /** The internal state declaration (if it was found) */\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    /** The target options */\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /** True if the target state was found */\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    /** True if the object is valid */\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /** If the object is invalid, returns the reason why */\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    TargetState.prototype.toString = function () {\n\t        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n\t    };\n\t    return TargetState;\n\t}());\n\t/** Returns true if the object has a state property that might be a state or state name */\n\tTargetState.isDef = function (obj) {\n\t    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n\t};\n\texports.TargetState = TargetState;\n\t//# sourceMappingURL=targetState.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar interface_1 = __webpack_require__(15); // has or is using\n\tvar glob_1 = __webpack_require__(9);\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t *\n\t * @hidden\n\t *\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = new glob_1.Glob(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\texports.matchState = matchState;\n\t/**\n\t * @internalapi\n\t * The registration data for a registered transition hook\n\t */\n\tvar RegisteredHook = (function () {\n\t    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.tranSvc = tranSvc;\n\t        this.eventType = eventType;\n\t        this.callback = callback;\n\t        this.matchCriteria = matchCriteria;\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t        this._deregistered = false;\n\t    }\n\t    /**\n\t     * Gets the matching [[PathNode]]s\n\t     *\n\t     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n\t     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n\t     *\n\t     * Returning `null` is significant to distinguish between the default\n\t     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n\t     * when the nodes is an empty array.\n\t     *\n\t     * This is useful to allow a transition match criteria of `entering: true`\n\t     * to still match a transition, even when `entering === []`.  Contrast that\n\t     * with `entering: (state) => true` which only matches when a state is actually\n\t     * being entered.\n\t     */\n\t    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Gets the default match criteria (all `true`)\n\t     *\n\t     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n\t     *\n\t     * ```js\n\t     * {\n\t     *   to: true,\n\t     *   from: true,\n\t     *   entering: true,\n\t     *   exiting: true,\n\t     *   retained: true,\n\t     * }\n\t     */\n\t    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n\t        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n\t    };\n\t    /**\n\t     * Gets matching nodes as [[IMatchingNodes]]\n\t     *\n\t     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n\t     *\n\t     * ```js\n\t     * let matches: IMatchingNodes = {\n\t     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n\t     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n\t     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n\t     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n\t     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n\t     * };\n\t     * ```\n\t     */\n\t    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n\t        var _this = this;\n\t        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n\t        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n\t        return paths.reduce(function (mn, pathtype) {\n\t            // STATE scope criteria matches against every node in the path.\n\t            // TRANSITION scope criteria matches against only the last node in the path\n\t            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n\t            var path = treeChanges[pathtype.name] || [];\n\t            var nodes = isStateHook ? path : [common_1.tail(path)];\n\t            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n\t            return mn;\n\t        }, {});\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    RegisteredHook.prototype.matches = function (treeChanges) {\n\t        var matches = this._getMatchingNodes(treeChanges);\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = common_1.values(matches).every(common_1.identity);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return RegisteredHook;\n\t}());\n\texports.RegisteredHook = RegisteredHook;\n\t/** @hidden Return a registration function of the requested type. */\n\tfunction makeEvent(registry, transitionService, eventType) {\n\t    // Create the object which holds the registered transition hooks.\n\t    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n\t    var hooks = _registeredHooks[eventType.name] = [];\n\t    // Create hook registration function on the IHookRegistry for the event\n\t    registry[eventType.name] = hookRegistrationFn;\n\t    function hookRegistrationFn(matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n\t        hooks.push(registeredHook);\n\t        return function deregisterEventHook() {\n\t            registeredHook._deregistered = true;\n\t            common_1.removeFrom(hooks)(registeredHook);\n\t        };\n\t    }\n\t    return hookRegistrationFn;\n\t}\n\texports.makeEvent = makeEvent;\n\t//# sourceMappingURL=hookRegistry.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar interface_1 = __webpack_require__(15);\n\tvar transitionHook_1 = __webpack_require__(16);\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder(transition) {\n\t        this.transition = transition;\n\t        this.treeChanges = transition.treeChanges();\n\t        this.transitionOptions = transition.options();\n\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t        this.$transitions = transition.router.transitionService;\n\t        this.baseHookOptions = {\n\t            transition: transition,\n\t            current: transition.options().current\n\t        };\n\t    }\n\t    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n\t        var _this = this;\n\t        return this.$transitions._pluginapi._getEvents(phase)\n\t            .map(function (type) { return _this.buildHooks(type); })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(common_1.identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[PathNode]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     */\n\t    HookBuilder.prototype.buildHooks = function (hookType) {\n\t        var _this = this;\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(_this.treeChanges);\n\t            // Select the PathNode[] that will be used as TransitionHook context objects\n\t            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n\t            // Return an array of HookTuples\n\t            return matchingNodes.map(function (node) {\n\t                var _options = common_1.extend({\n\t                    bind: hook.bind,\n\t                    traceData: { hookType: hookType.name, context: node }\n\t                }, _this.baseHookOptions);\n\t                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n\t                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(common_1.unnestR, [])\n\t            .sort(tupleSort(hookType.reverseSort))\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all RegisteredHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[RegisteredHook]]s\n\t     */\n\t    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n\t        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n\t        // Instance and Global hook registries\n\t        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n\t        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n\t            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\texports.HookBuilder = HookBuilder;\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\t//# sourceMappingURL=hookBuilder.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module path */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar param_1 = __webpack_require__(21);\n\t/**\n\t * A node in a [[TreeChanges]] path\n\t *\n\t * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n\t * Each PathNode corresponds to a state being entered, exited, or retained.\n\t * The stateful information includes parameter values and resolve data.\n\t */\n\tvar PathNode = (function () {\n\t    function PathNode(stateOrPath) {\n\t        if (stateOrPath instanceof PathNode) {\n\t            var node = stateOrPath;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t            this.resolvables = node.resolvables.slice();\n\t            this.views = node.views && node.views.slice();\n\t        }\n\t        else {\n\t            var state = stateOrPath;\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n\t        }\n\t    }\n\t    /** Sets [[paramValues]] for the node, from the values of an object hash */\n\t    PathNode.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    /** Gets a specific [[Param]] metadata that belongs to the node */\n\t    PathNode.prototype.parameter = function (name) {\n\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t    };\n\t    /**\n\t     * @returns true if the state and parameter values for another PathNode are\n\t     * equal to the state and param values for this PathNode\n\t     */\n\t    PathNode.prototype.equals = function (node, keys) {\n\t        var _this = this;\n\t        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n\t        var paramValsEq = function (key) {\n\t            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n\t        };\n\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t    };\n\t    /** Returns a clone of the PathNode */\n\t    PathNode.clone = function (node) {\n\t        return new PathNode(node);\n\t    };\n\t    /**\n\t     * Returns a new path which is a subpath of the first path which matched the second path.\n\t     *\n\t     * The new path starts from root and contains any nodes that match the nodes in the second path.\n\t     * Nodes are compared using their state property and parameter values.\n\t     *\n\t     * @param pathA the first path\n\t     * @param pathB the second path\n\t     * @param ignoreDynamicParams don't compare dynamic parameter values\n\t     */\n\t    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n\t        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n\t        var matching = [];\n\t        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n\t            var a = pathA[i], b = pathB[i];\n\t            if (a.state !== b.state)\n\t                break;\n\t            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n\t                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n\t            if (changedParams.length)\n\t                break;\n\t            matching.push(a);\n\t        }\n\t        return matching;\n\t    };\n\t    return PathNode;\n\t}());\n\texports.PathNode = PathNode;\n\t//# sourceMappingURL=node.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar paramType_1 = __webpack_require__(22);\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar isShorthand = function (cfg) {\n\t    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\t};\n\tvar DefType;\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(DefType = exports.DefType || (exports.DefType = {}));\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    return common_1.extend(cfg, {\n\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t    });\n\t}\n\tfunction getType(cfg, urlType, location, id, paramTypes) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n\t        return paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type) {\n\t        var type = location === DefType.CONFIG ? \"any\" :\n\t            location === DefType.PATH ? \"path\" :\n\t                location === DefType.SEARCH ? \"query\" : \"string\";\n\t        return paramTypes.type(type);\n\t    }\n\t    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t        return defaultPolicy;\n\t    if (squash === true || predicates_1.isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t    ];\n\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t    if (predicates_1.isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\tvar Param = (function () {\n\t    function Param(id, type, config, location, urlMatcherFactory) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n\t        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n\t        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n\t        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var $$getDefaultValue = function () {\n\t            if (!coreservices_1.services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\t            return defaultValue;\n\t        };\n\t        var $replace = function (val) {\n\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t            return replacement.length ? replacement[0] : val;\n\t        };\n\t        value = $replace(value);\n\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    Param.values = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\texports.Param = Param;\n\t//# sourceMappingURL=param.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\t/**\n\t * An internal class which implements [[ParamTypeDefinition]].\n\t *\n\t * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n\t * When a param type definition is registered, an instance of this class is created internally.\n\t *\n\t * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n\t *\n\t * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n\t *\n\t * #### Example:\n\t * ```js\n\t * var paramTypeDef = {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t *\n\t * var paramType = new ParamType(paramTypeDef);\n\t * ```\n\t * @internalapi\n\t */\n\tvar ParamType = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n\t     * @returns a new ParamType object\n\t     */\n\t    function ParamType(def) {\n\t        /** @inheritdoc */\n\t        this.pattern = /.*/;\n\t        /** @inheritdoc */\n\t        this.inherit = true;\n\t        common_1.extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    ParamType.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.equals = function (a, b) { return a == b; };\n\t    ParamType.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    ParamType.prototype.toString = function () {\n\t        return \"{ParamType:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    ParamType.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    ParamType.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t/**\n\t * Wraps up a `ParamType` object to handle array values.\n\t * @internalapi\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) {\n\t        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n\t    }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (predicates_1.isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = common_1.map(arr, callback);\n\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n\t        var paramTypeFn = type[name].bind(type);\n\t        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n\t        _this[name] = wrapperFn(paramTypeFn);\n\t    });\n\t    common_1.extend(this, {\n\t        dynamic: type.dynamic,\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        inherit: type.inherit,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t//# sourceMappingURL=paramType.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module path */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar targetState_1 = __webpack_require__(17);\n\tvar node_1 = __webpack_require__(20);\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathFactory = (function () {\n\t    function PathFactory() {\n\t    }\n\t    /** Given a PathNode[], create an TargetState */\n\t    PathFactory.makeTargetState = function (path) {\n\t        var state = common_1.tail(path).state;\n\t        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    PathFactory.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathFactory.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    /**\n\t     * Creates ViewConfig objects and adds to nodes.\n\t     *\n\t     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n\t     */\n\t    PathFactory.applyViewConfigs = function ($view, path, states) {\n\t        // Only apply the viewConfigs to the nodes for the given states\n\t        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n\t            var viewDecls = common_1.values(node.state.views || {});\n\t            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n\t            node.views = viewConfigs.reduce(common_1.unnestR, []);\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t            return common_1.extend({}, node && node.paramValues);\n\t        }\n\t        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (param) { return !param.inherit; })\n\t            .map(hof_1.prop('id'));\n\t        /**\n\t         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        function makeInheritedParamsNode(toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n\t            toParamVals = common_1.omit(toParamVals, toKeys);\n\t            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n\t        }\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode);\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var staticParams = function (state) {\n\t            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n\t        };\n\t        var nodesMatch = function (node1, node2) {\n\t            return node1.equals(node2, staticParams(node1.state));\n\t        };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = node_1.PathNode.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        var retainedWithToParams = retained.map(applyToParams);\n\t        entering = toPath.slice(keep);\n\t        to = (retainedWithToParams).concat(entering);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    /**\n\t     * Return a subpath of a path, which stops at the first matching node\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node,\n\t     * stopping when the first node matches the predicate.\n\t     *\n\t     * @param path a path of [[PathNode]]s\n\t     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n\t     * @returns a subpath up to the matching node, or undefined if no match is found\n\t     */\n\t    PathFactory.subPath = function (path, predicate) {\n\t        var node = common_1.find(path, predicate);\n\t        var elementIdx = path.indexOf(node);\n\t        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n\t    };\n\t    return PathFactory;\n\t}());\n\t/** Gets the raw parameter values from a path */\n\tPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\texports.PathFactory = PathFactory;\n\t//# sourceMappingURL=pathFactory.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module resolve\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(14);\n\tvar strings_1 = __webpack_require__(11);\n\tvar predicates_1 = __webpack_require__(6);\n\t// TODO: explicitly make this user configurable\n\texports.defaultResolvePolicy = {\n\t    when: \"LAZY\",\n\t    async: \"WAIT\"\n\t};\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(arg1, resolveFn, deps, policy, data) {\n\t        this.resolved = false;\n\t        this.promise = undefined;\n\t        if (arg1 instanceof Resolvable) {\n\t            common_1.extend(this, arg1);\n\t        }\n\t        else if (predicates_1.isFunction(resolveFn)) {\n\t            if (arg1 == null || arg1 == undefined)\n\t                throw new Error(\"new Resolvable(): token argument is required\");\n\t            if (!predicates_1.isFunction(resolveFn))\n\t                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\t            this.token = arg1;\n\t            this.policy = policy;\n\t            this.resolveFn = resolveFn;\n\t            this.deps = deps || [];\n\t            this.data = data;\n\t            this.resolved = data !== undefined;\n\t            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n\t        }\n\t        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n\t            var literal = arg1;\n\t            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n\t        }\n\t    }\n\t    Resolvable.prototype.getPolicy = function (state) {\n\t        var thisPolicy = this.policy || {};\n\t        var statePolicy = state && state.resolvePolicy || {};\n\t        return {\n\t            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n\t            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n\t        };\n\t    };\n\t    /**\n\t     * Asynchronously resolve this Resolvable's data\n\t     *\n\t     * Given a ResolveContext that this Resolvable is found in:\n\t     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n\t     * and update the Resolvable's state\n\t     */\n\t    Resolvable.prototype.resolve = function (resolveContext, trans) {\n\t        var _this = this;\n\t        var $q = coreservices_1.services.$q;\n\t        // Gets all dependencies from ResolveContext and wait for them to be resolved\n\t        var getResolvableDependencies = function () {\n\t            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n\t                return r.get(resolveContext, trans);\n\t            }));\n\t        };\n\t        // Invokes the resolve function passing the resolved dependencies as arguments\n\t        var invokeResolveFn = function (resolvedDeps) {\n\t            return _this.resolveFn.apply(null, resolvedDeps);\n\t        };\n\t        /**\n\t         * For RXWAIT policy:\n\t         *\n\t         * Given an observable returned from a resolve function:\n\t         * - enables .cache() mode (this allows multicast subscribers)\n\t         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n\t         * - Waits for the promise, then return the cached observable (not the first emitted value).\n\t         */\n\t        var waitForRx = function (observable$) {\n\t            var cached = observable$.cache(1);\n\t            return cached.take(1).toPromise().then(function () { return cached; });\n\t        };\n\t        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n\t        var node = resolveContext.findNode(this);\n\t        var state = node && node.state;\n\t        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n\t        // After the final value has been resolved, update the state of the Resolvable\n\t        var applyResolvedValue = function (resolvedValue) {\n\t            _this.data = resolvedValue;\n\t            _this.resolved = true;\n\t            trace_1.trace.traceResolvableResolved(_this, trans);\n\t            return _this.data;\n\t        };\n\t        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\t        return this.promise = $q.when()\n\t            .then(getResolvableDependencies)\n\t            .then(invokeResolveFn)\n\t            .then(maybeWaitForRx)\n\t            .then(applyResolvedValue);\n\t    };\n\t    /**\n\t     * Gets a promise for this Resolvable's data.\n\t     *\n\t     * Fetches the data and returns a promise.\n\t     * Returns the existing promise if it has already been fetched once.\n\t     */\n\t    Resolvable.prototype.get = function (resolveContext, trans) {\n\t        return this.promise || this.resolve(resolveContext, trans);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n\t    };\n\t    Resolvable.prototype.clone = function () {\n\t        return new Resolvable(this);\n\t    };\n\t    return Resolvable;\n\t}());\n\tResolvable.fromData = function (token, data) {\n\t    return new Resolvable(token, function () { return data; }, null, null, data);\n\t};\n\texports.Resolvable = Resolvable;\n\t//# sourceMappingURL=resolvable.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar trace_1 = __webpack_require__(14);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar interface_1 = __webpack_require__(26);\n\tvar resolvable_1 = __webpack_require__(24);\n\tvar pathFactory_1 = __webpack_require__(23);\n\tvar strings_1 = __webpack_require__(11);\n\tvar when = interface_1.resolvePolicies.when;\n\tvar ALL_WHENS = [when.EAGER, when.LAZY];\n\tvar EAGER_WHENS = [when.EAGER];\n\texports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n\t/**\n\t * Encapsulates Depenency Injection for a path of nodes\n\t *\n\t * UI-Router states are organized as a tree.\n\t * A nested state has a path of ancestors to the root of the tree.\n\t * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n\t * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n\t *\n\t * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n\t */\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t    }\n\t    /** Gets all the tokens found in the resolve context, de-duplicated */\n\t    ResolveContext.prototype.getTokens = function () {\n\t        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n\t    };\n\t    /**\n\t     * Gets the Resolvable that matches the token\n\t     *\n\t     * Gets the last Resolvable that matches the token in this context, or undefined.\n\t     * Throws an error if it doesn't exist in the ResolveContext\n\t     */\n\t    ResolveContext.prototype.getResolvable = function (token) {\n\t        var matching = this._path.map(function (node) { return node.resolvables; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (r) { return r.token === token; });\n\t        return common_1.tail(matching);\n\t    };\n\t    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\t    ResolveContext.prototype.getPolicy = function (resolvable) {\n\t        var node = this.findNode(resolvable);\n\t        return resolvable.getPolicy(node.state);\n\t    };\n\t    /**\n\t     * Returns a ResolveContext that includes a portion of this one\n\t     *\n\t     * Given a state, this method creates a new ResolveContext from this one.\n\t     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n\t     *\n\t     * #### Why\n\t     *\n\t     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n\t     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n\t     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n\t     * This method is used to create a narrower context when injecting ancestor nodes.\n\t     *\n\t     * @example\n\t     * `let ABCD = new ResolveContext([A, B, C, D]);`\n\t     *\n\t     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n\t     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n\t     * However, `B` should only be able to access resolvables from `A`, `B`.\n\t     *\n\t     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n\t     * `let AB = ABCD.subcontext(a)`\n\t     */\n\t    ResolveContext.prototype.subContext = function (state) {\n\t        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n\t    };\n\t    /**\n\t     * Adds Resolvables to the node that matches the state\n\t     *\n\t     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n\t     * The resolvable is added to the node matching the `state` parameter.\n\t     *\n\t     * These new resolvables are not automatically fetched.\n\t     * The calling code should either fetch them, fetch something that depends on them,\n\t     * or rely on [[resolvePath]] being called when some state is being entered.\n\t     *\n\t     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n\t     *\n\t     * @param newResolvables the new Resolvables\n\t     * @param state Used to find the node to put the resolvable on\n\t     */\n\t    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n\t        var node = common_1.find(this._path, hof_1.propEq('state', state));\n\t        var keys = newResolvables.map(function (r) { return r.token; });\n\t        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n\t    };\n\t    /**\n\t     * Returns a promise for an array of resolved path Element promises\n\t     *\n\t     * @param when\n\t     * @param trans\n\t     * @returns {Promise<any>|any}\n\t     */\n\t    ResolveContext.prototype.resolvePath = function (when, trans) {\n\t        var _this = this;\n\t        if (when === void 0) { when = \"LAZY\"; }\n\t        // This option determines which 'when' policy Resolvables we are about to fetch.\n\t        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n\t        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n\t        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\t        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\t        // get the subpath to the state argument, if provided\n\t        trace_1.trace.traceResolvePath(this._path, when, trans);\n\t        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n\t            return function (resolvable) {\n\t                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n\t            };\n\t        };\n\t        // Trigger all the (matching) Resolvables in the path\n\t        // Reduce all the \"WAIT\" Resolvables into an array\n\t        var promises = this._path.reduce(function (acc, node) {\n\t            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n\t            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n\t            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n\t            // For the matching Resolvables, start their async fetch process.\n\t            var subContext = _this.subContext(node.state);\n\t            var getResult = function (r) { return r.get(subContext, trans)\n\t                .then(function (value) { return ({ token: r.token, value: value }); }); };\n\t            nowait.forEach(getResult);\n\t            return acc.concat(wait.map(getResult));\n\t        }, []);\n\t        // Wait for all the \"WAIT\" resolvables\n\t        return coreservices_1.services.$q.all(promises);\n\t    };\n\t    ResolveContext.prototype.injector = function () {\n\t        return this._injector || (this._injector = new UIInjectorImpl(this));\n\t    };\n\t    ResolveContext.prototype.findNode = function (resolvable) {\n\t        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n\t    };\n\t    /**\n\t     * Gets the async dependencies of a Resolvable\n\t     *\n\t     * Given a Resolvable, returns its dependencies as a Resolvable[]\n\t     */\n\t    ResolveContext.prototype.getDependencies = function (resolvable) {\n\t        var _this = this;\n\t        var node = this.findNode(resolvable);\n\t        // Find which other resolvables are \"visible\" to the `resolvable` argument\n\t        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\t        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n\t        var availableResolvables = subPath\n\t            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n\t            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n\t        var getDependency = function (token) {\n\t            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n\t            if (matching.length)\n\t                return common_1.tail(matching);\n\t            var fromInjector = _this.injector().getNative(token);\n\t            if (!fromInjector) {\n\t                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n\t            }\n\t            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n\t        };\n\t        return resolvable.deps.map(getDependency);\n\t    };\n\t    return ResolveContext;\n\t}());\n\texports.ResolveContext = ResolveContext;\n\tvar UIInjectorImpl = (function () {\n\t    function UIInjectorImpl(context) {\n\t        this.context = context;\n\t        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n\t    }\n\t    UIInjectorImpl.prototype.get = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable) {\n\t            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n\t                return resolvable.get(this.context);\n\t            }\n\t            if (!resolvable.resolved) {\n\t                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n\t            }\n\t            return resolvable.data;\n\t        }\n\t        return this.native && this.native.get(token);\n\t    };\n\t    UIInjectorImpl.prototype.getAsync = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable)\n\t            return resolvable.get(this.context);\n\t        return coreservices_1.services.$q.when(this.native.get(token));\n\t    };\n\t    UIInjectorImpl.prototype.getNative = function (token) {\n\t        return this.native && this.native.get(token);\n\t    };\n\t    return UIInjectorImpl;\n\t}());\n\t//# sourceMappingURL=resolveContext.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/** @internalapi */\n\texports.resolvePolicies = {\n\t    when: {\n\t        LAZY: \"LAZY\",\n\t        EAGER: \"EAGER\"\n\t    },\n\t    async: {\n\t        WAIT: \"WAIT\",\n\t        NOWAIT: \"NOWAIT\",\n\t        RXWAIT: \"RXWAIT\"\n\t    }\n\t};\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar urlMatcherFactory_1 = __webpack_require__(28);\n\tvar urlRouter_1 = __webpack_require__(31);\n\tvar transitionService_1 = __webpack_require__(34);\n\tvar view_1 = __webpack_require__(42);\n\tvar stateRegistry_1 = __webpack_require__(43);\n\tvar stateService_1 = __webpack_require__(47);\n\tvar globals_1 = __webpack_require__(48);\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar urlService_1 = __webpack_require__(50);\n\tvar trace_1 = __webpack_require__(14);\n\t/** @hidden */\n\tvar _routerInstance = 0;\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n\t * This class instantiates and wires the UI-Router services together.\n\t *\n\t * After a new instance of the UIRouter class is created, it should be configured for your app.\n\t * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n\t *\n\t * ---\n\t *\n\t * Normally the framework code will bootstrap UI-Router.\n\t * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n\t * [[UrlService.listen]] then [[UrlService.sync]].\n\t */\n\tvar UIRouter = (function () {\n\t    /**\n\t     * Creates a new `UIRouter` object\n\t     *\n\t     * @param locationService a [[LocationServices]] implementation\n\t     * @param locationConfig a [[LocationConfig]] implementation\n\t     * @internalapi\n\t     */\n\t    function UIRouter(locationService, locationConfig) {\n\t        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n\t        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n\t        this.locationService = locationService;\n\t        this.locationConfig = locationConfig;\n\t        /** @hidden */\n\t        this.$id = _routerInstance++;\n\t        /** Provides trace information to the console */\n\t        this.trace = trace_1.trace;\n\t        /** Provides services related to ui-view synchronization */\n\t        this.viewService = new view_1.ViewService();\n\t        /** Provides services related to Transitions */\n\t        this.transitionService = new transitionService_1.TransitionService(this);\n\t        /** Global router state */\n\t        this.globals = new globals_1.Globals(this.transitionService);\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlRouter = new urlRouter_1.UrlRouter(this);\n\t        /** Provides a registry for states, and related registration services */\n\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n\t        /** Provides services related to states */\n\t        this.stateService = new stateService_1.StateService(this);\n\t        /** Provides services related to the URL */\n\t        this.urlService = new urlService_1.UrlService(this);\n\t        /** @hidden */\n\t        this._disposables = [];\n\t        /** @hidden */\n\t        this._plugins = {};\n\t        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t        this.disposable(this.transitionService);\n\t        this.disposable(this.urlRouter);\n\t        this.disposable(this.stateRegistry);\n\t        this.disposable(locationService);\n\t        this.disposable(locationConfig);\n\t    }\n\t    /** Registers an object to be notified when the router is disposed */\n\t    UIRouter.prototype.disposable = function (disposable) {\n\t        this._disposables.push(disposable);\n\t    };\n\t    /**\n\t     * Disposes this router instance\n\t     *\n\t     * When called, clears resources retained by the router by calling `dispose(this)` on all\n\t     * registered [[disposable]] objects.\n\t     *\n\t     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n\t     *\n\t     * @param disposable (optional) the disposable to dispose\n\t     */\n\t    UIRouter.prototype.dispose = function (disposable) {\n\t        var _this = this;\n\t        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n\t            disposable.dispose(this);\n\t            return undefined;\n\t        }\n\t        this._disposables.slice().forEach(function (d) {\n\t            try {\n\t                typeof d.dispose === 'function' && d.dispose(_this);\n\t                common_1.removeFrom(_this._disposables, d);\n\t            }\n\t            catch (ignored) { }\n\t        });\n\t    };\n\t    /**\n\t     * Adds a plugin to UI-Router\n\t     *\n\t     * This method adds a UI-Router Plugin.\n\t     * A plugin can enhance or change UI-Router behavior using any public API.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n\t     *\n\t     * var plugin = router.addPlugin(MyCoolPlugin);\n\t     * ```\n\t     *\n\t     * ### Plugin authoring\n\t     *\n\t     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n\t     *\n\t     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n\t     * For example, it may configure router options or add a Transition Hook.\n\t     *\n\t     * The plugin can then be published as a separate module.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * export class MyAuthPlugin implements UIRouterPlugin {\n\t     *   constructor(router: UIRouter, options: any) {\n\t     *     this.name = \"MyAuthPlugin\";\n\t     *     let $transitions = router.transitionService;\n\t     *     let $state = router.stateService;\n\t     *\n\t     *     let authCriteria = {\n\t     *       to: (state) => state.data && state.data.requiresAuth\n\t     *     };\n\t     *\n\t     *     function authHook(transition: Transition) {\n\t     *       let authService = transition.injector().get('AuthService');\n\t     *       if (!authService.isAuthenticated()) {\n\t     *         return $state.target('login');\n\t     *       }\n\t     *     }\n\t     *\n\t     *     $transitions.onStart(authCriteria, authHook);\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @param plugin one of:\n\t     *        - a plugin class which implements [[UIRouterPlugin]]\n\t     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n\t     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n\t     * @param options options to pass to the plugin class/factory\n\t     * @returns the registered plugin instance\n\t     */\n\t    UIRouter.prototype.plugin = function (plugin, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var pluginInstance = new plugin(this, options);\n\t        if (!pluginInstance.name)\n\t            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n\t        this._disposables.push(pluginInstance);\n\t        return this._plugins[pluginInstance.name] = pluginInstance;\n\t    };\n\t    UIRouter.prototype.getPlugin = function (pluginName) {\n\t        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n\t    };\n\t    return UIRouter;\n\t}());\n\texports.UIRouter = UIRouter;\n\t//# sourceMappingURL=router.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar urlMatcher_1 = __webpack_require__(29);\n\tvar param_1 = __webpack_require__(21);\n\tvar paramTypes_1 = __webpack_require__(30);\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n\t        /** @hidden */ this._isCaseInsensitive = false;\n\t        /** @hidden */ this._isStrictMode = true;\n\t        /** @hidden */ this._defaultSquashPolicy = false;\n\t        /** @hidden */\n\t        this._getConfig = function (config) {\n\t            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n\t        };\n\t        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\t        this.paramFactory = {\n\t            /** Creates a new [[Param]] from a CONFIG block */\n\t            fromConfig: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url PATH */\n\t            fromPath: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url SEARCH */\n\t            fromSearch: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n\t            },\n\t        };\n\t        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n\t    }\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!predicates_1.isObject(object))\n\t            return false;\n\t        var result = true;\n\t        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n\t            if (predicates_1.isFunction(val))\n\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    ;\n\t    /**\n\t     * Creates and registers a custom [[ParamType]] object\n\t     *\n\t     * A [[ParamType]] can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app runtime starts.\n\t     *        The result of this function should be a [[ParamTypeDefinition]].\n\t     *        The result is merged into the existing `definition`.\n\t     *        See [[ParamType]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n\t     *\n\t     * Note: Register custom types *before using them* in a state definition.\n\t     *\n\t     * See [[ParamTypeDefinition]] for examples\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = this.paramTypes.type(name, definition, definitionFn);\n\t        return !predicates_1.isDefined(definition) ? type : this;\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        this.paramTypes.enqueue = false;\n\t        this.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    ;\n\t    /** @internalapi */\n\t    UrlMatcherFactory.prototype.dispose = function () {\n\t        this.paramTypes.dispose();\n\t    };\n\t    return UrlMatcherFactory;\n\t}());\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\t//# sourceMappingURL=urlMatcherFactory.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar param_1 = __webpack_require__(21);\n\tvar strings_1 = __webpack_require__(11);\n\t/** @hidden */\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\t/** @hidden */\n\tvar memoizeTo = function (obj, prop, fn) {\n\t    return obj[prop] = obj[prop] || fn();\n\t};\n\t/**\n\t * Matches URLs against patterns.\n\t *\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL.\n\t *\n\t * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n\t * parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by [[UrlMatcher.exec]].\n\t *\n\t * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n\t * or colon placeholders (`/somePath/:param`).\n\t *\n\t * - *A parameter RegExp* may be defined for a param after a colon\n\t * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n\t * The regexp must match for the url to be matched.\n\t * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n\t *\n\t * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n\t *   See [[UrlMatcherFactory.type]] for more information.\n\t *\n\t * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n\t *   A catch-all * parameter value will contain the remainder of the URL.\n\t *\n\t * ---\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters).\n\t * A path parameter matches any number of characters other than '/'. For catch-all\n\t * placeholders the path parameter matches any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t */\n\tvar UrlMatcher = (function () {\n\t    /**\n\t     * @param pattern The pattern to compile into a matcher.\n\t     * @param paramTypes The [[ParamTypes]] registry\n\t     * @param config  A configuration object\n\t     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t     */\n\t    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n\t        var _this = this;\n\t        this.config = config;\n\t        /** @hidden */\n\t        this._cache = { path: [this], parent: null, pattern: null };\n\t        /** @hidden */\n\t        this._children = [];\n\t        /** @hidden */\n\t        this._params = [];\n\t        /** @hidden */\n\t        this._segments = [];\n\t        /** @hidden */\n\t        this._compiled = [];\n\t        this.pattern = pattern;\n\t        this.config = common_1.defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: common_1.identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3];\n\t            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n\t                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t            }); };\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern.substring(last, m.index),\n\t                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n\t    }\n\t    /**\n\t     * Creates a new concatenated UrlMatcher\n\t     *\n\t     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n\t     *\n\t     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        url._cache = {\n\t            path: this._cache.path.concat(url),\n\t            parent: this,\n\t            pattern: null,\n\t        };\n\t        return url;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path[0] === this;\n\t    };\n\t    /** Returns the input pattern string */\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * Tests the specified url/path against this matcher.\n\t     *\n\t     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n\t     * parameter values.  Returns null if the path does not match.\n\t     *\n\t     * The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * ```\n\t     *\n\t     * @param path    The URL path to match, e.g. `$location.path()`.\n\t     * @param search  URL search parameters, e.g. `$location.search()`.\n\t     * @param hash    URL hash e.g. `$location.hash()`.\n\t     * @param options\n\t     *\n\t     * @returns The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = common_1.map(split, reverseString);\n\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        }\n\t        searchParams.forEach(function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values[\"#\"] = hash;\n\t        return values;\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns a single parameter from this UrlMatcher by id\n\t     *\n\t     * @param id\n\t     * @param opts\n\t     * @returns {T|Param|any|boolean|UrlMatcher|null}\n\t     */\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var parent = this._cache.parent;\n\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n\t            null);\n\t    };\n\t    /**\n\t     * Validates the input parameter values against this UrlMatcher\n\t     *\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param params The object hash of parameters to validate.\n\t     * @returns Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var _this = this;\n\t        var validParamVal = function (param, val) {\n\t            return !param || param.validates(val);\n\t        };\n\t        return common_1.pairs(params || {}).map(function (_a) {\n\t            var key = _a[0], val = _a[1];\n\t            return validParamVal(_this.parameter(key), val);\n\t        }).reduce(common_1.allTrueR, true);\n\t    };\n\t    /**\n\t     * Given a set of parameter values, creates a URL from this UrlMatcher.\n\t     *\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * ```\n\t     *\n\t     * @param values  the values to substitute for the parameters in this pattern.\n\t     * @returns the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values) {\n\t        if (values === void 0) { values = {}; }\n\t        if (!this.validates(values))\n\t            return null;\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path;\n\t        // Extract all the static segments and Params into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n\t        /**\n\t         * Given a Param,\n\t         * Applies the parameter value, then returns details about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values[param.id]);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (predicates_1.isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (predicates_1.isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (predicates_1.isArray(encoded))\n\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (param) {\n\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!predicates_1.isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.raw)\n\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val) { return param.id + \"=\" + val; });\n\t        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t    };\n\t    /**\n\t     * Compare two UrlMatchers\n\t     *\n\t     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n\t     * Each static path segment is a static string between a path separator (slash character).\n\t     * Each dynamic segment is a path parameter.\n\t     *\n\t     * The comparison function sorts static segments before dynamic ones.\n\t     */\n\t    UrlMatcher.compare = function (a, b) {\n\t        var splitOnSlash = strings_1.splitOnDelim('/');\n\t        /**\n\t         * Turn a UrlMatcher and all its parent matchers into an array\n\t         * of slash literals '/', string literals, and Param objects\n\t         *\n\t         * This example matcher matches strings like \"/foo/:param/tail\":\n\t         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n\t         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n\t         *\n\t         */\n\t        var segments = function (matcher) {\n\t            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n\t                .reduce(common_1.unnestR, [])\n\t                .reduce(strings_1.joinNeighborsR, [])\n\t                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n\t                .reduce(common_1.unnestR, []);\n\t        };\n\t        var aSegments = segments(a), bSegments = segments(b);\n\t        // console.table( { aSegments, bSegments });\n\t        // Sort slashes first, then static strings, the Params\n\t        var weight = hof_1.pattern([\n\t            [hof_1.eq(\"/\"), hof_1.val(1)],\n\t            [predicates_1.isString, hof_1.val(2)],\n\t            [hof_1.is(param_1.Param), hof_1.val(3)]\n\t        ]);\n\t        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n\t        // console.table(pairs);\n\t        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n\t    };\n\t    return UrlMatcher;\n\t}());\n\t/** @hidden */\n\tUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\texports.UrlMatcher = UrlMatcher;\n\t//# sourceMappingURL=urlMatcher.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar paramType_1 = __webpack_require__(22);\n\t/**\n\t * A registry for parameter types.\n\t *\n\t * This registry manages the built-in (and custom) parameter types.\n\t *\n\t * The built-in parameter types are:\n\t *\n\t * - [[string]]\n\t * - [[path]]\n\t * - [[query]]\n\t * - [[hash]]\n\t * - [[int]]\n\t * - [[bool]]\n\t * - [[date]]\n\t * - [[json]]\n\t * - [[any]]\n\t */\n\tvar ParamTypes = (function () {\n\t    /** @internalapi */\n\t    function ParamTypes() {\n\t        /** @hidden */\n\t        this.enqueue = true;\n\t        /** @hidden */\n\t        this.typeQueue = [];\n\t        /** @internalapi */\n\t        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) {\n\t            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        };\n\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t    }\n\t    /** @internalapi */\n\t    ParamTypes.prototype.dispose = function () {\n\t        this.types = {};\n\t    };\n\t    /**\n\t     * Registers a parameter type\n\t     *\n\t     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n\t     */\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!predicates_1.isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    /** @internalapi */\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\texports.ParamTypes = ParamTypes;\n\t/** @hidden */\n\tfunction initDefaultTypes() {\n\t    var makeDefaultType = function (def) {\n\t        var valToString = function (val) {\n\t            return val != null ? val.toString() : val;\n\t        };\n\t        var defaultTypeBase = {\n\t            encode: valToString,\n\t            decode: valToString,\n\t            is: hof_1.is(String),\n\t            pattern: /.*/,\n\t            equals: function (a, b) { return a == b; },\n\t        };\n\t        return common_1.extend({}, defaultTypeBase, def);\n\t    };\n\t    // Default Parameter Type Definitions\n\t    common_1.extend(ParamTypes.prototype, {\n\t        string: makeDefaultType({}),\n\t        path: makeDefaultType({\n\t            pattern: /[^/]*/,\n\t        }),\n\t        query: makeDefaultType({}),\n\t        hash: makeDefaultType({\n\t            inherit: false,\n\t        }),\n\t        int: makeDefaultType({\n\t            decode: function (val) { return parseInt(val, 10); },\n\t            is: function (val) {\n\t                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n\t            },\n\t            pattern: /-?\\d+/,\n\t        }),\n\t        bool: makeDefaultType({\n\t            encode: function (val) { return val && 1 || 0; },\n\t            decode: function (val) { return parseInt(val, 10) !== 0; },\n\t            is: hof_1.is(Boolean),\n\t            pattern: /0|1/\n\t        }),\n\t        date: makeDefaultType({\n\t            encode: function (val) {\n\t                return !this.is(val) ? undefined : [\n\t                    val.getFullYear(),\n\t                    ('0' + (val.getMonth() + 1)).slice(-2),\n\t                    ('0' + val.getDate()).slice(-2)\n\t                ].join(\"-\");\n\t            },\n\t            decode: function (val) {\n\t                if (this.is(val))\n\t                    return val;\n\t                var match = this.capture.exec(val);\n\t                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t            },\n\t            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t            equals: function (l, r) {\n\t                return ['getFullYear', 'getMonth', 'getDate']\n\t                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t            },\n\t            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t        }),\n\t        json: makeDefaultType({\n\t            encode: common_1.toJson,\n\t            decode: common_1.fromJson,\n\t            is: hof_1.is(Object),\n\t            equals: common_1.equals,\n\t            pattern: /[^/]*/\n\t        }),\n\t        // does not encode/decode\n\t        any: makeDefaultType({\n\t            encode: common_1.identity,\n\t            decode: common_1.identity,\n\t            is: function () { return true; },\n\t            equals: common_1.equals,\n\t        }),\n\t    });\n\t}\n\tinitDefaultTypes();\n\t//# sourceMappingURL=paramTypes.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar urlMatcher_1 = __webpack_require__(29);\n\tvar hof_1 = __webpack_require__(7);\n\tvar urlRule_1 = __webpack_require__(32);\n\tvar targetState_1 = __webpack_require__(17);\n\t/** @hidden */\n\tfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t/** @hidden */\n\tvar getMatcher = hof_1.prop(\"urlMatcher\");\n\t/**\n\t * Default rule priority sorting function.\n\t *\n\t * Sorts rules by:\n\t *\n\t * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n\t * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n\t * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n\t * - Registration order (for rule types other than STATE and URLMATCHER)\n\t *\n\t * @coreapi\n\t */\n\tvar defaultRuleSortFn;\n\tdefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n\t/**\n\t * Updates URL and responds to URL changes\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class updates the URL when the state changes.\n\t * It also responds to changes in the URL.\n\t */\n\tvar UrlRouter = (function () {\n\t    /** @hidden */\n\t    function UrlRouter(router) {\n\t        /** @hidden */ this._sortFn = defaultRuleSortFn;\n\t        /** @hidden */ this._rules = [];\n\t        /** @hidden */ this.interceptDeferred = false;\n\t        /** @hidden */ this._id = 0;\n\t        this._router = router;\n\t        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n\t        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n\t    }\n\t    /** @internalapi */\n\t    UrlRouter.prototype.dispose = function () {\n\t        this.listen(false);\n\t        this._rules = [];\n\t        delete this._otherwiseFn;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sort = function (compareFn) {\n\t        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n\t    };\n\t    /**\n\t     * Given a URL, check all rules and return the best [[MatchResult]]\n\t     * @param url\n\t     * @returns {MatchResult}\n\t     */\n\t    UrlRouter.prototype.match = function (url) {\n\t        var _this = this;\n\t        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n\t        var rules = this.rules();\n\t        if (this._otherwiseFn)\n\t            rules.push(this._otherwiseFn);\n\t        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n\t        var checkRule = function (rule) {\n\t            var match = rule.match(url, _this._router);\n\t            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n\t        };\n\t        // The rules are pre-sorted.\n\t        // - Find the first matching rule.\n\t        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n\t        // - Choose the rule with the highest match weight.\n\t        var best;\n\t        for (var i = 0; i < rules.length; i++) {\n\t            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n\t            if (best && this._sortFn(rules[i], best.rule) !== 0)\n\t                break;\n\t            var current = checkRule(rules[i]);\n\t            // Pick the best MatchResult\n\t            best = (!best || current && current.weight > best.weight) ? current : best;\n\t        }\n\t        return best;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sync = function (evt) {\n\t        if (evt && evt.defaultPrevented)\n\t            return;\n\t        var router = this._router, $url = router.urlService, $state = router.stateService;\n\t        var url = {\n\t            path: $url.path(), search: $url.search(), hash: $url.hash()\n\t        };\n\t        var best = this.match(url);\n\t        var applyResult = hof_1.pattern([\n\t            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n\t            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n\t            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n\t        ]);\n\t        applyResult(best && best.rule.handler(best.match, url, router));\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.listen = function (enabled) {\n\t        var _this = this;\n\t        if (enabled === false) {\n\t            this._stopFn && this._stopFn();\n\t            delete this._stopFn;\n\t        }\n\t        else {\n\t            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n\t        }\n\t    };\n\t    /**\n\t     * Internal API.\n\t     * @internalapi\n\t     */\n\t    UrlRouter.prototype.update = function (read) {\n\t        var $url = this._router.locationService;\n\t        if (read) {\n\t            this.location = $url.path();\n\t            return;\n\t        }\n\t        if ($url.path() === this.location)\n\t            return;\n\t        $url.url(this.location, true);\n\t    };\n\t    /**\n\t     * Internal API.\n\t     *\n\t     * Pushes a new location to the browser history.\n\t     *\n\t     * @internalapi\n\t     * @param urlMatcher\n\t     * @param params\n\t     * @param options\n\t     */\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        var replace = options && !!options.replace;\n\t        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n\t    };\n\t    /**\n\t     * Builds and returns a URL with interpolated parameters\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * matcher = $umf.compile(\"/about/:person\");\n\t     * params = { person: \"bob\" };\n\t     * $bob = $urlRouter.href(matcher, params);\n\t     * // $bob == \"/about/bob\";\n\t     * ```\n\t     *\n\t     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n\t     * @param params An object of parameter values to fill the matcher's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params))\n\t            return null;\n\t        var url = urlMatcher.format(params);\n\t        options = options || { absolute: false };\n\t        var cfg = this._router.urlService.config;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    /**\n\t     * Manually adds a URL Rule.\n\t     *\n\t     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n\t     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n\t     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n\t     *\n\t     * A rule should have a `match` function which returns truthy if the rule matched.\n\t     * It should also have a `handler` function which is invoked if the rule is the best match.\n\t     *\n\t     * @return a function that deregisters the rule\n\t     */\n\t    UrlRouter.prototype.rule = function (rule) {\n\t        var _this = this;\n\t        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n\t            throw new Error(\"invalid rule\");\n\t        rule.$id = this._id++;\n\t        rule.priority = rule.priority || 0;\n\t        this._rules.push(rule);\n\t        this.sort();\n\t        return function () { return _this.removeRule(rule); };\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.removeRule = function (rule) {\n\t        common_1.removeFrom(this._rules, rule);\n\t        this.sort();\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.otherwise = function (handler) {\n\t        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n\t            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n\t        }\n\t        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n\t        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n\t        this.sort();\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.when = function (matcher, handler, options) {\n\t        var rule = this.urlRuleFactory.create(matcher, handler);\n\t        if (predicates_1.isDefined(options && options.priority))\n\t            rule.priority = options.priority;\n\t        this.rule(rule);\n\t        return rule;\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    ;\n\t    return UrlRouter;\n\t}());\n\texports.UrlRouter = UrlRouter;\n\t//# sourceMappingURL=urlRouter.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\tvar urlMatcher_1 = __webpack_require__(29);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar stateObject_1 = __webpack_require__(33);\n\t/**\n\t * Creates a [[UrlRule]]\n\t *\n\t * Creates a [[UrlRule]] from a:\n\t *\n\t * - `string`\n\t * - [[UrlMatcher]]\n\t * - `RegExp`\n\t * - [[State]]\n\t * @internalapi\n\t */\n\tvar UrlRuleFactory = (function () {\n\t    function UrlRuleFactory(router) {\n\t        this.router = router;\n\t    }\n\t    UrlRuleFactory.prototype.compile = function (str) {\n\t        return this.router.urlMatcherFactory.compile(str);\n\t    };\n\t    UrlRuleFactory.prototype.create = function (what, handler) {\n\t        var _this = this;\n\t        var makeRule = hof_1.pattern([\n\t            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n\t            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n\t            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n\t            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n\t            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n\t        ]);\n\t        var rule = makeRule(what);\n\t        if (!rule)\n\t            throw new Error(\"invalid 'what' in when()\");\n\t        return rule;\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a UrlMatcher\n\t     *\n\t     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     *\n\t     * ## Handler as UrlMatcher\n\t     *\n\t     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n\t     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n\t     * The url is replaced with the result.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n\t        var _handler = handler;\n\t        if (predicates_1.isString(handler))\n\t            handler = this.router.urlMatcherFactory.compile(handler);\n\t        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n\t            _handler = function (match) { return handler.format(match); };\n\t        function match(url) {\n\t            var match = urlMatcher.exec(url.path, url.search, url.hash);\n\t            return urlMatcher.validates(match) && match;\n\t        }\n\t        // Prioritize URLs, lowest to highest:\n\t        // - Some optional URL parameters, but none matched\n\t        // - No optional parameters in URL\n\t        // - Some optional parameters, some matched\n\t        // - Some optional parameters, all matched\n\t        function matchPriority(params) {\n\t            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n\t            if (!optional.length)\n\t                return 0.000001;\n\t            var matched = optional.filter(function (param) { return params[param.id]; });\n\t            return matched.length / optional.length;\n\t        }\n\t        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches a state by its url\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromState($state.get('foo'), router);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match);\n\t     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromState = function (state, router) {\n\t        /**\n\t         * Handles match by transitioning to matched state\n\t         *\n\t         * First checks if the router should start a new transition.\n\t         * A new transition is not required if the current state's URL\n\t         * and the new URL are already identical\n\t         */\n\t        var handler = function (match) {\n\t            var $state = router.stateService;\n\t            var globals = router.globals;\n\t            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n\t                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n\t            }\n\t        };\n\t        var details = { state: state, type: \"STATE\" };\n\t        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a regular expression\n\t     *\n\t     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - regexp match array (from `regexp`)\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     *\n\t     * ## Handler as string\n\t     *\n\t     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n\t     * The string is first interpolated using `string.replace()` style pattern.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n\t        if (regexp.global || regexp.sticky)\n\t            throw new Error(\"Rule RegExp must not be global or sticky\");\n\t        /**\n\t         * If handler is a string, the url will be replaced by the string.\n\t         * If the string has any String.replace() style variables in it (like `$2`),\n\t         * they will be replaced by the captures from [[match]]\n\t         */\n\t        var redirectUrlTo = function (match) {\n\t            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n\t            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t                return match[what === '$' ? 0 : Number(what)];\n\t            });\n\t        };\n\t        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n\t        var match = function (url) {\n\t            return regexp.exec(url.path);\n\t        };\n\t        var details = { regexp: regexp, type: \"REGEXP\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    return UrlRuleFactory;\n\t}());\n\tUrlRuleFactory.isUrlRule = function (obj) {\n\t    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n\t};\n\texports.UrlRuleFactory = UrlRuleFactory;\n\t/**\n\t * A base rule which calls `match`\n\t *\n\t * The value from the `match` function is passed through to the `handler`.\n\t * @internalapi\n\t */\n\tvar BaseUrlRule = (function () {\n\t    function BaseUrlRule(match, handler) {\n\t        var _this = this;\n\t        this.match = match;\n\t        this.type = \"RAW\";\n\t        this.matchPriority = function (match) { return 0 - _this.$id; };\n\t        this.handler = handler || common_1.identity;\n\t    }\n\t    return BaseUrlRule;\n\t}());\n\texports.BaseUrlRule = BaseUrlRule;\n\t//# sourceMappingURL=urlRule.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\t/**\n\t * Internal representation of a UI-Router state.\n\t *\n\t * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n\t *\n\t * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n\t *\n\t * This class prototypally inherits from the corresponding [[StateDeclaration]].\n\t * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n\t */\n\tvar State = (function () {\n\t    function State(config) {\n\t        common_1.extend(this, config);\n\t        // Object.freeze(this);\n\t    }\n\t    /**\n\t     * Returns true if the provided parameter is the same state.\n\t     *\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    State.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @deprecated this does not properly handle dot notation\n\t     * @returns Returns a dot-separated name of the state.\n\t     */\n\t    State.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns The root of this state's tree.\n\t     */\n\t    State.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    /**\n\t     * Gets the state's `Param`eters\n\t     *\n\t     * Gets [[Param]] information that is owned by the state.\n\t     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n\t     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n\t     *\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameters = function (opts) {\n\t        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(common_1.values(this.params))\n\t            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n\t    };\n\t    /**\n\t     * Returns a single [[Param]] that is owned by the state\n\t     *\n\t     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n\t     * @param id the name of the [[Param]] to return\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    State.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    return State;\n\t}());\n\texports.State = State;\n\t//# sourceMappingURL=stateObject.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar interface_1 = __webpack_require__(15);\n\tvar transition_1 = __webpack_require__(13);\n\tvar hookRegistry_1 = __webpack_require__(18);\n\tvar resolve_1 = __webpack_require__(35);\n\tvar views_1 = __webpack_require__(36);\n\tvar url_1 = __webpack_require__(37);\n\tvar redirectTo_1 = __webpack_require__(38);\n\tvar onEnterExitRetain_1 = __webpack_require__(39);\n\tvar lazyLoad_1 = __webpack_require__(40);\n\tvar transitionEventType_1 = __webpack_require__(41);\n\tvar transitionHook_1 = __webpack_require__(16);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\t/**\n\t * The default [[Transition]] options.\n\t *\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\texports.defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; },\n\t    source: \"unknown\"\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * - Most importantly, it allows global Transition Hooks to be registered.\n\t * - It allows the default transition error handler to be set.\n\t * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n\t *\n\t * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n\t */\n\tvar TransitionService = (function () {\n\t    /** @hidden */\n\t    function TransitionService(_router) {\n\t        /** @hidden */\n\t        this._transitionCount = 0;\n\t        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n\t        this._eventTypes = [];\n\t        /** @hidden The registered transition hooks */\n\t        this._registeredHooks = {};\n\t        /** @hidden The  paths on a criteria object */\n\t        this._criteriaPaths = {};\n\t        this._router = _router;\n\t        this.$view = _router.viewService;\n\t        this._deregisterHookFns = {};\n\t        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n\t            '_definePathType',\n\t            '_defineEvent',\n\t            '_getPathTypes',\n\t            '_getEvents',\n\t            'getHooks',\n\t        ]);\n\t        this._defineDefaultPaths();\n\t        this._defineDefaultEvents();\n\t        this._registerDefaultTransitionHooks();\n\t    }\n\t    /**\n\t     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n\t     *\n\t     * Registers a transition lifecycle hook, which is invoked during transition construction.\n\t     *\n\t     * This low level hook should only be used by plugins.\n\t     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n\t     * The Sticky States plugin uses this hook to modify the treechanges.\n\t     *\n\t     * ### Lifecycle\n\t     *\n\t     * `onCreate` hooks are invoked *while a transition is being constructed*.\n\t     *\n\t     * ### Return value\n\t     *\n\t     * The hook's return value is ignored\n\t     *\n\t     * @internalapi\n\t     * @param criteria defines which Transitions the Hook should be invoked for.\n\t     * @param callback the hook function which will be invoked.\n\t     * @param options the registration options\n\t     * @returns a function which deregisters the hook.\n\t     */\n\t    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n\t    /**\n\t     * dispose\n\t     * @internalapi\n\t     */\n\t    TransitionService.prototype.dispose = function (router) {\n\t        delete router.globals.transition;\n\t        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n\t            hook._deregistered = true;\n\t            common_1.removeFrom(hooksArray, hook);\n\t        }); });\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     * It is used internally by the [[StateService]] and should generally not be called by application code.\n\t     *\n\t     * @param fromPath the path to the current state (the from state)\n\t     * @param targetState the target state (destination)\n\t     * @returns a Transition\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new transition_1.Transition(fromPath, targetState, this._router);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultEvents = function () {\n\t        var Phase = interface_1.TransitionHookPhase;\n\t        var TH = transitionHook_1.TransitionHook;\n\t        var paths = this._criteriaPaths;\n\t        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n\t        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n\t        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n\t        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n\t        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n\t        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n\t        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n\t        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultPaths = function () {\n\t        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n\t        this._definePathType(\"to\", TRANSITION);\n\t        this._definePathType(\"from\", TRANSITION);\n\t        this._definePathType(\"exiting\", STATE);\n\t        this._definePathType(\"retained\", STATE);\n\t        this._definePathType(\"entering\", STATE);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n\t        this._eventTypes.push(eventType);\n\t        hookRegistry_1.makeEvent(this, this, eventType);\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    TransitionService.prototype._getEvents = function (phase) {\n\t        var transitionHookTypes = predicates_1.isDefined(phase) ?\n\t            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n\t            this._eventTypes.slice();\n\t        return transitionHookTypes.sort(function (l, r) {\n\t            var cmpByPhase = l.hookPhase - r.hookPhase;\n\t            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n\t        });\n\t    };\n\t    /**\n\t     * Adds a Path to be used as a criterion against a TreeChanges path\n\t     *\n\t     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n\t     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n\t     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * @hidden\n\t     */\n\t    TransitionService.prototype._definePathType = function (name, hookScope) {\n\t        this._criteriaPaths[name] = { name: name, scope: hookScope };\n\t    };\n\t    /** * @hidden */\n\t    TransitionService.prototype._getPathTypes = function () {\n\t        return this._criteriaPaths;\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n\t        var fns = this._deregisterHookFns;\n\t        // Wire up redirectTo hook\n\t        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n\t        // Wire up onExit/Retain/Enter state hooks\n\t        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n\t        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n\t        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n\t        // Wire up Resolve hooks\n\t        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n\t        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n\t        // Wire up the View management hooks\n\t        fns.loadViews = views_1.registerLoadEnteringViews(this);\n\t        fns.activateViews = views_1.registerActivateViews(this);\n\t        // After globals.current is updated at priority: 10000\n\t        fns.updateUrl = url_1.registerUpdateUrl(this);\n\t        // Lazy load state trees\n\t        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n\t    };\n\t    return TransitionService;\n\t}());\n\texports.TransitionService = TransitionService;\n\t//# sourceMappingURL=transitionService.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar resolveContext_1 = __webpack_require__(25);\n\tvar hof_1 = __webpack_require__(7);\n\t/**\n\t * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n\t *\n\t * Registered using `transitionService.onStart({}, eagerResolvePath);`\n\t *\n\t * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar eagerResolvePath = function (trans) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .resolvePath(\"EAGER\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerEagerResolvePath = function (transitionService) {\n\t    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n\t *\n\t * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n\t *\n\t * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar lazyResolveState = function (trans, state) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .subContext(state)\n\t        .resolvePath(\"LAZY\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerLazyResolveState = function (transitionService) {\n\t    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n\t};\n\t//# sourceMappingURL=resolve.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar coreservices_1 = __webpack_require__(8);\n\t/**\n\t * A [[TransitionHookFn]] which waits for the views to load\n\t *\n\t * Registered using `transitionService.onStart({}, loadEnteringViews);`\n\t *\n\t * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n\t * In angular 1, this includes loading the templates.\n\t */\n\tvar loadEnteringViews = function (transition) {\n\t    var $q = coreservices_1.services.$q;\n\t    var enteringViews = transition.views(\"entering\");\n\t    if (!enteringViews.length)\n\t        return;\n\t    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n\t};\n\texports.registerLoadEnteringViews = function (transitionService) {\n\t    return transitionService.onFinish({}, loadEnteringViews);\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n\t *\n\t * Registered using `transitionService.onSuccess({}, activateViews);`\n\t *\n\t * After a transition is complete, this hook deactivates the old views from the previous state,\n\t * and activates the new views from the destination state.\n\t *\n\t * See [[ViewService]]\n\t */\n\tvar activateViews = function (transition) {\n\t    var enteringViews = transition.views(\"entering\");\n\t    var exitingViews = transition.views(\"exiting\");\n\t    if (!enteringViews.length && !exitingViews.length)\n\t        return;\n\t    var $view = transition.router.viewService;\n\t    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n\t    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n\t    $view.sync();\n\t};\n\texports.registerActivateViews = function (transitionService) {\n\t    return transitionService.onSuccess({}, activateViews);\n\t};\n\t//# sourceMappingURL=views.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A [[TransitionHookFn]] which updates the URL after a successful transition\n\t *\n\t * Registered using `transitionService.onSuccess({}, updateUrl);`\n\t */\n\tvar updateUrl = function (transition) {\n\t    var options = transition.options();\n\t    var $state = transition.router.stateService;\n\t    var $urlRouter = transition.router.urlRouter;\n\t    // Dont update the url in these situations:\n\t    // The transition was triggered by a URL sync (options.source === 'url')\n\t    // The user doesn't want the url to update (options.location === false)\n\t    // The destination state, and all parents have no navigable url\n\t    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n\t        var urlOptions = { replace: options.location === 'replace' };\n\t        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n\t    }\n\t    $urlRouter.update(true);\n\t};\n\texports.registerUpdateUrl = function (transitionService) {\n\t    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n\t};\n\t//# sourceMappingURL=url.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** */\n\tvar predicates_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar targetState_1 = __webpack_require__(17);\n\t/**\n\t * A [[TransitionHookFn]] that redirects to a different state or params\n\t *\n\t * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n\t *\n\t * See [[StateDeclaration.redirectTo]]\n\t */\n\tvar redirectToHook = function (trans) {\n\t    var redirect = trans.to().redirectTo;\n\t    if (!redirect)\n\t        return;\n\t    var $state = trans.router.stateService;\n\t    function handleResult(result) {\n\t        if (!result)\n\t            return;\n\t        if (result instanceof targetState_1.TargetState)\n\t            return result;\n\t        if (predicates_1.isString(result))\n\t            return $state.target(result, trans.params(), trans.options());\n\t        if (result['state'] || result['params'])\n\t            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n\t    }\n\t    if (predicates_1.isFunction(redirect)) {\n\t        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n\t    }\n\t    return handleResult(redirect);\n\t};\n\texports.registerRedirectToHook = function (transitionService) {\n\t    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n\t};\n\t//# sourceMappingURL=redirectTo.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A factory which creates an onEnter, onExit or onRetain transition hook function\n\t *\n\t * The returned function invokes the (for instance) state.onEnter hook when the\n\t * state is being entered.\n\t *\n\t * @hidden\n\t */\n\tfunction makeEnterExitRetainHook(hookName) {\n\t    return function (transition, state) {\n\t        var hookFn = state[hookName];\n\t        return hookFn(transition, state);\n\t    };\n\t}\n\t/**\n\t * The [[TransitionStateHookFn]] for onExit\n\t *\n\t * When the state is being exited, the state's .onExit function is invoked.\n\t *\n\t * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n\t *\n\t * See: [[IHookRegistry.onExit]]\n\t */\n\tvar onExitHook = makeEnterExitRetainHook('onExit');\n\texports.registerOnExitHook = function (transitionService) {\n\t    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onRetain\n\t *\n\t * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n\t *\n\t * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n\t *\n\t * See: [[IHookRegistry.onRetain]]\n\t */\n\tvar onRetainHook = makeEnterExitRetainHook('onRetain');\n\texports.registerOnRetainHook = function (transitionService) {\n\t    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onEnter\n\t *\n\t * When the state is being entered, the state's .onEnter function is invoked.\n\t *\n\t * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n\t *\n\t * See: [[IHookRegistry.onEnter]]\n\t */\n\tvar onEnterHook = makeEnterExitRetainHook('onEnter');\n\texports.registerOnEnterHook = function (transitionService) {\n\t    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n\t};\n\t//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(8);\n\t/**\n\t * A [[TransitionHookFn]] that performs lazy loading\n\t *\n\t * When entering a state \"abc\" which has a `lazyLoad` function defined:\n\t * - Invoke the `lazyLoad` function (unless it is already in process)\n\t *   - Flag the hook function as \"in process\"\n\t *   - The function should return a promise (that resolves when lazy loading is complete)\n\t * - Wait for the promise to settle\n\t *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n\t *   - Flag the hook function as \"not in process\"\n\t * - If the hook was successful\n\t *   - Remove the `lazyLoad` function from the state declaration\n\t * - If all the hooks were successful\n\t *   - Retry the transition (by returning a TargetState)\n\t *\n\t * ```\n\t * .state('abc', {\n\t *   component: 'fooComponent',\n\t *   lazyLoad: () => System.import('./fooComponent')\n\t *   });\n\t * ```\n\t *\n\t * See [[StateDeclaration.lazyLoad]]\n\t */\n\tvar lazyLoadHook = function (transition) {\n\t    var router = transition.router;\n\t    function retryTransition() {\n\t        if (transition.originalTransition().options().source !== 'url') {\n\t            // The original transition was not triggered via url sync\n\t            // The lazy state should be loaded now, so re-try the original transition\n\t            var orig = transition.targetState();\n\t            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n\t        }\n\t        // The original transition was triggered via url sync\n\t        // Run the URL rules and find the best match\n\t        var $url = router.urlService;\n\t        var result = $url.match($url.parts());\n\t        var rule = result && result.rule;\n\t        // If the best match is a state, redirect the transition (instead\n\t        // of calling sync() which supersedes the current transition)\n\t        if (rule && rule.type === \"STATE\") {\n\t            var state = rule.state;\n\t            var params = result.match;\n\t            return router.stateService.target(state, params, transition.options());\n\t        }\n\t        // No matching state found, so let .sync() choose the best non-state match/otherwise\n\t        router.urlService.sync();\n\t    }\n\t    var promises = transition.entering()\n\t        .filter(function (state) { return !!state.$$state().lazyLoad; })\n\t        .map(function (state) { return lazyLoadState(transition, state); });\n\t    return coreservices_1.services.$q.all(promises).then(retryTransition);\n\t};\n\texports.registerLazyLoadHook = function (transitionService) {\n\t    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n\t};\n\t/**\n\t * Invokes a state's lazy load function\n\t *\n\t * @param transition a Transition context\n\t * @param state the state to lazy load\n\t * @returns A promise for the lazy load result\n\t */\n\tfunction lazyLoadState(transition, state) {\n\t    var lazyLoadFn = state.$$state().lazyLoad;\n\t    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\t    var promise = lazyLoadFn['_promise'];\n\t    if (!promise) {\n\t        var success = function (result) {\n\t            delete state.lazyLoad;\n\t            delete state.$$state().lazyLoad;\n\t            delete lazyLoadFn['_promise'];\n\t            return result;\n\t        };\n\t        var error = function (err) {\n\t            delete lazyLoadFn['_promise'];\n\t            return coreservices_1.services.$q.reject(err);\n\t        };\n\t        promise = lazyLoadFn['_promise'] =\n\t            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n\t                .then(updateStateRegistry)\n\t                .then(success, error);\n\t    }\n\t    /** Register any lazy loaded state definitions */\n\t    function updateStateRegistry(result) {\n\t        if (result && Array.isArray(result.states)) {\n\t            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n\t        }\n\t        return result;\n\t    }\n\t    return promise;\n\t}\n\texports.lazyLoadState = lazyLoadState;\n\t//# sourceMappingURL=lazyLoad.js.map\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar transitionHook_1 = __webpack_require__(16);\n\t/**\n\t * This class defines a type of hook, such as `onBefore` or `onEnter`.\n\t * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n\t *\n\t * @interalapi\n\t */\n\tvar TransitionEventType = (function () {\n\t    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        this.name = name;\n\t        this.hookPhase = hookPhase;\n\t        this.hookOrder = hookOrder;\n\t        this.criteriaMatchPath = criteriaMatchPath;\n\t        this.reverseSort = reverseSort;\n\t        this.getResultHandler = getResultHandler;\n\t        this.getErrorHandler = getErrorHandler;\n\t        this.rejectIfSuperseded = rejectIfSuperseded;\n\t    }\n\t    return TransitionEventType;\n\t}());\n\texports.TransitionEventType = TransitionEventType;\n\t//# sourceMappingURL=transitionEventType.js.map\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module view\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar trace_1 = __webpack_require__(14);\n\t/**\n\t * The View service\n\t *\n\t * This service pairs existing `ui-view` components (which live in the DOM)\n\t * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n\t *\n\t * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n\t *   The views from exited states are deactivated via [[deactivateViewConfig]].\n\t *   (See: the [[registerActivateViews]] Transition Hook)\n\t *\n\t * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n\t *\n\t * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n\t * are configured with the matching [[ViewConfig]](s)\n\t *\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this._uiViews = [];\n\t        this._viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this._pluginapi = {\n\t            _rootViewContext: this._rootViewContext.bind(this),\n\t            _viewConfigFactory: this._viewConfigFactory.bind(this),\n\t            _registeredUIViews: function () { return _this._uiViews; },\n\t            _activeViewConfigs: function () { return _this._viewConfigs; },\n\t        };\n\t    }\n\t    ViewService.prototype._rootViewContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    ;\n\t    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (path, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(path, decl);\n\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * Deactivates a ViewConfig.\n\t     *\n\t     * This function deactivates a `ViewConfig`.\n\t     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        common_1.removeFrom(this._viewConfigs, viewConfig);\n\t    };\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this._viewConfigs.push(viewConfig);\n\t    };\n\t    ViewService.prototype.sync = function () {\n\t        var _this = this;\n\t        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t        // Return the number of dots in the fully qualified name\n\t        function uiViewDepth(uiView) {\n\t            return uiView.fqn.split(\".\").length;\n\t        }\n\t        // Return the ViewConfig's context's depth in the context tree.\n\t        function viewConfigDepth(config) {\n\t            var context = config.viewDecl.$context, count = 0;\n\t            while (++count && context.parent)\n\t                context = context.parent;\n\t            return count;\n\t        }\n\t        // Given a depth function, returns a compare function which can return either ascending or descending order\n\t        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t        var matchingConfigPair = function (uiView) {\n\t            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n\t            if (matchingConfigs.length > 1) {\n\t                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n\t                // Sort by depth and return the match from the deepest child\n\t                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n\t                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t            }\n\t            return [uiView, matchingConfigs[0]];\n\t        };\n\t        var configureUIView = function (_a) {\n\t            var uiView = _a[0], viewConfig = _a[1];\n\t            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t            if (_this._uiViews.indexOf(uiView) !== -1)\n\t                uiView.configUpdated(viewConfig);\n\t        };\n\t        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n\t    };\n\t    ;\n\t    /**\n\t     * Registers a `ui-view` component\n\t     *\n\t     * When a `ui-view` component is created, it uses this method to register itself.\n\t     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n\t     *\n\t     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n\t     * and what the view's state context is.\n\t     *\n\t     * Note: There is no corresponding `deregisterUIView`.\n\t     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n\t     *\n\t     * @param uiView The metadata for a UIView\n\t     * @return a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUIView = function (uiView) {\n\t        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this._uiViews;\n\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t        if (uiViews.filter(fqnMatches).length)\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx === -1) {\n\t                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n\t            common_1.removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    ;\n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this._uiViews.map(hof_1.prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * This should be used by a framework implementation to calculate the values for\n\t     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        else if (uiViewContextAnchor === '.') {\n\t            uiViewContextAnchor = context.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    return ViewService;\n\t}());\n\t/**\n\t * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t *\n\t * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t *\n\t * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t *\n\t * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t *\n\t * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t * - the ui-view's name matches the ViewConfig's target name\n\t * - the ui-view's context matches the ViewConfig's anchor\n\t *\n\t * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t * - There exists a parent ui-view where:\n\t *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t *    - the parent ui-view's context matches the ViewConfig's anchor\n\t * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t *\n\t * Example:\n\t *\n\t * DOM:\n\t * <ui-view>                        <!-- created in the root context (name: \"\") -->\n\t *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t *       </ui-view>\n\t *     </ui-view>\n\t *   </ui-view>\n\t * </ui-view>\n\t *\n\t * uiViews: [\n\t *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t * ]\n\t *\n\t * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t *\n\t * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t *\n\t * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t *   the tail of the ui-view's fqn \"default.bar\"\n\t *\n\t * @internalapi\n\t */\n\tViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n\t    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t    if (uiView.$type !== viewConfig.viewDecl.$type)\n\t        return false;\n\t    // Split names apart from both viewConfig and uiView into segments\n\t    var vc = viewConfig.viewDecl;\n\t    var vcSegments = vc.$uiViewName.split(\".\");\n\t    var uivSegments = uiView.fqn.split(\".\");\n\t    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t        return false;\n\t    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t    var negOffset = (1 - vcSegments.length) || undefined;\n\t    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t}; };\n\texports.ViewService = ViewService;\n\t//# sourceMappingURL=view.js.map\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar stateMatcher_1 = __webpack_require__(44);\n\tvar stateBuilder_1 = __webpack_require__(45);\n\tvar stateQueueManager_1 = __webpack_require__(46);\n\tvar common_1 = __webpack_require__(5);\n\tvar hof_1 = __webpack_require__(7);\n\tvar StateRegistry = (function () {\n\t    /** @internalapi */\n\t    function StateRegistry(_router) {\n\t        this._router = _router;\n\t        this.states = {};\n\t        this.listeners = [];\n\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n\t        this._registerRoot();\n\t    }\n\t    /** @internalapi */\n\t    StateRegistry.prototype._registerRoot = function () {\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    };\n\t    /** @internalapi */\n\t    StateRegistry.prototype.dispose = function () {\n\t        var _this = this;\n\t        this.stateQueue.dispose();\n\t        this.listeners = [];\n\t        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n\t    };\n\t    /**\n\t     * Listen for a State Registry events\n\t     *\n\t     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let allStates = registry.get();\n\t     *\n\t     * // Later, invoke deregisterFn() to remove the listener\n\t     * let deregisterFn = registry.onStatesChanged((event, states) => {\n\t     *   switch(event) {\n\t     *     case: 'registered':\n\t     *       states.forEach(state => allStates.push(state));\n\t     *       break;\n\t     *     case: 'deregistered':\n\t     *       states.forEach(state => {\n\t     *         let idx = allStates.indexOf(state);\n\t     *         if (idx !== -1) allStates.splice(idx, 1);\n\t     *       });\n\t     *       break;\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param listener a callback function invoked when the registered states changes.\n\t     *        The function receives two parameters, `event` and `state`.\n\t     *        See [[StateRegistryListener]]\n\t     * @return a function that deregisters the listener\n\t     */\n\t    StateRegistry.prototype.onStatesChanged = function (listener) {\n\t        this.listeners.push(listener);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.listeners)(listener);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Gets the implicit root state\n\t     *\n\t     * Gets the root of the state tree.\n\t     * The root state is implicitly created by UI-Router.\n\t     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n\t     *\n\t     * @return the root [[State]]\n\t     */\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    /**\n\t     * Adds a state to the registry\n\t     *\n\t     * Registers a [[StateDeclaration]] or queues it for registration.\n\t     *\n\t     * Note: a state will be queued if the state's parent isn't yet registered.\n\t     *\n\t     * @param stateDefinition the definition of the state to register.\n\t     * @returns the internal [[State]] object.\n\t     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n\t     *          If the state was only queued, then the object is not fully built.\n\t     */\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    /** @hidden */\n\t    StateRegistry.prototype._deregisterTree = function (state) {\n\t        var _this = this;\n\t        var all = this.get().map(function (s) { return s.$$state(); });\n\t        var getChildren = function (states) {\n\t            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n\t            return children.length === 0 ? children : children.concat(getChildren(children));\n\t        };\n\t        var children = getChildren([state]);\n\t        var deregistered = [state].concat(children).reverse();\n\t        deregistered.forEach(function (state) {\n\t            var $ur = _this._router.urlRouter;\n\t            // Remove URL rule\n\t            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n\t            // Remove state from registry\n\t            delete _this.states[state.name];\n\t        });\n\t        return deregistered;\n\t    };\n\t    /**\n\t     * Removes a state from the registry\n\t     *\n\t     * This removes a state from the registry.\n\t     * If the state has children, they are are also removed from the registry.\n\t     *\n\t     * @param stateOrName the state's name or object representation\n\t     * @returns {State[]} a list of removed states\n\t     */\n\t    StateRegistry.prototype.deregister = function (stateOrName) {\n\t        var _state = this.get(stateOrName);\n\t        if (!_state)\n\t            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\t        var deregisteredStates = this._deregisterTree(_state.$$state());\n\t        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n\t        return deregisteredStates;\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\texports.StateRegistry = StateRegistry;\n\t//# sourceMappingURL=stateRegistry.js.map\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(6);\n\tvar glob_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(5);\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = predicates_1.isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        else if (isStr) {\n\t            var matches = common_1.values(this._states)\n\t                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n\t            if (matches.length > 1) {\n\t                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n\t            }\n\t            return matches[0];\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\texports.StateMatcher = StateMatcher;\n\t//# sourceMappingURL=stateMatcher.js.map\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(11);\n\tvar hof_1 = __webpack_require__(7);\n\tvar resolvable_1 = __webpack_require__(24);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar parseUrl = function (url) {\n\t    if (!predicates_1.isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\tfunction nameBuilder(state) {\n\t    return state.name;\n\t}\n\tfunction selfBuilder(state) {\n\t    state.self.$$state = function () { return state; };\n\t    return state.self;\n\t}\n\tfunction dataBuilder(state) {\n\t    if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t    }\n\t    return state.data;\n\t}\n\tvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n\t    return function urlBuilder(state) {\n\t        var stateDec = state;\n\t        // For future states, i.e., states whose name ends with `.**`,\n\t        // match anything that starts with the url prefix\n\t        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n\t            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n\t        }\n\t        var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t            params: state.params || {},\n\t            paramMap: function (paramConfig, isSearch) {\n\t                if (stateDec.reloadOnSearch === false && isSearch)\n\t                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t                return paramConfig;\n\t            }\n\t        });\n\t        if (!url)\n\t            return null;\n\t        if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t    };\n\t};\n\tvar getNavigableBuilder = function (isRoot) {\n\t    return function navigableBuilder(state) {\n\t        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    };\n\t};\n\tvar getParamsBuilder = function (paramFactory) {\n\t    return function paramsBuilder(state) {\n\t        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n\t        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t};\n\tfunction pathBuilder(state) {\n\t    return state.parent ? state.parent.path.concat(state) : [state];\n\t}\n\tfunction includesBuilder(state) {\n\t    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t    includes[state.name] = true;\n\t    return includes;\n\t}\n\t/**\n\t * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * validates the `resolve` property and converts it to a [[Resolvable]] array.\n\t *\n\t * resolve: input value can be:\n\t *\n\t * {\n\t *   // analyzed but not injected\n\t *   myFooResolve: function() { return \"myFooData\"; },\n\t *\n\t *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n\t *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; \"DependencyName\" dep as string\n\t *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; DependencyType dep as token (compared using ===)\n\t *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n\t *\n\t *   // val.$inject used as deps\n\t *   // where:\n\t *   //     corgeResolve.$inject = [\"DependencyName\"];\n\t *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n\t *   // then \"DependencyName\" dep as string\n\t *   myCorgeResolve: corgeResolve,\n\t *\n\t *  // inject service by name\n\t *  // When a string is found, desugar creating a resolve that injects the named service\n\t *   myGraultResolve: \"SomeService\"\n\t * }\n\t *\n\t * or:\n\t *\n\t * [\n\t *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n\t *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n\t *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n\t * ]\n\t */\n\tfunction resolvablesBuilder(state) {\n\t    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n\t    var objects2Tuples = function (resolveObj, resolvePolicies) {\n\t        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n\t    };\n\t    /** fetch DI annotations from a function or ng1-style array */\n\t    var annotate = function (fn) {\n\t        var $injector = coreservices_1.services.$injector;\n\t        // ng1 doesn't have an $injector until runtime.\n\t        // If the $injector doesn't exist, use \"deferred\" literal as a\n\t        // marker indicating they should be annotated when runtime starts\n\t        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n\t    };\n\t    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\t    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n\t    /** true if the object looks like a provide literal, or a ng2 Provider */\n\t    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n\t    /** true if the object looks like a tuple from obj2Tuples */\n\t    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n\t    /** extracts the token from a Provider or provide literal */\n\t    var token = function (p) { return p.provide || p.token; };\n\t    /** Given a literal resolve or provider object, returns a Resolvable */\n\t    var literal2Resolvable = hof_1.pattern([\n\t        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n\t        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n\t        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n\t        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n\t        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n\t    ]);\n\t    var tuple2Resolvable = hof_1.pattern([\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n\t    ]);\n\t    var item2Resolvable = hof_1.pattern([\n\t        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n\t        [isResolveLiteral, literal2Resolvable],\n\t        [isLikeNg2Provider, literal2Resolvable],\n\t        [isTupleFromObj, tuple2Resolvable],\n\t        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n\t    ]);\n\t    // If resolveBlock is already an array, use it as-is.\n\t    // Otherwise, assume it's an object and convert to an Array of tuples\n\t    var decl = state.resolve;\n\t    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n\t    return items.map(item2Resolvable);\n\t}\n\texports.resolvablesBuilder = resolvablesBuilder;\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[State]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[State]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, urlMatcherFactory) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var root = function () { return matcher.find(\"\"); };\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        function parentBuilder(state) {\n\t            if (isRoot(state))\n\t                return null;\n\t            return matcher.find(self.parentName(state)) || root();\n\t        }\n\t        this.builders = {\n\t            name: [nameBuilder],\n\t            self: [selfBuilder],\n\t            parent: [parentBuilder],\n\t            data: [dataBuilder],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [getUrlBuilder(urlMatcherFactory, root)],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [getNavigableBuilder(isRoot)],\n\t            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/statebuilders/views.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [pathBuilder],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [includesBuilder],\n\t            resolvables: [resolvablesBuilder]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent))\n\t            return null;\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        var name = state.name || \"\";\n\t        var segments = name.split('.');\n\t        if (segments.length > 1) {\n\t            if (state.parent) {\n\t                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n\t            }\n\t            var lastSegment = segments.pop();\n\t            if (lastSegment === '**')\n\t                segments.pop();\n\t            return segments.join(\".\");\n\t        }\n\t        if (!state.parent)\n\t            return \"\";\n\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\texports.StateBuilder = StateBuilder;\n\t//# sourceMappingURL=stateBuilder.js.map\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar stateObject_1 = __webpack_require__(33);\n\t/** @internalapi */\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n\t        this.$registry = $registry;\n\t        this.$urlRouter = $urlRouter;\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.listeners = listeners;\n\t        this.queue = [];\n\t    }\n\t    /** @internalapi */\n\t    StateQueueManager.prototype.dispose = function () {\n\t        this.queue = [];\n\t    };\n\t    StateQueueManager.prototype.register = function (config) {\n\t        var _a = this, states = _a.states, queue = _a.queue;\n\t        // Wrap a new object around the state so we can store our private details easily.\n\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n\t            self: config,\n\t            resolve: config.resolve || [],\n\t            toString: function () { return config.name; }\n\t        }));\n\t        if (!predicates_1.isString(state.name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t        queue.push(state);\n\t        this.flush();\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function () {\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var registered = [], // states that got registered\n\t        orphans = [], // states that don't yet have a parent registered\n\t        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\t        while (queue.length > 0) {\n\t            var state = queue.shift();\n\t            var result = builder.build(state);\n\t            var orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                var existingState = this.$registry.get(state.name);\n\t                if (existingState && existingState.name === state.name) {\n\t                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t                }\n\t                if (existingState && existingState.name === state.name + \".**\") {\n\t                    // Remove future state of the same name\n\t                    this.$registry.deregister(existingState);\n\t                }\n\t                states[state.name] = state;\n\t                this.attachRoute(state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                registered.push(state);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[state.name];\n\t            previousQueueLength[state.name] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t                queue.push(state);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        if (registered.length) {\n\t            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function (state) {\n\t        if (state.abstract || !state.url)\n\t            return;\n\t        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n\t    };\n\t    return StateQueueManager;\n\t}());\n\texports.StateQueueManager = StateQueueManager;\n\t//# sourceMappingURL=stateQueueManager.js.map\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** */\n\tvar common_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar queue_1 = __webpack_require__(10);\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar pathFactory_1 = __webpack_require__(23);\n\tvar node_1 = __webpack_require__(20);\n\tvar transitionService_1 = __webpack_require__(34);\n\tvar rejectFactory_1 = __webpack_require__(12);\n\tvar targetState_1 = __webpack_require__(17);\n\tvar param_1 = __webpack_require__(21);\n\tvar glob_1 = __webpack_require__(9);\n\tvar resolveContext_1 = __webpack_require__(25);\n\tvar lazyLoad_1 = __webpack_require__(40);\n\tvar hof_1 = __webpack_require__(7);\n\t/**\n\t * Provides state related service functions\n\t *\n\t * This class provides services related to ui-router states.\n\t * An instance of this class is located on the global [[UIRouter]] object.\n\t */\n\tvar StateService = (function () {\n\t    /** @internalapi */\n\t    function StateService(router) {\n\t        this.router = router;\n\t        /** @internalapi */\n\t        this.invalidCallbacks = [];\n\t        /** @hidden */\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error && $error$.stack) {\n\t                console.error($error$);\n\t                console.error($error$.stack);\n\t            }\n\t            else if ($error$ instanceof rejectFactory_1.Rejection) {\n\t                console.error($error$.toString());\n\t                if ($error$.detail && $error$.detail.stack)\n\t                    console.error($error$.detail.stack);\n\t            }\n\t            else {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n\t        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        /**\n\t         * The [[Transition]] currently in progress (or null)\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.transition]]\n\t         */\n\t        get: function () { return this.router.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        /**\n\t         * The latest successful state parameters\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.params]]\n\t         */\n\t        get: function () { return this.router.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        /**\n\t         * The current [[StateDeclaration]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.current]]\n\t         */\n\t        get: function () { return this.router.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        /**\n\t         * The current [[State]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.$current]]\n\t         */\n\t        get: function () { return this.router.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /** @internalapi */\n\t    StateService.prototype.dispose = function () {\n\t        this.defaultErrorHandler(common_1.noop);\n\t        this.invalidCallbacks = [];\n\t    };\n\t    /**\n\t     * Handler for when [[transitionTo]] is called with an invalid state.\n\t     *\n\t     * Invokes the [[onInvalid]] callbacks, in natural order.\n\t     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n\t     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n\t     *\n\t     * @internalapi\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n\t        var _this = this;\n\t        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t        var globals = this.router.globals;\n\t        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n\t        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof targetState_1.TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid())\n\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t            if (latestThing() !== latest)\n\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n\t            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n\t            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * Registers an Invalid State handler\n\t     *\n\t     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n\t     * has been called with an invalid state reference parameter\n\t     *\n\t     * Example:\n\t     * ```js\n\t     * stateService.onInvalid(function(to, from, injector) {\n\t     *   if (to.name() === 'foo') {\n\t     *     let lazyLoader = injector.get('LazyLoadService');\n\t     *     return lazyLoader.load('foo')\n\t     *         .then(() => stateService.target('foo'));\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param {function} callback invoked when the toState is invalid\n\t     *   This function receives the (invalid) toState, the fromState, and an injector.\n\t     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n\t     *   If one is returned, it is treated as a redirect.\n\t     *\n\t     * @returns a function which deregisters the callback\n\t     */\n\t    StateService.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.invalidCallbacks)(callback);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Reloads the current state\n\t     *\n\t     * A method that force reloads the current state, or a partial state hierarchy.\n\t     * All resolves are re-resolved, and components reinstantiated.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * Note: `reload()` is just an alias for:\n\t     *\n\t     * ```js\n\t     * $state.transitionTo($state.current, $state.params, {\n\t     *   reload: true, inherit: false\n\t     * });\n\t     * ```\n\t     *\n\t     * @param reloadState A state name or a state object.\n\t     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Transition to a different state or parameters\n\t     *\n\t     * Convenience method for transitioning to a new state.\n\t     *\n\t     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t     * This allows you to easily use an absolute or relative to path and specify\n\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param to Absolute state name, state object, or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n\t     *\n\t     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n\t     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n\t     *\n\t     *    Parameter inheritance only works between common ancestor states, I.e.\n\t     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     *    will get you all current parameters, etc.\n\t     *\n\t     * @param options Transition options\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * - Possible success values:\n\t     *    - $state.current\n\t     *\n\t     * - Possible rejection reasons:\n\t     *   - transition superseded - when a newer transition has been started after this one\n\t     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n\t     *   - transition failed - when a transition hook errors\n\t     *   - resolve error - when a resolve has errored or rejected\n\t     *\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a [[TargetState]]\n\t     *\n\t     * This is a factory method for creating a TargetState\n\t     *\n\t     * This may be returned from a Transition Hook to redirect a transition, for example.\n\t     */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        var reg = this.router.stateRegistry;\n\t        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = reg.matcher.find(identifier, options.relative);\n\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    ;\n\t    StateService.prototype.getCurrentPath = function () {\n\t        var _this = this;\n\t        var globals = this.router.globals;\n\t        var latestSuccess = globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n\t        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t    };\n\t    /**\n\t     * Low-level method for transitioning to a new state.\n\t     *\n\t     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to State name or state object.\n\t     * @param toParams A map of the parameters that will be sent to the state,\n\t     *      will populate $stateParams.\n\t     * @param options Transition options\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[go]]\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var router = this.router;\n\t        var globals = router.globals;\n\t        var transHistory = globals.transitionHistory;\n\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t        var ref = this.target(to, toParams, options);\n\t        var currentPath = this.getCurrentPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return common_1.silentRejection(ref.error());\n\t        /**\n\t         * Special handling for Ignored, Aborted, and Redirected transitions\n\t         *\n\t         * The semantics for the transition.run() promise and the StateService.transitionTo()\n\t         * promise differ. For instance, the run() promise may be rejected because it was\n\t         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n\t         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n\t         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n\t         */\n\t        var rejectedTransitionHandler = function (transition) { return function (error) {\n\t            if (error instanceof rejectFactory_1.Rejection) {\n\t                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n\t                    router.urlRouter.update();\n\t                    return coreservices_1.services.$q.when(globals.current);\n\t                }\n\t                var detail = error.detail;\n\t                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n\t                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n\t                    // by returning the promise for the new (redirect) `Transition.run()`.\n\t                    var redirect = transition.redirect(detail);\n\t                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n\t                }\n\t                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t                    router.urlRouter.update();\n\t                }\n\t            }\n\t            var errorHandler = _this.defaultErrorHandler();\n\t            errorHandler(error);\n\t            return coreservices_1.services.$q.reject(error);\n\t        }; };\n\t        var transition = this.router.transitionService.create(currentPath, ref);\n\t        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n\t        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return common_1.extend(transitionToPromise, { transition: transition });\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *is* the provided state\n\t     *\n\t     * Similar to [[includes]] but only checks for the full state name.\n\t     * If params is supplied then it will be tested for strict equality against the current\n\t     * active params object, so all params must match with none missing and no extras.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     * ```\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * ```html\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *includes* the provided state\n\t     *\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * #### Example when `$state.$current.name === 'contacts.details.item'`\n\t     * ```js\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     * ```\n\t     *\n\t     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n\t     * ```js\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * ```\n\t     *\n\t     * @param stateOrName A partial name, relative name, glob pattern,\n\t     *   or state object to be searched for within the current state name.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`,\n\t     *   that you'd like to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (!predicates_1.isDefined(include[state.name]))\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Generates a URL for a state and parameters\n\t     *\n\t     * Returns the url for the given state populated with the given params.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param params An object of parameter values to fill the state's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current\n\t        };\n\t        options = common_1.defaults(options, defaultHrefOpts);\n\t        params = params || {};\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t            absolute: options.absolute\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Sets or gets the default [[transitionTo]] error handler.\n\t     *\n\t     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n\t     * This includes errors caused by resolves and transition hooks.\n\t     *\n\t     * Note:\n\t     * This handler does not receive certain Transition rejections.\n\t     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n\t     *\n\t     * The built-in default error handler logs the error to the console.\n\t     *\n\t     * You can provide your own custom handler.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * stateService.defaultErrorHandler(function() {\n\t     *   // Do not log transitionTo errors\n\t     * });\n\t     * ```\n\t     *\n\t     * @param handler a global error handler function\n\t     * @returns the current global error handler\n\t     */\n\t    StateService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        var reg = this.router.stateRegistry;\n\t        if (arguments.length === 0)\n\t            return reg.get();\n\t        return reg.get(stateOrName, base || this.$current);\n\t    };\n\t    /**\n\t     * Lazy loads a state\n\t     *\n\t     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n\t     *\n\t     * @param stateOrName the state that should be lazy loaded\n\t     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n\t     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n\t     * This noop transition is not actually run.\n\t     *\n\t     * @returns a promise to lazy load\n\t     */\n\t    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n\t        var state = this.get(stateOrName);\n\t        if (!state || !state.lazyLoad)\n\t            throw new Error(\"Can not lazy load \" + stateOrName);\n\t        var currentPath = this.getCurrentPath();\n\t        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n\t        transition = transition || this.router.transitionService.create(currentPath, target);\n\t        return lazyLoad_1.lazyLoadState(transition, state);\n\t    };\n\t    return StateService;\n\t}());\n\texports.StateService = StateService;\n\t//# sourceMappingURL=stateService.js.map\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar stateParams_1 = __webpack_require__(49);\n\tvar queue_1 = __webpack_require__(10);\n\tvar common_1 = __webpack_require__(5);\n\t/**\n\t * Global router state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, etc.\n\t */\n\tvar Globals = (function () {\n\t    /** @hidden */\n\t    function Globals(transitionService) {\n\t        var _this = this;\n\t        /** @inheritdoc */\n\t        this.params = new stateParams_1.StateParams();\n\t        /** @internalapi */\n\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t        /** @internalapi */\n\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t        // TODO: This probably belongs in a hooks/globals.ts\n\t        var beforeNewTransition = function ($transition$) {\n\t            _this.transition = $transition$;\n\t            _this.transitionHistory.enqueue($transition$);\n\t            var updateGlobalState = function () {\n\t                _this.successfulTransitions.enqueue($transition$);\n\t                _this.$current = $transition$.$to();\n\t                _this.current = _this.$current.self;\n\t                common_1.copy($transition$.params(), _this.params);\n\t            };\n\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t                _this.transition = null; };\n\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t        };\n\t        transitionService.onBefore({}, beforeNewTransition);\n\t    }\n\t    return Globals;\n\t}());\n\texports.Globals = Globals;\n\t//# sourceMappingURL=globals.js.map\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(5);\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        common_1.extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return common_1.extend({}, inherited, newParams);\n\t    };\n\t    ;\n\t    return StateParams;\n\t}());\n\texports.StateParams = StateParams;\n\t//# sourceMappingURL=stateParams.js.map\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(8);\n\tvar common_1 = __webpack_require__(5);\n\t/** @hidden */\n\tvar makeStub = function (keys) {\n\t    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n\t};\n\t/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n\t/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n\t/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n\t/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n\t/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n\t/**\n\t * API for URL management\n\t */\n\tvar UrlService = (function () {\n\t    /** @hidden */\n\t    function UrlService(router, lateBind) {\n\t        if (lateBind === void 0) { lateBind = true; }\n\t        this.router = router;\n\t        this.rules = {};\n\t        this.config = {};\n\t        // proxy function calls from UrlService to the LocationService/LocationConfig\n\t        var locationServices = function () { return router.locationService; };\n\t        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n\t        var locationConfig = function () { return router.locationConfig; };\n\t        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n\t        var umf = function () { return router.urlMatcherFactory; };\n\t        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n\t        var urlRouter = function () { return router.urlRouter; };\n\t        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n\t        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n\t    }\n\t    UrlService.prototype.url = function (newurl, replace, state) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.path = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.search = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.hash = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.onChange = function (callback) { return; };\n\t    ;\n\t    /**\n\t     * Returns the current URL parts\n\t     *\n\t     * This method returns the current URL components as a [[UrlParts]] object.\n\t     *\n\t     * @returns the current url parts\n\t     */\n\t    UrlService.prototype.parts = function () {\n\t        return { path: this.path(), search: this.search(), hash: this.hash() };\n\t    };\n\t    UrlService.prototype.dispose = function () { };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.sync = function (evt) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.listen = function (enabled) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.deferIntercept = function (defer) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.match = function (urlParts) { return; };\n\t    return UrlService;\n\t}());\n\t/** @hidden */\n\tUrlService.locationServiceStub = makeStub(locationServicesFns);\n\t/** @hidden */\n\tUrlService.locationConfigStub = makeStub(locationConfigFns);\n\texports.UrlService = UrlService;\n\t//# sourceMappingURL=urlService.js.map\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(21));\n\t__export(__webpack_require__(30));\n\t__export(__webpack_require__(49));\n\t__export(__webpack_require__(22));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module path */ /** for typedoc */\n\t__export(__webpack_require__(20));\n\t__export(__webpack_require__(23));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module resolve */ /** for typedoc */\n\t__export(__webpack_require__(26));\n\t__export(__webpack_require__(24));\n\t__export(__webpack_require__(25));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(45));\n\t__export(__webpack_require__(33));\n\t__export(__webpack_require__(44));\n\t__export(__webpack_require__(46));\n\t__export(__webpack_require__(43));\n\t__export(__webpack_require__(47));\n\t__export(__webpack_require__(17));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * # Transition subsystem\n\t *\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See:\n\t * - [[TransitionService]]\n\t * - [[Transition]]\n\t * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module transition\n\t */ /** for typedoc */\n\t__export(__webpack_require__(15));\n\t__export(__webpack_require__(19));\n\t__export(__webpack_require__(18));\n\t__export(__webpack_require__(12));\n\t__export(__webpack_require__(13));\n\t__export(__webpack_require__(16));\n\t__export(__webpack_require__(41));\n\t__export(__webpack_require__(34));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(29));\n\t__export(__webpack_require__(28));\n\t__export(__webpack_require__(31));\n\t__export(__webpack_require__(32));\n\t__export(__webpack_require__(50));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(42));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t/**\n\t * # Core classes and interfaces\n\t *\n\t * The classes and interfaces that are core to ui-router and do not belong\n\t * to a more specific subsystem (such as resolve).\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module core\n\t */ /** for typedoc */\n\t\"use strict\";\n\t/** @internalapi */\n\tvar UIRouterPluginBase = (function () {\n\t    function UIRouterPluginBase() {\n\t    }\n\t    UIRouterPluginBase.prototype.dispose = function (router) { };\n\t    return UIRouterPluginBase;\n\t}());\n\texports.UIRouterPluginBase = UIRouterPluginBase;\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MnViewConfig, UIRouter, UIRouterMarionette, UIViewMarionette, getStateHookBuilder, hashLocationPlugin, mnViewsBuilder, ref, ref1, routerInstance, servicesPlugin, viewConfigFactory,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty,\n\t  slice = [].slice;\n\t\n\tUIRouter = __webpack_require__(3).UIRouter;\n\t\n\tref = __webpack_require__(60), mnViewsBuilder = ref.mnViewsBuilder, MnViewConfig = ref.MnViewConfig;\n\t\n\tref1 = __webpack_require__(61), hashLocationPlugin = ref1.hashLocationPlugin, servicesPlugin = ref1.servicesPlugin;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\tgetStateHookBuilder = __webpack_require__(75);\n\t\n\trouterInstance = null;\n\t\n\tviewConfigFactory = function(node, config) {\n\t  return new MnViewConfig(node, config);\n\t};\n\t\n\tUIRouterMarionette = (function(superClass) {\n\t  extend(UIRouterMarionette, superClass);\n\t\n\t  UIRouterMarionette.getInstance = function() {\n\t    return routerInstance || (routerInstance = new this);\n\t  };\n\t\n\t  function UIRouterMarionette() {\n\t    UIRouterMarionette.__super__.constructor.apply(this, arguments);\n\t    this._started = false;\n\t    this.viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory);\n\t    this.plugin(servicesPlugin);\n\t    this.plugin(hashLocationPlugin);\n\t    this.stateRegistry.decorator(\"views\", mnViewsBuilder);\n\t    this.stateRegistry.decorator(\"onExit\", getStateHookBuilder(\"onExit\"));\n\t    this.stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"));\n\t    this.stateRegistry.decorator(\"onEnter\", getStateHookBuilder(\"onEnter\"));\n\t    routerInstance = this;\n\t  }\n\t\n\t  UIRouterMarionette.prototype.addState = function(def) {\n\t    this.stateRegistry.register(def);\n\t    return this;\n\t  };\n\t\n\t  UIRouterMarionette.prototype.start = function(rootRegion) {\n\t    this.rootRegion = rootRegion;\n\t    if (this._started) {\n\t      throw new Error(\"Router was already started\");\n\t    }\n\t    this.rootRegion.uiView = new UIViewMarionette(this, null, this.rootRegion, \"\");\n\t    this.rootRegion.uiView.register();\n\t    this.urlMatcherFactory.$get();\n\t    this.urlService.listen();\n\t    this.urlService.sync();\n\t    this._started = true;\n\t    return this;\n\t  };\n\t\n\t  UIRouterMarionette.prototype.beforeBackboneRoute = function(beforeRouteCallback) {\n\t    var originalRoute, uiRouter;\n\t    if (typeof beforeRouteCallback !== 'function') {\n\t      return;\n\t    }\n\t    originalRoute = Backbone.Router.prototype.route;\n\t    uiRouter = this;\n\t    return Backbone.Router.prototype.route = function(route, name, originalCallback) {\n\t      var bbRouter, wrappedCallback;\n\t      bbRouter = this;\n\t      wrappedCallback = function() {\n\t        var result, routeParams;\n\t        routeParams = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t        result = beforeRouteCallback.call(uiRouter, route, name, routeParams, uiRouter.stateService);\n\t        if (_.isFunction(result != null ? result.then : void 0)) {\n\t          return result.then(function() {\n\t            return originalCallback.apply(bbRouter, routeParams);\n\t          });\n\t        } else {\n\t          return originalCallback.apply(bbRouter, routeParams);\n\t        }\n\t      };\n\t      return originalRoute.call(bbRouter, route, name, wrappedCallback);\n\t    };\n\t  };\n\t\n\t  return UIRouterMarionette;\n\t\n\t})(UIRouter);\n\t\n\texports.UIViewMarionette = UIViewMarionette;\n\t\n\texports.Router = UIRouterMarionette;\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MnViewConfig, Resolvable, ResolveContext, ViewService, hasAnyKey, ref, services, viewConfigId;\n\t\n\tref = __webpack_require__(3), services = ref.services, ViewService = ref.ViewService, ResolveContext = ref.ResolveContext, Resolvable = ref.Resolvable;\n\t\n\tviewConfigId = 0;\n\t\n\thasAnyKey = function(keys, obj) {\n\t  return _.reduce(keys, (function(memo, key) {\n\t    return memo || (obj[key] != null);\n\t  }), false);\n\t};\n\t\n\texports.mnViewsBuilder = function(state) {\n\t  var keys, views, viewsObject;\n\t  if (!state.parent) {\n\t    return;\n\t  }\n\t  keys = ['view', 'controller'];\n\t  views = {};\n\t  viewsObject = state.views || {\n\t    $default: _.pick(state, keys)\n\t  };\n\t  _.each(viewsObject, function(config, name) {\n\t    var i, key, len, normalized, results;\n\t    name = name || '$default';\n\t    config.resolveAs = config.resolveAs || '$resolve';\n\t    config.$type = 'backbone';\n\t    config.$context = state;\n\t    config.$name = name;\n\t    normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n\t    config.$uiViewName = normalized.uiViewName;\n\t    config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t    views[name] = config;\n\t    results = [];\n\t    for (i = 0, len = keys.length; i < len; i++) {\n\t      key = keys[i];\n\t      if (config.hasOwnProperty(key)) {\n\t        if (config[key] == null) {\n\t          results.push(console.warn(\"ui-router state: \" + state.name + \" - null or undefined value for '\" + key + \"' in '\" + config.$name + \"'\"));\n\t        } else if (typeof config[key] !== 'function') {\n\t          results.push(console.warn(\"ui-router state: \" + state.name + \" - '\" + key + \"' in '\" + config.$name + \"' was not a function\"));\n\t        } else {\n\t          results.push(void 0);\n\t        }\n\t      } else {\n\t        results.push(void 0);\n\t      }\n\t    }\n\t    return results;\n\t  });\n\t  return views;\n\t};\n\t\n\texports.MnViewConfig = MnViewConfig = (function() {\n\t  function MnViewConfig(path, viewDecl) {\n\t    this.path = path;\n\t    this.viewDecl = viewDecl;\n\t    this.loaded = true;\n\t    this.$id = viewConfigId++;\n\t  }\n\t\n\t  MnViewConfig.prototype.load = function() {\n\t    return services.$q.when(this);\n\t  };\n\t\n\t  return MnViewConfig;\n\n\t})();\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(62));\n\t//# sourceMappingURL=vanilla.js.map\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * Naive, pure JS implementation of core ui-router services\n\t *\n\t *\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t__export(__webpack_require__(63));\n\t__export(__webpack_require__(64));\n\t__export(__webpack_require__(65));\n\t__export(__webpack_require__(67));\n\t__export(__webpack_require__(68));\n\t__export(__webpack_require__(69));\n\t__export(__webpack_require__(70));\n\t__export(__webpack_require__(71));\n\t__export(__webpack_require__(72));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(4);\n\t/**\n\t * An angular1-like promise api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This API provides native ES6 promise support wrapped as a $q-like API.\n\t * Internally, UI-Router uses this $q object to perform promise operations.\n\t * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n\t *\n\t * $q-like promise api\n\t */\n\texports.$q = {\n\t    /** Normalizes a value as a promise */\n\t    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n\t    /** Normalizes a value as a promise rejection */\n\t    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n\t    /** @returns a deferred object, which has `resolve` and `reject` functions */\n\t    defer: function () {\n\t        var deferred = {};\n\t        deferred.promise = new Promise(function (resolve, reject) {\n\t            deferred.resolve = resolve;\n\t            deferred.reject = reject;\n\t        });\n\t        return deferred;\n\t    },\n\t    /** Like Promise.all(), but also supports object key/promise notation like $q */\n\t    all: function (promises) {\n\t        if (index_1.isArray(promises)) {\n\t            return new Promise(function (resolve, reject) {\n\t                var results = [];\n\t                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n\t                    .then(function () { resolve(results); }, reject);\n\t            });\n\t        }\n\t        if (index_1.isObject(promises)) {\n\t            // Convert promises map to promises array.\n\t            // When each promise resolves, map it to a tuple { key: key, val: val }\n\t            var chain = Object.keys(promises)\n\t                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n\t            // Then wait for all promises to resolve, and convert them back to an object\n\t            return exports.$q.all(chain).then(function (values) {\n\t                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n\t            });\n\t        }\n\t    }\n\t};\n\t//# sourceMappingURL=$q.js.map\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(4);\n\t// globally available injectables\n\tvar globals = {};\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t/**\n\t * A basic angular1-like injector api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This object provides a naive implementation of a globally scoped dependency injection system.\n\t * It supports the following DI approaches:\n\t *\n\t * ### Function parameter names\n\t *\n\t * A function's `.toString()` is called, and the parameter names are parsed.\n\t * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n\t *\n\t * ```js\n\t * function injectedFunction(FooService, BarService) {\n\t *   // FooService and BarService are injected\n\t * }\n\t * ```\n\t *\n\t * ### Function annotation\n\t *\n\t * A function may be annotated with an array of dependency names as the `$inject` property.\n\t *\n\t * ```js\n\t * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n\t * function injectedFunction(fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }\n\t * ```\n\t *\n\t * ### Array notation\n\t *\n\t * An array provides the names of the dependencies to inject (as strings).\n\t * The function is the last element of the array.\n\t *\n\t * ```js\n\t * [ 'FooService', 'BarService', function (fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }]\n\t * ```\n\t *\n\t * @type {$InjectorLike}\n\t */\n\texports.$injector = {\n\t    /** Gets an object from DI based on a string token */\n\t    get: function (name) { return globals[name]; },\n\t    /** Returns true if an object named `name` exists in global DI */\n\t    has: function (name) { return exports.$injector.get(name) != null; },\n\t    /**\n\t     * Injects a function\n\t     *\n\t     * @param fn the function to inject\n\t     * @param context the function's `this` binding\n\t     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n\t     */\n\t    invoke: function (fn, context, locals) {\n\t        var all = index_1.extend({}, globals, locals || {});\n\t        var params = exports.$injector.annotate(fn);\n\t        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n\t        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n\t        if (index_1.isFunction(fn))\n\t            return fn.apply(context, args);\n\t        else\n\t            return fn.slice(-1)[0].apply(context, args);\n\t    },\n\t    /**\n\t     * Returns a function's dependencies\n\t     *\n\t     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n\t     * @return an array of `string`s\n\t     */\n\t    annotate: function (fn) {\n\t        if (!index_1.isInjectable(fn))\n\t            throw new Error(\"Not an injectable function: \" + fn);\n\t        if (fn && fn.$inject)\n\t            return fn.$inject;\n\t        if (index_1.isArray(fn))\n\t            return fn.slice(0, -1);\n\t        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n\t        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\t        return result || [];\n\t    }\n\t};\n\t//# sourceMappingURL=$injector.js.map\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */ /** */\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(66);\n\tvar predicates_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(5);\n\t/** A base `LocationServices` */\n\tvar BaseLocationServices = (function () {\n\t    function BaseLocationServices(router, fireAfterUpdate) {\n\t        var _this = this;\n\t        this.fireAfterUpdate = fireAfterUpdate;\n\t        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n\t        this._listeners = [];\n\t        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n\t        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n\t        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n\t        this._location = window && window.location;\n\t        this._history = window && window.history;\n\t    }\n\t    BaseLocationServices.prototype.url = function (url, replace) {\n\t        if (replace === void 0) { replace = true; }\n\t        if (predicates_1.isDefined(url) && url !== this._get()) {\n\t            this._set(null, null, url, replace);\n\t            if (this.fireAfterUpdate) {\n\t                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n\t                this._listeners.forEach(function (cb) { return cb(evt_1); });\n\t            }\n\t        }\n\t        return utils_1.buildUrl(this);\n\t    };\n\t    BaseLocationServices.prototype.onChange = function (cb) {\n\t        var _this = this;\n\t        this._listeners.push(cb);\n\t        return function () { return common_1.removeFrom(_this._listeners, cb); };\n\t    };\n\t    BaseLocationServices.prototype.dispose = function (router) {\n\t        common_1.deregAll(this._listeners);\n\t    };\n\t    return BaseLocationServices;\n\t}());\n\texports.BaseLocationServices = BaseLocationServices;\n\t//# sourceMappingURL=baseLocationService.js.map\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(4);\n\tvar common_1 = __webpack_require__(5);\n\tvar beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\texports.splitHash = beforeAfterSubstr(\"#\");\n\texports.splitQuery = beforeAfterSubstr(\"?\");\n\texports.splitEqual = beforeAfterSubstr(\"=\");\n\texports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\n\texports.keyValsToObjectR = function (accum, _a) {\n\t    var key = _a[0], val = _a[1];\n\t    if (!accum.hasOwnProperty(key)) {\n\t        accum[key] = val;\n\t    }\n\t    else if (index_1.isArray(accum[key])) {\n\t        accum[key].push(val);\n\t    }\n\t    else {\n\t        accum[key] = [accum[key], val];\n\t    }\n\t    return accum;\n\t};\n\texports.getParams = function (queryString) {\n\t    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n\t};\n\tfunction parseUrl(url) {\n\t    var orEmptyString = function (x) { return x || \"\"; };\n\t    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n\t    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n\t    return { path: path, search: search, hash: hash, url: url };\n\t}\n\texports.parseUrl = parseUrl;\n\texports.buildUrl = function (loc) {\n\t    var path = loc.path();\n\t    var searchObject = loc.search();\n\t    var hash = loc.hash();\n\t    var search = Object.keys(searchObject).map(function (key) {\n\t        var param = searchObject[key];\n\t        var vals = index_1.isArray(param) ? param : [param];\n\t        return vals.map(function (val) { return key + \"=\" + val; });\n\t    }).reduce(common_1.unnestR, []).join(\"&\");\n\t    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n\t};\n\tfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n\t    return function (router) {\n\t        var service = router.locationService = new serviceClass(router);\n\t        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n\t        function dispose(router) {\n\t            router.dispose(service);\n\t            router.dispose(configuration);\n\t        }\n\t        return { name: name, service: service, configuration: configuration, dispose: dispose };\n\t    };\n\t}\n\texports.locationPluginFactory = locationPluginFactory;\n\t//# sourceMappingURL=utils.js.map\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\n\tvar HashLocationService = (function (_super) {\n\t    __extends(HashLocationService, _super);\n\t    function HashLocationService(router) {\n\t        var _this = _super.call(this, router, false) || this;\n\t        window.addEventListener('hashchange', _this._listener, false);\n\t        return _this;\n\t    }\n\t    HashLocationService.prototype._get = function () {\n\t        return utils_1.trimHashVal(this._location.hash);\n\t    };\n\t    HashLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._location.hash = url;\n\t    };\n\t    HashLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener('hashchange', this._listener);\n\t    };\n\t    return HashLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.HashLocationService = HashLocationService;\n\t//# sourceMappingURL=hashLocationService.js.map\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that gets/sets the current location from an in-memory object */\n\tvar MemoryLocationService = (function (_super) {\n\t    __extends(MemoryLocationService, _super);\n\t    function MemoryLocationService(router) {\n\t        return _super.call(this, router, true) || this;\n\t    }\n\t    MemoryLocationService.prototype._get = function () {\n\t        return this._url;\n\t    };\n\t    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._url = url;\n\t    };\n\t    return MemoryLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.MemoryLocationService = MemoryLocationService;\n\t//# sourceMappingURL=memoryLocationService.js.map\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/**\n\t * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n\t *\n\t * Uses `history.pushState` and `history.replaceState`\n\t */\n\tvar PushStateLocationService = (function (_super) {\n\t    __extends(PushStateLocationService, _super);\n\t    function PushStateLocationService(router) {\n\t        var _this = _super.call(this, router, true) || this;\n\t        _this._config = router.urlService.config;\n\t        window.addEventListener(\"popstate\", _this._listener, false);\n\t        return _this;\n\t    }\n\t    ;\n\t    PushStateLocationService.prototype._get = function () {\n\t        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n\t        search = utils_1.splitQuery(search)[1]; // strip ? if found\n\t        hash = utils_1.splitHash(hash)[1]; // strip # if found\n\t        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n\t    };\n\t    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n\t        var _a = this, _config = _a._config, _history = _a._history;\n\t        var fullUrl = _config.baseHref() + url;\n\t        if (replace) {\n\t            _history.replaceState(state, title, fullUrl);\n\t        }\n\t        else {\n\t            _history.pushState(state, title, fullUrl);\n\t        }\n\t    };\n\t    PushStateLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener(\"popstate\", this._listener);\n\t    };\n\t    return PushStateLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.PushStateLocationService = PushStateLocationService;\n\t//# sourceMappingURL=pushStateLocationService.js.map\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(5);\n\t/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\n\tvar MemoryLocationConfig = (function () {\n\t    function MemoryLocationConfig() {\n\t        var _this = this;\n\t        this._baseHref = '';\n\t        this._port = 80;\n\t        this._protocol = \"http\";\n\t        this._host = \"localhost\";\n\t        this._hashPrefix = \"\";\n\t        this.port = function () { return _this._port; };\n\t        this.protocol = function () { return _this._protocol; };\n\t        this.host = function () { return _this._host; };\n\t        this.baseHref = function () { return _this._baseHref; };\n\t        this.html5Mode = function () { return false; };\n\t        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n\t        this.dispose = common_1.noop;\n\t    }\n\t    return MemoryLocationConfig;\n\t}());\n\texports.MemoryLocationConfig = MemoryLocationConfig;\n\t//# sourceMappingURL=memoryLocationConfig.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar predicates_1 = __webpack_require__(6);\n\t/** A `LocationConfig` that delegates to the browser's `location` object */\n\tvar BrowserLocationConfig = (function () {\n\t    function BrowserLocationConfig(router, _isHtml5) {\n\t        if (_isHtml5 === void 0) { _isHtml5 = false; }\n\t        this._isHtml5 = _isHtml5;\n\t        this._baseHref = undefined;\n\t        this._hashPrefix = \"\";\n\t    }\n\t    BrowserLocationConfig.prototype.port = function () {\n\t        return parseInt(location.port);\n\t    };\n\t    BrowserLocationConfig.prototype.protocol = function () {\n\t        return location.protocol;\n\t    };\n\t    BrowserLocationConfig.prototype.host = function () {\n\t        return location.host;\n\t    };\n\t    BrowserLocationConfig.prototype.html5Mode = function () {\n\t        return this._isHtml5;\n\t    };\n\t    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n\t        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n\t    };\n\t    ;\n\t    BrowserLocationConfig.prototype.baseHref = function (href) {\n\t        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n\t    };\n\t    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n\t        var baseTags = document.getElementsByTagName(\"base\");\n\t        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n\t    };\n\t    BrowserLocationConfig.prototype.dispose = function () { };\n\t    return BrowserLocationConfig;\n\t}());\n\texports.BrowserLocationConfig = BrowserLocationConfig;\n\t//# sourceMappingURL=browserLocationConfig.js.map\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar browserLocationConfig_1 = __webpack_require__(71);\n\tvar hashLocationService_1 = __webpack_require__(67);\n\tvar utils_1 = __webpack_require__(66);\n\tvar pushStateLocationService_1 = __webpack_require__(69);\n\tvar memoryLocationService_1 = __webpack_require__(68);\n\tvar memoryLocationConfig_1 = __webpack_require__(70);\n\tvar _injector_1 = __webpack_require__(64);\n\tvar _q_1 = __webpack_require__(63);\n\tvar coreservices_1 = __webpack_require__(8);\n\tfunction servicesPlugin(router) {\n\t    coreservices_1.services.$injector = _injector_1.$injector;\n\t    coreservices_1.services.$q = _q_1.$q;\n\t    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n\t}\n\texports.servicesPlugin = servicesPlugin;\n\t/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\n\texports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\n\texports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\n\texports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n\t//# sourceMappingURL=plugins.js.map\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, ResolveContext, UIViewMarionette, id,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tid = 0;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tResolveContext = __webpack_require__(3).ResolveContext;\n\t\n\texports.UIViewMarionette = UIViewMarionette = (function(superClass) {\n\t  extend(UIViewMarionette, superClass);\n\t\n\t  function UIViewMarionette() {\n\t    return UIViewMarionette.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UIViewMarionette.prototype.initialize = function(router, mnLayout, mnRegion, mnRegionName) {\n\t    var name, parentContext, parentFqn, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n\t    this.router = router;\n\t    this.mnRegion = mnRegion;\n\t    this.listenTo(mnLayout, \"before:destroy\", this.destroy);\n\t    name = mnRegionName || '$default';\n\t    parentContext = mnLayout != null ? (ref = mnLayout.parent) != null ? (ref1 = ref.uiView) != null ? (ref2 = ref1.activeUIView.config) != null ? (ref3 = ref2.viewDecl) != null ? ref3.$context : void 0 : void 0 : void 0 : void 0 : void 0;\n\t    parentFqn = mnLayout != null ? (ref4 = mnLayout.parent) != null ? (ref5 = ref4.uiView) != null ? (ref6 = ref5.activeUIView) != null ? ref6.fqn : void 0 : void 0 : void 0 : void 0;\n\t    return this.activeUIView = {\n\t      $type: 'backbone',\n\t      id: id++,\n\t      name: name,\n\t      fqn: parentFqn ? parentFqn + \".\" + name : name,\n\t      creationContext: parentContext || this.router.stateRegistry.root(),\n\t      configUpdated: (function(_this) {\n\t        return function(config) {\n\t          return _this.onConfigUpdated(config);\n\t        };\n\t      })(this),\n\t      config: void 0\n\t    };\n\t  };\n\t\n\t  UIViewMarionette.prototype.register = function() {\n\t    return this.deregister = this.router.viewService.registerUIView(this.activeUIView);\n\t  };\n\t\n\t  UIViewMarionette.prototype.onConfigUpdated = function(newConfig) {\n\t    if (!newConfig) {\n\t      return this.clearPreviousConfig();\n\t    }\n\t    if (newConfig.viewDecl.$type !== 'backbone') {\n\t      return;\n\t    }\n\t    if (this.activeUIView.config === newConfig) {\n\t      return;\n\t    }\n\t    return this.updateView(newConfig);\n\t  };\n\t\n\t  UIViewMarionette.prototype.updateView = function(newConfig) {\n\t    var controller, resolved, state, view;\n\t    this.activeUIView.config = newConfig;\n\t    resolved = this.getResolved(newConfig);\n\t    view = this.getView(newConfig, {\n\t      resolved: resolved\n\t    });\n\t    controller = this.getController(newConfig, {\n\t      resolved: resolved,\n\t      view: view\n\t    });\n\t    if (view != null) {\n\t      this.mnRegion.show(view);\n\t      if (controller != null) {\n\t        controller.triggerMethod(\"ui:view:show\");\n\t        this.listenToOnce(view, \"destroy\", function() {\n\t          return controller.destroy();\n\t        });\n\t      }\n\t    }\n\t    state = newConfig.path[newConfig.path.length - 1].state.self;\n\t    return this.registerEventCallbacks(state, view, controller);\n\t  };\n\t\n\t  UIViewMarionette.prototype.getResolved = function(config) {\n\t    var context, i, key, keys, len, resolved;\n\t    context = new ResolveContext(config.path);\n\t    resolved = {};\n\t    keys = _.filter(context.getTokens(), function(token) {\n\t      return typeof token === 'string';\n\t    });\n\t    for (i = 0, len = keys.length; i < len; i++) {\n\t      key = keys[i];\n\t      resolved[key] = context.getResolvable(key).data;\n\t    }\n\t    return resolved;\n\t  };\n\t\n\t  UIViewMarionette.prototype.getView = function(config, viewOptions) {\n\t    var ref, view;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.view : void 0 : void 0) != null) {\n\t      return view = new config.viewDecl.view(viewOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getController = function(config, controllerOptions) {\n\t    var ref;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.controller : void 0 : void 0) != null) {\n\t      return new config.viewDecl.controller(controllerOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.registerEventCallbacks = function(state, view, controller) {\n\t    var criteria;\n\t    criteria = {\n\t      exiting: state.name\n\t    };\n\t    if (view != null) {\n\t      this.registerExitCallback(view, criteria);\n\t    }\n\t    if (controller != null) {\n\t      return this.registerExitCallback(controller, criteria);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.registerExitCallback = function(component, criteria) {\n\t    var deregisterFn;\n\t    if (typeof component.uiCanExit === 'function') {\n\t      deregisterFn = this.router.transitionService.onBefore(criteria, component.uiCanExit, {\n\t        bind: component\n\t      });\n\t      return component.on(\"destroy\", deregisterFn);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.clearPreviousConfig = function() {\n\t    var ref;\n\t    this.mnRegion.empty();\n\t    (this.activeUIView.view != null) && ((ref = this.activeUIView.controller) != null ? ref.triggerMethod('view:destroyed') : void 0);\n\t    return this.activeUIView.config = void 0;\n\t  };\n\t\n\t  UIViewMarionette.prototype.onBeforeDestroy = function() {\n\t    return typeof this.deregister === \"function\" ? this.deregister() : void 0;\n\t  };\n\t\n\t  return UIViewMarionette;\n\t\n\t})(Mn.Object);\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ResolveContext, getLocals, getStateHookBuilder;\n\t\n\tResolveContext = __webpack_require__(3).ResolveContext;\n\t\n\tgetLocals = function(resolveContext) {\n\t  var i, key, len, resolvable, tokens, tuples, waitPolicy;\n\t  tokens = _.filter(resolveContext.getTokens(), function(token) {\n\t    return typeof token === 'string';\n\t  });\n\t  tuples = {};\n\t  for (i = 0, len = tokens.length; i < len; i++) {\n\t    key = tokens[i];\n\t    resolvable = resolveContext.getResolvable(key);\n\t    waitPolicy = resolveContext.getPolicy(resolvable).async;\n\t    tuples[key] = waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data;\n\t  }\n\t  return tuples;\n\t};\n\t\n\tmodule.exports = getStateHookBuilder = function(hookName) {\n\t  return function(state, parentFn) {\n\t    var decoratedHook, hook, pathname;\n\t    hook = state[hookName];\n\t    pathname = hookName === 'onExit' ? 'from' : 'to';\n\t    decoratedHook = function(transition, state) {\n\t      var locals, resolveContext;\n\t      resolveContext = new ResolveContext(transition.treeChanges(pathname));\n\t      locals = getLocals(resolveContext);\n\t      return hook(transition, state, locals);\n\t    };\n\t    if (hook != null) {\n\t      return decoratedHook;\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, Router, UISref, UISrefActive,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tRouter = __webpack_require__(59).Router;\n\t\n\texports.UISref = UISref = (function(superClass) {\n\t  extend(UISref, superClass);\n\t\n\t  function UISref() {\n\t    return UISref.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISref.prototype.ui = {\n\t    sref: '[ui-sref]'\n\t  };\n\t\n\t  UISref.prototype.events = {\n\t    'click @ui.ref': 'onClickLink'\n\t  };\n\t\n\t  UISref.prototype.onClickLink = function() {};\n\t\n\t  UISref.prototype.onAttach = function() {\n\t    var router;\n\t    router = Router.getInstance();\n\t    return this.ui.sref.each(function(i, e) {\n\t      var params, state, url;\n\t      e = $(e);\n\t      state = e.attr('ui-sref');\n\t      try {\n\t        params = JSON.parse(e.attr('ui-sparams'));\n\t      } catch (error) {}\n\t      url = router.stateService.href(state, params);\n\t      e.attr('href', url);\n\t      return e.click(function(event) {\n\t        var button;\n\t        button = event.which;\n\t        if (button > 1 || event.shiftKey || event.metaKey || event.altKey || event.ctrlKey || e.attr('target')) {\n\t          return;\n\t        }\n\t        router.stateService.go(state, params);\n\t        return event.preventDefault();\n\t      });\n\t    });\n\t  };\n\t\n\t  return UISref;\n\t\n\t})(Mn.Behavior);\n\t\n\texports.UISrefActive = UISrefActive = (function(superClass) {\n\t  extend(UISrefActive, superClass);\n\t\n\t  function UISrefActive() {\n\t    return UISrefActive.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISrefActive.prototype.ui = {\n\t    active: '[ui-sref-active]'\n\t  };\n\t\n\t  UISrefActive.prototype.defaults = {\n\t    activeClasses: 'ui-state-active',\n\t    applyToRoot: false,\n\t    modelStateField: 'state'\n\t  };\n\t\n\t  UISrefActive.prototype.initialize = function() {\n\t    this.router = Router.getInstance();\n\t    return this.deregister = this.router.transitionService.onSuccess({}, (function(_this) {\n\t      return function(transition) {\n\t        return _this.onStateChange();\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onRender = function() {\n\t    return this.onStateChange();\n\t  };\n\t\n\t  UISrefActive.prototype.onStateChange = function() {\n\t    var classFn, compareState, ref;\n\t    if (this.getOption('applyToRoot')) {\n\t      compareState = (ref = this.view.model) != null ? ref.get(this.getOption('modelStateField')) : void 0;\n\t      if (compareState != null) {\n\t        classFn = this.router.stateService.includes(compareState) ? 'addClass' : 'removeClass';\n\t        this.$el[classFn](this.options.activeClasses);\n\t      }\n\t    }\n\t    return this.ui.active.each((function(_this) {\n\t      return function(i, el) {\n\t        var $el, params;\n\t        $el = $(el);\n\t        params = $el.attr('ui-sparams');\n\t        if (params) {\n\t          params = JSON.parse(params);\n\t        }\n\t        compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref');\n\t        classFn = _this.router.stateService.includes(compareState, params) ? 'addClass' : 'removeClass';\n\t        return $el[classFn](_this.options.activeClasses);\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onBeforeDestroy = function() {\n\t    return this.deregister();\n\t  };\n\t\n\t  UISrefActive.prototype.removeListeners = function() {\n\t    return this.ui.active.off('ui:state:change');\n\t  };\n\t\n\t  return UISrefActive;\n\t\n\t})(Mn.Behavior);\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, Router, UILayoutMn2, UIViewMarionette,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\tRouter = __webpack_require__(59).Router;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tmodule.exports = UILayoutMn2 = (function(superClass) {\n\t  extend(UILayoutMn2, superClass);\n\t\n\t  function UILayoutMn2() {\n\t    UILayoutMn2.__super__.constructor.apply(this, arguments);\n\t    this.on(\"attach\", this.onAttachUI);\n\t    this.on(\"before:destroy\", this.onBeforeDestroyUI);\n\t  }\n\t\n\t  UILayoutMn2.prototype.regions = {\n\t    \"$default\": \"[ui-view]\"\n\t  };\n\t\n\t  UILayoutMn2.prototype.onAttachUI = function(me, parentRegion) {\n\t    var ref, region, regionName;\n\t    this.parent = parentRegion;\n\t    ref = this.regions;\n\t    for (regionName in ref) {\n\t      if (!hasProp.call(ref, regionName)) continue;\n\t      region = ref[regionName];\n\t      this[regionName].uiView = new UIViewMarionette(Router.getInstance(), this, this[regionName], regionName);\n\t      this[regionName].uiView.register();\n\t    }\n\t  };\n\t\n\t  UILayoutMn2.prototype.onBeforeDestroyUI = function() {\n\t    return this.parent = null;\n\t  };\n\t\n\t  return UILayoutMn2;\n\t\n\t})(Mn.LayoutView);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ui-router-marionette.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 89dbb5e3bbf8d99bad2e","_ = require('underscore')\n{ $q } = require('ui-router-core')\n\n{\n  UIViewMarionette\n  Router\n} = require('./router')\n\n{\n  UISref\n  UISrefActive\n} = require('./marionette/behaviors')\n\nUILayoutMn2 = require('./ui_layout_mn2')\n\n\n_.extend exports, {\n  Router\n  UISref\n  UISrefActive\n  UILayoutMn2\n  UIViewMarionette\n  $q\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}\n// module id = 2\n// module chunks = 0 1","/**\n * @coreapi\n * @module common\n */ /** */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./common/index\"));\n__export(require(\"./params/index\"));\n__export(require(\"./path/index\"));\n__export(require(\"./resolve/index\"));\n__export(require(\"./state/index\"));\n__export(require(\"./transition/index\"));\n__export(require(\"./url/index\"));\n__export(require(\"./view/index\"));\n__export(require(\"./globals\"));\n__export(require(\"./router\"));\n__export(require(\"./interface\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/index.js\n// module id = 3\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module common */ /** for typedoc */\n__export(require(\"./common\"));\n__export(require(\"./coreservices\"));\n__export(require(\"./glob\"));\n__export(require(\"./hof\"));\n__export(require(\"./predicates\"));\n__export(require(\"./queue\"));\n__export(require(\"./strings\"));\n__export(require(\"./trace\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/index.js\n// module id = 4\n// module chunks = 0 1","/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar hof_1 = require(\"./hof\");\nvar coreservices_1 = require(\"./coreservices\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = angular.extend || _extend;\nexports.equals = angular.equals || _equals;\nexports.identity = function (x) { return x; };\nexports.noop = function () { return undefined; };\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    if (opts === void 0) { opts = {}; }\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var defaults = merge.apply(null, [{}].concat(defaultsList));\n    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n}\nexports.defaults = defaults;\n/**\n * Merges properties from the list of objects to the destination object.\n * If a property already exists in the destination object, then it is not overwritten.\n */\nfunction merge(dst) {\n    var objs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objs[_i - 1] = arguments[_i];\n    }\n    exports.forEach(objs, function (obj) {\n        exports.forEach(obj, function (value, key) {\n            if (!dst.hasOwnProperty(key))\n                dst[key] = value;\n        });\n    });\n    return dst;\n}\nexports.merge = merge;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\nfunction pickOmitImpl(predicate, obj) {\n    var keys = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        keys[_i - 2] = arguments[_i];\n    }\n    var objCopy = {};\n    for (var key in obj) {\n        if (predicate(keys, key))\n            objCopy[key] = obj[key];\n    }\n    return objCopy;\n}\n/** Return a copy of the object only containing the whitelisted properties. */\nfunction pick(obj) {\n    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n}\nexports.pick = pick;\n/** Return a copy of the object omitting the blacklisted properties. */\nfunction omit(obj) {\n    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var arrayArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrayArgs[_i] = arguments[_i];\n    }\n    if (arrayArgs.length === 0)\n        return [];\n    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _copyProps(to, from) {\n    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n    return to;\n}\nfunction _extend(toObj) {\n    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n}\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function (a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/common.js\n// module id = 5\n// module chunks = 0 1","\"use strict\";\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */ /** */\nvar hof_1 = require(\"./hof\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/predicates.js\n// module id = 6\n// module chunks = 0 1","/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\n\"use strict\";\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/hof.js\n// module id = 7\n// module chunks = 0 1","\"use strict\";\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/coreservices.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** @deprecated whats the point? */\n    Glob.is = function (text) {\n        return text.indexOf('*') > -1;\n    };\n    /** @deprecated whats the point? */\n    Glob.fromString = function (text) {\n        if (!this.is(text))\n            return null;\n        return new Glob(text);\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/glob.js\n// module id = 9\n// module chunks = 0 1","/**\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/queue.js\n// module id = 10\n// module chunks = 0 1","/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar common_1 = require(\"./common\");\nvar hof_1 = require(\"./hof\");\nvar transition_1 = require(\"../transition/transition\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/strings.js\n// module id = 11\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var type = this.type, message = this.message, detail = detailString(this.detail);\n        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isTransitionRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n    };\n    /** Returns a TransitionRejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a TransitionRejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a TransitionRejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a TransitionRejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/rejectFactory.js\n// module id = 12\n// module chunks = 0 1","\"use strict\";\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar hookBuilder_1 = require(\"./hookBuilder\");\nvar node_1 = require(\"../path/node\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar param_1 = require(\"../params/param\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar router_1 = require(\"../router\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /**\n         * Checks if this transition is currently active/running.\n         */\n        this.isActive = function () { return _this === _this._options.current(); };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n        this.applyViewConfigs(router);\n        this.applyRootResolvables(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    Transition.prototype.applyRootResolvables = function (router) {\n        var _this = this;\n        var rootResolvables = [\n            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n        ];\n        var rootNode = this._treeChanges.to[0];\n        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n        context.addResolvables(rootResolvables, rootNode.state);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless  the target state explicitly specifies location)\n        if (this.options().source === 'url') {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.length === 0;\n    };\n    /**\n     * @hidden\n     */\n    Transition.prototype.hookBuilder = function () {\n        return new hookBuilder_1.HookBuilder(this);\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        var hookBuilder = this.hookBuilder();\n        var globals = this.router.globals;\n        globals.transitionHistory.enqueue(this);\n        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n            syncResult.catch(function () { return 0; }); // issue #2676\n            var rejectReason = syncResult._transitionRejection;\n            this._deferred.reject(rejectReason);\n            return this.promise;\n        }\n        if (!this.valid()) {\n            var error = new Error(this.error());\n            this._deferred.reject(error);\n            return this.promise;\n        }\n        if (this.ignored()) {\n            trace_1.trace.traceTransitionIgnored(this);\n            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n            return this.promise;\n        }\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n            runAllHooks(onSuccessHooks);\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n            runAllHooks(onErrorHooks);\n        };\n        trace_1.trace.traceTransitionStart(this);\n        // Chain the next hook off the previous\n        var appendHookToChain = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n        asyncHooks.reduce(appendHookToChain, syncResult)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transition.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"./strings\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/trace.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/interface.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.stateService = function () { return _this.transition.router.stateService; };\n        this.rejectIfSuperseded = function () {\n            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n    }\n    TransitionHook.prototype.invokeHook = function () {\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        if (this.rejectIfSuperseded()) {\n            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n        }\n        var cb = hook.callback;\n        var bind = this.options.bind;\n        var trans = this.transition;\n        var state = this.stateContext;\n        var errorHandler = hook.eventType.getErrorHandler(this);\n        var resultHandler = hook.eventType.getResultHandler(this);\n        resultHandler = resultHandler || common_1.identity;\n        if (!errorHandler) {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        try {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        catch (error) {\n            return errorHandler(error);\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.rejectIfSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess the resolved value\n            return result.then(this.handleHookResult.bind(this));\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and start a redirected Transition (to the TargetState).\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n     *\n     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n     */\n    TransitionHook.runOnBeforeHooks = function (hooks) {\n        var results = [];\n        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n            var hook = hooks_1[_i];\n            var hookResult = hook.invokeHook();\n            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n                // Break on first thrown error or false/TargetState\n                return hookResult;\n            }\n            results.push(hookResult);\n        }\n        return results\n            .filter(predicates_1.isPromise)\n            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n    };\n    return TransitionHook;\n}());\nTransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n        return hook.handleHookResult(result);\n    };\n};\nTransitionHook.IGNORE_RESULT = function (hook) {\n    return function (result) { return undefined; };\n};\nTransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n        return (hook.stateService().defaultErrorHandler()(error), undefined);\n    };\n};\nTransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n        return rejectFactory_1.Rejection.errored(error).toPromise();\n    };\n};\nTransitionHook.THROW_ERROR = function (hook) {\n    return undefined;\n};\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionHook.js\n// module id = 16\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/targetState.js\n// module id = 17\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar glob_1 = require(\"../common/glob\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookRegistry.js\n// module id = 18\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n        this.treeChanges = transition.treeChanges();\n        this.transitionOptions = transition.options();\n        this.toState = common_1.tail(this.treeChanges.to).state;\n        this.fromState = common_1.tail(this.treeChanges.from).state;\n        this.$transitions = transition.router.transitionService;\n        this.baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        return this.$transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var _this = this;\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n        if (!matchingHooks)\n            return [];\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(_this.treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, _this.baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookBuilder.js\n// module id = 19\n// module chunks = 0 1","\"use strict\";\n/** @module path */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar param_1 = require(\"../params/param\");\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrPath) {\n        if (stateOrPath instanceof PathNode) {\n            var node = stateOrPath;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrPath;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, keys) {\n        var _this = this;\n        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n        var paramValsEq = function (key) {\n            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n        };\n        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    /**\n     * Returns a new path which is a subpath of the first path which matched the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * Nodes are compared using their state property and parameter values.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param ignoreDynamicParams don't compare dynamic parameter values\n     */\n    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n        var matching = [];\n        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n            var a = pathA[i], b = pathB[i];\n            if (a.state !== b.state)\n                break;\n            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n            if (changedParams.length)\n                break;\n            matching.push(a);\n        }\n        return matching;\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=node.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/node.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n    });\n}\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var $$getDefaultValue = function () {\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            return defaultValue;\n        };\n        var $replace = function (val) {\n            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n            return replacement.length ? replacement[0] : val;\n        };\n        value = $replace(value);\n        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/param.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramType.js\n// module id = 22\n// module chunks = 0 1","/** @module path */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar targetState_1 = require(\"../state/targetState\");\nvar node_1 = require(\"../path/node\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathFactory = (function () {\n    function PathFactory() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathFactory.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathFactory.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathFactory.buildToPath = function (fromPath, targetState) {\n        var toPath = PathFactory.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathFactory.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var staticParams = function (state) {\n            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n        };\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, staticParams(node1.state));\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = node_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathFactory.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathFactory;\n}());\n/** Gets the raw parameter values from a path */\nPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\nexports.PathFactory = PathFactory;\n//# sourceMappingURL=pathFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/pathFactory.js\n// module id = 23\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar trace_1 = require(\"../common/trace\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n                return r.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolvable.js\n// module id = 24\n// module chunks = 0 1","\"use strict\";\n/** @module resolve */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar interface_1 = require(\"./interface\");\nvar resolvable_1 = require(\"./resolvable\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar strings_1 = require(\"../common/strings\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Depenency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolveContext.js\n// module id = 25\n// module chunks = 0 1","\"use strict\";\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/interface.js\n// module id = 26\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = require(\"./url/urlMatcherFactory\");\nvar urlRouter_1 = require(\"./url/urlRouter\");\nvar transitionService_1 = require(\"./transition/transitionService\");\nvar view_1 = require(\"./view/view\");\nvar stateRegistry_1 = require(\"./state/stateRegistry\");\nvar stateService_1 = require(\"./state/stateService\");\nvar globals_1 = require(\"./globals\");\nvar common_1 = require(\"./common/common\");\nvar predicates_1 = require(\"./common/predicates\");\nvar urlService_1 = require(\"./url/urlService\");\nvar trace_1 = require(\"./common/trace\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */\n        this.$id = _routerInstance++;\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.Globals(this.transitionService);\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._disposables = [];\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(this.stateRegistry);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/router.js\n// module id = 27\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar param_1 = require(\"../params/param\");\nvar paramTypes_1 = require(\"../params/paramTypes\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcherFactory.js\n// module id = 28\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar param_1 = require(\"../params/param\");\nvar strings_1 = require(\"../common/strings\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this], parent: null, pattern: null };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        var parent = this._cache.parent;\n        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n            null);\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var _this = this;\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        return common_1.pairs(params || {}).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return validParamVal(_this.parameter(key), val);\n        }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        if (!this.validates(values))\n            return null;\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n        /**\n         * Given a Param,\n         * Applies the parameter value, then returns details about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a Param.  Fetch details about the parameter value\n            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (param) {\n            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        var splitOnSlash = strings_1.splitOnDelim('/');\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         */\n        var segments = function (matcher) {\n            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                .reduce(common_1.unnestR, [])\n                .reduce(strings_1.joinNeighborsR, [])\n                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                .reduce(common_1.unnestR, []);\n        };\n        var aSegments = segments(a), bSegments = segments(b);\n        // console.table( { aSegments, bSegments });\n        // Sort slashes first, then static strings, the Params\n        var weight = hof_1.pattern([\n            [hof_1.eq(\"/\"), hof_1.val(1)],\n            [predicates_1.isString, hof_1.val(2)],\n            [hof_1.is(param_1.Param), hof_1.val(3)]\n        ]);\n        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n        // console.table(pairs);\n        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcher.js\n// module id = 29\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramTypes.js\n// module id = 30\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar hof_1 = require(\"../common/hof\");\nvar urlRule_1 = require(\"./urlRule\");\nvar targetState_1 = require(\"../state/targetState\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash()\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        if (!urlMatcher.validates(params))\n            return null;\n        var url = urlMatcher.format(params);\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this.sort();\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n        this.sort();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n        }\n        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this.sort();\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\n//# sourceMappingURL=urlRouter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRouter.js\n// module id = 31\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar stateObject_1 = require(\"../state/stateObject\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[State]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRule.js\n// module id = 32\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar State = (function () {\n    function State(config) {\n        common_1.extend(this, config);\n        // Object.freeze(this);\n    }\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    State.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    State.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    State.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param`eters\n     *\n     * Gets [[Param]] information that is owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    State.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    State.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    State.prototype.toString = function () {\n        return this.fqn();\n    };\n    return State;\n}());\nexports.State = State;\n//# sourceMappingURL=stateObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateObject.js\n// module id = 33\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar transition_1 = require(\"./transition\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar resolve_1 = require(\"../hooks/resolve\");\nvar views_1 = require(\"../hooks/views\");\nvar url_1 = require(\"../hooks/url\");\nvar redirectTo_1 = require(\"../hooks/redirectTo\");\nvar onEnterExitRetain_1 = require(\"../hooks/onEnterExitRetain\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar transitionEventType_1 = require(\"./transitionEventType\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineDefaultPaths();\n        this._defineDefaultEvents();\n        this._registerDefaultTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        delete router.globals.transition;\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultPaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionService.js\n// module id = 34\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state)\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/resolve.js\n// module id = 35\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/views.js\n// module id = 36\n// module chunks = 0 1","\"use strict\";\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/url.js\n// module id = 37\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** */\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar targetState_1 = require(\"../state/targetState\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/redirectTo.js\n// module id = 38\n// module chunks = 0 1","\"use strict\";\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var hookFn = state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/onEnterExitRetain.js\n// module id = 39\n// module chunks = 0 1","\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/lazyLoad.js\n// module id = 40\n// module chunks = 0 1","\"use strict\";\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.rejectIfSuperseded = rejectIfSuperseded;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionEventType.js\n// module id = 41\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar trace_1 = require(\"../common/trace\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return the number of dots in the fully qualified name\n        function uiViewDepth(uiView) {\n            return uiView.fqn.split(\".\").length;\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/view.js\n// module id = 42\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar stateMatcher_1 = require(\"./stateMatcher\");\nvar stateBuilder_1 = require(\"./stateBuilder\");\nvar stateQueueManager_1 = require(\"./stateQueueManager\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[State]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[State]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {State[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateRegistry.js\n// module id = 43\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar predicates_1 = require(\"../common/predicates\");\nvar glob_1 = require(\"../common/glob\");\nvar common_1 = require(\"../common/common\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base) {\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr) {\n            var matches = common_1.values(this._states)\n                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateMatcher.js\n// module id = 44\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[State]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[State]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent))\n            return null;\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateBuilder.js\n// module id = 45\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar stateObject_1 = require(\"./stateObject\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (config) {\n        var _a = this, states = _a.states, queue = _a.queue;\n        // Wrap a new object around the state so we can store our private details easily.\n        // @TODO: state = new State(extend({}, config, { ... }))\n        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n            self: config,\n            resolve: config.resolve || [],\n            toString: function () { return config.name; }\n        }));\n        if (!predicates_1.isString(state.name))\n            throw new Error(\"State must have a valid name\");\n        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n            throw new Error(\"State '\" + state.name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = this.$registry.get(state.name);\n                if (existingState && existingState.name === state.name) {\n                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n                }\n                if (existingState && existingState.name === state.name + \".**\") {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingState);\n                }\n                states[state.name] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[state.name];\n            previousQueueLength[state.name] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateQueueManager.js\n// module id = 46\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar queue_1 = require(\"../common/queue\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar node_1 = require(\"../path/node\");\nvar transitionService_1 = require(\"../transition/transitionService\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar targetState_1 = require(\"./targetState\");\nvar param_1 = require(\"../params/param\");\nvar glob_1 = require(\"../common/glob\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[State]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid())\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            if (latestThing() !== latest)\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false\n        });\n    };\n    ;\n    /**\n     * Transition to a different state or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n     * This allows you to easily use an absolute or relative to path and specify\n     * only the parameters you'd like to update (while letting unspecified parameters\n     * inherit from the currently active ancestor states).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     *\n     * @param to Absolute state name, state object, or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n     *\n     *    Parameter inheritance only works between common ancestor states, I.e.\n     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     *    will get you all current parameters, etc.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * - Possible success values:\n     *    - $state.current\n     *\n     * - Possible rejection reasons:\n     *   - transition superseded - when a newer transition has been started after this one\n     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n     *   - transition failed - when a transition hook errors\n     *   - resolve error - when a resolve has errored or rejected\n     *\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        var transHistory = globals.transitionHistory;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    router.urlRouter.update();\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    router.urlRouter.update();\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n            absolute: options.absolute\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateService.js\n// module id = 47\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = require(\"./params/stateParams\");\nvar queue_1 = require(\"./common/queue\");\nvar common_1 = require(\"./common/common\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar Globals = (function () {\n    /** @hidden */\n    function Globals(transitionService) {\n        var _this = this;\n        /** @inheritdoc */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n        // TODO: This probably belongs in a hooks/globals.ts\n        var beforeNewTransition = function ($transition$) {\n            _this.transition = $transition$;\n            _this.transitionHistory.enqueue($transition$);\n            var updateGlobalState = function () {\n                _this.successfulTransitions.enqueue($transition$);\n                _this.$current = $transition$.$to();\n                _this.current = _this.$current.self;\n                common_1.copy($transition$.params(), _this.params);\n            };\n            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n                _this.transition = null; };\n            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n        };\n        transitionService.onBefore({}, beforeNewTransition);\n    }\n    return Globals;\n}());\nexports.Globals = Globals;\n//# sourceMappingURL=globals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/globals.js\n// module id = 48\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/stateParams.js\n// module id = 49\n// module chunks = 0 1","/**\n * @coreapi\n * @module url\n */ /** */\n\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlService.js\n// module id = 50\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./param\"));\n__export(require(\"./paramTypes\"));\n__export(require(\"./stateParams\"));\n__export(require(\"./paramType\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/index.js\n// module id = 51\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module path */ /** for typedoc */\n__export(require(\"./node\"));\n__export(require(\"./pathFactory\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/index.js\n// module id = 52\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module resolve */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./resolvable\"));\n__export(require(\"./resolveContext\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/index.js\n// module id = 53\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./stateBuilder\"));\n__export(require(\"./stateObject\"));\n__export(require(\"./stateMatcher\"));\n__export(require(\"./stateQueueManager\"));\n__export(require(\"./stateRegistry\"));\n__export(require(\"./stateService\"));\n__export(require(\"./targetState\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/index.js\n// module id = 54\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./hookBuilder\"));\n__export(require(\"./hookRegistry\"));\n__export(require(\"./rejectFactory\"));\n__export(require(\"./transition\"));\n__export(require(\"./transitionHook\"));\n__export(require(\"./transitionEventType\"));\n__export(require(\"./transitionService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/index.js\n// module id = 55\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./urlMatcher\"));\n__export(require(\"./urlMatcherFactory\"));\n__export(require(\"./urlRouter\"));\n__export(require(\"./urlRule\"));\n__export(require(\"./urlService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/index.js\n// module id = 56\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./view\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/index.js\n// module id = 57\n// module chunks = 0 1","/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\n\"use strict\";\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/interface.js\n// module id = 58\n// module chunks = 0 1","{ UIRouter } = require('ui-router-core')\n{ mnViewsBuilder, MnViewConfig } = require('./state_views_builder')\n{ hashLocationPlugin, servicesPlugin } = require('ui-router-core/lib/vanilla')\n{ UIViewMarionette } = require('./uiview')\n\ngetStateHookBuilder = require('./hook_builder')\n\nrouterInstance = null\n\nviewConfigFactory = (node, config) ->\n  new MnViewConfig(node, config)\n\n\nclass UIRouterMarionette extends UIRouter\n  @getInstance: ->\n    routerInstance or= new @\n\n  constructor: ->\n    super\n    @_started = false\n    @viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory)\n    @plugin(servicesPlugin)\n    @plugin(hashLocationPlugin)\n\n    @stateRegistry.decorator(\"views\", mnViewsBuilder)\n    @stateRegistry.decorator(\"onExit\", getStateHookBuilder(\"onExit\"))\n    @stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"))\n    @stateRegistry.decorator(\"onEnter\", getStateHookBuilder(\"onEnter\"))\n    routerInstance = @\n\n  # shortcut for adding a new state definition\n  addState: (def) ->\n    @stateRegistry.register(def)\n    return @\n\n\n  # start listening for router events. Takes a Marionette region to use as the\n  # root container (and can even share this region with Marionette routes using\n  # beforeBackboneRoute below!)\n  start: (@rootRegion) ->\n    throw new Error(\"Router was already started\") if @_started\n\n    @rootRegion.uiView = new UIViewMarionette(@, null, @rootRegion, \"\")\n    @rootRegion.uiView.register()\n\n    @urlMatcherFactory.$get()\n    @urlService.listen()\n    @urlService.sync()\n    @_started = true\n    return @\n\n\n  # Allows the application to run a synchronous or async callback before\n  # processing a Backbone/Marionette route. Intended to provide a way to wait\n  # for ui-router to enter an empty \"inactive\" state before the Backbone or\n  # Marionette routers start inserting things into the DOM.\n  # Replaces Backbone.Router.route, so could potentially conflict if used with\n  # something like backbone.routefilter which also wraps the same function.\n  # Should be fine in that specific case if called after routefilter has already\n  # patched it.\n  # Call order:\n  # - load routefilter or other addons that modify Backbone.Router.prototype.route\n  # - initialize marionette app and main content region\n  # - register beforeBackboneRoute callback\n  # - register backbone, marionette and ui-router routes\n  # - tell your routers to start\n  # Must be called before backbone/marionette routes are defined to have any\n  # effect.\n  # Example:\n  #   uiRouter.beforeBackboneRoute(function(route, name, routeParams, $state){\n  #     return $state.go(\"inactiveRouterState\")\n  #   })\n  #   uiRouter.addState({name: \"inactiveRouterState\"})\n  beforeBackboneRoute: (beforeRouteCallback) ->\n    return if typeof beforeRouteCallback isnt 'function'\n    originalRoute = Backbone.Router::route\n    uiRouter = @\n\n    Backbone.Router::route = (route, name, originalCallback) ->\n      bbRouter = @\n      wrappedCallback = (routeParams...) ->\n        result = beforeRouteCallback.call(uiRouter, route, name, routeParams, uiRouter.stateService)\n        if _.isFunction result?.then\n          # if it looks like a promise, wait for promise to resolve before\n          # processing route\n          result.then ->\n            originalCallback.apply(bbRouter, routeParams)\n        else\n          # if it doesn't look like a promise, just run normally.\n          originalCallback.apply(bbRouter, routeParams)\n\n      return originalRoute.call(bbRouter, route, name, wrappedCallback)\n\n\nexports.UIViewMarionette = UIViewMarionette\nexports.Router = UIRouterMarionette\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.coffee","# state->view logic specific to backbone (marionette)\n# ref: ui-router-ng1/statebuilders/views.ts\n\n# guess there's some missing magic here\n\n{ services, ViewService, ResolveContext, Resolvable } = require('ui-router-core')\n# AppLayout = require('javascripts/lib/views/layout')\nviewConfigId = 0\n\nhasAnyKey = (keys, obj) ->\n  # unused, copied from ui-router for ng1\n  _.reduce keys, ((memo, key) -> memo or obj[key]?), false\n\n\n\nexports.mnViewsBuilder = (state) ->\n  return if not state.parent\n\n  keys = ['view', 'controller']\n\n  views = {}\n  viewsObject = state.views or {$default: _.pick(state, keys)}\n\n  _.each viewsObject, (config, name) ->\n    name = name or '$default'\n\n    config.resolveAs = config.resolveAs or '$resolve'\n    config.$type = 'backbone'\n    config.$context = state\n    config.$name = name\n\n    normalized = ViewService.normalizeUIViewTarget config.$context, config.$name\n    config.$uiViewName = normalized.uiViewName\n    config.$uiViewContextAnchor = normalized.uiViewContextAnchor\n    views[name] = config\n\n    for key in keys\n      if config.hasOwnProperty(key)\n        # these could probably go through ui-router's logging/tracing service\n        if not config[key]?\n          console.warn(\"ui-router state: #{state.name} - null or undefined value for '#{key}' in '#{config.$name}'\")\n        else if typeof config[key] isnt 'function'\n          console.warn(\"ui-router state: #{state.name} - '#{key}' in '#{config.$name}' was not a function\")\n\n  return views\n\n\n\nexports.MnViewConfig = class MnViewConfig\n  constructor: (@path, @viewDecl) ->\n    @loaded = true\n    @$id = viewConfigId++\n\n  load: ->\n    services.$q.when(@)\n\n\n\n// WEBPACK FOOTER //\n// ./src/state_views_builder.coffee","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./vanilla/index\"));\n//# sourceMappingURL=vanilla.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla.js\n// module id = 61\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * Naive, pure JS implementation of core ui-router services\n *\n *\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(require(\"./$q\"));\n__export(require(\"./$injector\"));\n__export(require(\"./baseLocationService\"));\n__export(require(\"./hashLocationService\"));\n__export(require(\"./memoryLocationService\"));\n__export(require(\"./pushStateLocationService\"));\n__export(require(\"./memoryLocationConfig\"));\n__export(require(\"./browserLocationConfig\"));\n__export(require(\"./plugins\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/index.js\n// module id = 62\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return new Promise(function (resolve, reject) {\n                var results = [];\n                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n                    .then(function () { resolve(results); }, reject);\n            });\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=$q.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$q.js\n// module id = 63\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=$injector.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$injector.js\n// module id = 64\n// module chunks = 0 1","/**\n * @internalapi\n * @module vanilla\n */ /** */\n\"use strict\";\nvar utils_1 = require(\"./utils\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/baseLocationService.js\n// module id = 65\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\nvar common_1 = require(\"../common/common\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/utils.js\n// module id = 66\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/hashLocationService.js\n// module id = 67\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationService.js\n// module id = 68\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/pushStateLocationService.js\n// module id = 69\n// module chunks = 0 1","\"use strict\";\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationConfig.js\n// module id = 70\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = require(\"../common/predicates\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        return parseInt(location.port);\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol;\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/browserLocationConfig.js\n// module id = 71\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = require(\"./browserLocationConfig\");\nvar hashLocationService_1 = require(\"./hashLocationService\");\nvar utils_1 = require(\"./utils\");\nvar pushStateLocationService_1 = require(\"./pushStateLocationService\");\nvar memoryLocationService_1 = require(\"./memoryLocationService\");\nvar memoryLocationConfig_1 = require(\"./memoryLocationConfig\");\nvar _injector_1 = require(\"./$injector\");\nvar _q_1 = require(\"./$q\");\nvar coreservices_1 = require(\"../common/coreservices\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = _injector_1.$injector;\n    coreservices_1.services.$q = _q_1.$q;\n    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/plugins.js\n// module id = 72\n// module chunks = 0 1","id = 0\nMn = require('backbone.marionette')\n{ ResolveContext } = require('ui-router-core')\n\n\n\nexports.UIViewMarionette = class UIViewMarionette extends Mn.Object\n  # Side note:\n  # If Marionette provided a way to use custom Region subclasses on a per-View\n  # basis I could register ui-views directly in the Region constructor instead\n  # of having this separate UIViewMarionette class and a custom\n  # LayoutView subclass, but I don't want to do that globally and attempt to\n  # register regions that aren't going to be managed by ui-router.\n\n  initialize: (@router, mnLayout, @mnRegion, mnRegionName) ->\n    # Leverage Marionette's view lifecycle to know when to unregister\n    # the ui-view\n    @listenTo mnLayout, \"before:destroy\", @destroy\n\n    # Except for the top-level region passed to router.start(), a name should\n    # always be provided (even if it is '$default')\n    name = mnRegionName || '$default'\n    # TBH I'm not entirely sure what the context is for.\n    parentContext = mnLayout?.parent?.uiView?.activeUIView.config?.viewDecl?.$context\n    # nested FQNs will end up as something like\n    # '$default.$default.myNamedUIView.$default'\n    parentFqn = mnLayout?.parent?.uiView?.activeUIView?.fqn\n\n    @activeUIView =\n      $type: 'backbone'\n      id: id++\n      name: name\n      fqn: if parentFqn then \"#{parentFqn}.#{name}\" else name\n      creationContext: parentContext || @router.stateRegistry.root()\n      configUpdated: (config) => @onConfigUpdated(config)\n      config: undefined\n\n  register: ->\n    @deregister = @router.viewService.registerUIView(@activeUIView)\n\n  onConfigUpdated: (newConfig) ->\n    # If no config was provided (which happens right after registering this view\n    # or or when entering a state that has nothing to put in this slot), we want\n    # to make sure that the ui-view element is empty.\n    return @clearPreviousConfig() if not newConfig\n\n    # We somehow got a config for a different framework's ui-router integration\n    # (I imagine this is mainly an angular 1 to 2 migration thing?)\n    return if newConfig.viewDecl.$type isnt 'backbone'\n\n    # Got the currently active view config again.\n    return if @activeUIView.config is newConfig\n\n    @updateView(newConfig)\n\n  updateView: (newConfig) ->\n    @activeUIView.config = newConfig\n\n    # Create view and controller instances if they were specified in the\n    # state config.\n    resolved = @getResolved(newConfig)\n    view = @getView(newConfig, resolved: resolved)\n    controller = @getController(newConfig, resolved: resolved, view: view)\n\n    if view?\n      @mnRegion.show view\n      if controller?\n        controller.triggerMethod(\"ui:view:show\")\n        # this could be buggy if user specifies controller without view\n        # (zombie controllers)\n        @listenToOnce view, \"destroy\", ->\n          controller.destroy()\n\n    state = newConfig.path[newConfig.path.length-1].state.self\n    @registerEventCallbacks(state, view, controller)\n\n  getResolved: (config) ->\n    # Map all resolved objects (plus $stateParams and $transition$)\n    # to a plain object to pass to the view and controller\n    context = new ResolveContext(config.path)\n    resolved = {}\n    keys = _.filter context.getTokens(), (token) -> typeof token is 'string'\n    resolved[key] = context.getResolvable(key).data for key in keys\n\n    return resolved\n\n  getView: (config, viewOptions) ->\n    if config?.viewDecl?.view?\n      view = new config.viewDecl.view(viewOptions)\n\n  getController: (config, controllerOptions) ->\n    if config?.viewDecl?.controller?\n      return new config.viewDecl.controller(controllerOptions)\n\n  registerEventCallbacks: (state, view, controller) ->\n    criteria = {exiting: state.name}\n    @registerExitCallback(view, criteria) if view?\n    @registerExitCallback(controller, criteria) if controller?\n\n  registerExitCallback: (component, criteria) ->\n    # call the view or controller's uiCanExit method to determine if we should\n    # leave the current state.\n    if typeof component.uiCanExit is 'function'\n      deregisterFn = @router.transitionService.onBefore criteria, component.uiCanExit, bind: component\n      component.on \"destroy\", deregisterFn\n\n  clearPreviousConfig: ->\n    @mnRegion.empty()\n    @activeUIView.view? && @activeUIView.controller?.triggerMethod('view:destroyed')\n    @activeUIView.config = undefined\n\n  onBeforeDestroy: ->\n    @deregister?()\n\n\n\n// WEBPACK FOOTER //\n// ./src/uiview.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}\n// module id = 74\n// module chunks = 0 1","{ ResolveContext } = require('ui-router-core')\n\ngetLocals = (resolveContext) ->\n  # return a {k:v} map of the resolved objects for this state\n  tokens = _.filter resolveContext.getTokens(), (token) -> typeof token is 'string'\n  tuples = {}\n  for key in tokens\n    resolvable = resolveContext.getResolvable(key)\n    waitPolicy = resolveContext.getPolicy(resolvable).async\n    tuples[key] = if waitPolicy is 'NOWAIT' then resolvable.promise else resolvable.data\n  return tuples\n\nmodule.exports = getStateHookBuilder = (hookName) ->\n  # hookName = \"onEnter\"|\"onExit\"|\"onRetain\"\n  return (state, parentFn) ->\n    hook = state[hookName]\n    pathname = if hookName is 'onExit' then 'from' else 'to'\n\n    decoratedHook = (transition, state) ->\n      resolveContext = new ResolveContext(transition.treeChanges(pathname))\n      locals = getLocals(resolveContext)\n      return hook(transition, state, locals)\n\n    return decoratedHook if hook?\n\n\n\n// WEBPACK FOOTER //\n// ./src/hook_builder.coffee","Mn = require('backbone.marionette')\n{ Router } = require('../router')\n\n\n# A helper behavior for linking to states with or without state parameters.\n# Element attributes:\n#   ui-sref=\"app.state.substate\"\n#   ui-sparams='{\"client_id\": 5}' - optional if state doesn't need params or\n#                                   you're linking to a sibling/child state\n#                                   with the same parameters.\n#                                   The value should be HTML-encoded JSON.\n#                                   A template helper method is helpful here.\n# Behavior options: none\n#\nexports.UISref = class UISref extends Mn.Behavior\n  ui:\n    sref: '[ui-sref]'\n\n  events:\n    'click @ui.ref': 'onClickLink'\n\n  onClickLink: ->\n    # maybe parse and navigate to state if this element was inserted after\n    # original dom insertion (through data binding or whatever)\n\n  onAttach: ->\n    # Go through all the ui-sref links and turn their ui-sref and HTML-escaped\n    # ui-sparams attributes into a functioning app state link\n    router = Router.getInstance()\n    @ui.sref.each (i, e) ->\n      e = $(e)\n      state = e.attr('ui-sref')\n      try\n        params = JSON.parse(e.attr 'ui-sparams')\n      url = router.stateService.href(state, params)\n\n      e.attr('href', url)\n\n      # prevent the url from changing before state transition happens\n      e.click (event) ->\n        button = event.which\n        # ignore if this isn't a regular left click (enter key appears to be\n        # treated as a regular left click)\n        return if button > 1 || event.shiftKey || event.metaKey || event.altKey || event.ctrlKey || e.attr('target')\n        router.stateService.go(state, params)\n        event.preventDefault()\n\n\n# A behavior to toggle CSS classes on an element when a particular state\n# (with or without specific state parameters) is active.\n# Targets elements with a ui-sref-active attribute.\n# ui-sref-active can optionally have a value selecting the specific state\n# you want to watch for. If no value is provided, it will look to the state\n# referenced by ui-sref.\n# To help with lists that point at the same state with different state params,\n# the behavior will also compare the contents of ui-sparams, if present.\n# The default class is 'ui-state-active' but this can be customized in the\n# behavior options:\n# class MyView extends Marionette.ItemView\n#   behaviors:\n#     UISref: {}\n#     UISrefActive: {activeClasses: 'state-is-active', applyToRoot: true, rootStateModelAttribute: 'state'}\n#\n# Behavior options:\n# - activeClasses   - string. List of css classes to apply to elements when their\n#                     state is active.\n#\n# - applyToRoot     - boolean. Toggle applying active classes to the\n#                     root element. If you're using this option you also\n#                     likely want to set modelStateField. State params are not\n#                     currently supported for root elements with this option.\n#\n# - modelStateField - string. If the parent view has a backbone model,\n#                     look at this field on that model to determine\n#                     which state to compare against.\n#                     eg:\n#                     class MyView extends Marionette.ItemView\n#                       behaviors:\n#                         UISrefActive: {\n#                           applyToRoot: true,\n#                           modelStateField: \"active_state\"\n#                         }\n#                     ...\n#                     navItem = new NavbarItemModel({\n#                     state: \"app.clients.details\",\n#                        name: \"Details\"\n#                     })\n#                     view = new MyView({model: navItem})\n#\nexports.UISrefActive = class UISrefActive extends Mn.Behavior\n  ui:\n    active: '[ui-sref-active]'\n\n  defaults:\n    activeClasses: 'ui-state-active'\n    applyToRoot: false\n    modelStateField: 'state'\n\n  initialize: ->\n    @router = Router.getInstance()\n    @deregister = @router.transitionService.onSuccess {}, (transition) => @onStateChange()\n\n  onRender: ->\n    @onStateChange()\n\n  onStateChange: ->\n    if @getOption('applyToRoot')\n      # state params are not supported on the view root element\n      compareState = @view.model?.get(@getOption('modelStateField'))\n      if compareState?\n        classFn = if @router.stateService.includes(compareState) then 'addClass' else 'removeClass'\n        @$el[classFn](@options.activeClasses)\n\n    @ui.active.each (i, el) =>\n      $el = $(el)\n      params = $el.attr('ui-sparams')\n      if params\n        params = JSON.parse(params)\n      compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref') # fall back to the state in ui-sref if the ui-sref-active attribute is present but empty\n      classFn = if @router.stateService.includes(compareState, params) then 'addClass' else 'removeClass'\n      $el[classFn](@options.activeClasses)\n\n  onBeforeDestroy: ->\n    @deregister()\n\n  removeListeners: ->\n    @ui.active.off('ui:state:change')\n\n\n\n// WEBPACK FOOTER //\n// ./src/marionette/behaviors.coffee","{ UIViewMarionette } = require('./uiview')\n{ Router } = require('./router')\nMn = require('backbone.marionette')\n# A layout view for Marionette 2.x apps.\n# When the regions are created they also get registered as UIViews.\nmodule.exports = class UILayoutMn2 extends Mn.LayoutView\n  constructor: ->\n    super\n\n    @on \"attach\", @onAttachUI\n\n    @on \"before:destroy\", @onBeforeDestroyUI\n\n  regions:\n    # Register the first element with a ui-view attribute as the\n    # default region and UIView.\n    \"$default\": \"[ui-view]\"\n\n  onAttachUI: (me, parentRegion) ->\n    @parent = parentRegion\n    for own regionName, region of @regions\n      @[regionName].uiView = new UIViewMarionette Router.getInstance(), @, @[regionName], regionName\n      @[regionName].uiView.register()\n    return\n\n  onBeforeDestroyUI: ->\n    @parent = null\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui_layout_mn2.coffee"],"sourceRoot":""}