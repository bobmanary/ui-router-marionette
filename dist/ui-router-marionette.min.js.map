{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///ui-router-marionette.min.js","webpack:///webpack/bootstrap 1620402356dec27c4931?52de","webpack:///./src/index.coffee?3d3c","webpack:///external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}?8e93","webpack:///./src/router.coffee?5584","webpack:///./~/ui-router-core/lib/index.js?eb25","webpack:///./~/ui-router-core/lib/common/index.js?0a2c","webpack:///./~/ui-router-core/lib/common/common.js?cf4d","webpack:///./~/ui-router-core/lib/common/predicates.js?d043","webpack:///./~/ui-router-core/lib/common/hof.js?f100","webpack:///./~/ui-router-core/lib/common/coreservices.js?cdcd","webpack:///./~/ui-router-core/lib/common/glob.js?6b30","webpack:///./~/ui-router-core/lib/common/queue.js?d4a0","webpack:///./~/ui-router-core/lib/common/strings.js?311e","webpack:///./~/ui-router-core/lib/transition/rejectFactory.js?f278","webpack:///./~/ui-router-core/lib/transition/transition.js?cb73","webpack:///./~/ui-router-core/lib/common/trace.js?439e","webpack:///./~/ui-router-core/lib/transition/interface.js?90d0","webpack:///./~/ui-router-core/lib/transition/transitionHook.js?f358","webpack:///./~/ui-router-core/lib/state/targetState.js?a35d","webpack:///./~/ui-router-core/lib/transition/hookRegistry.js?e1c9","webpack:///./~/ui-router-core/lib/transition/hookBuilder.js?a5b9","webpack:///./~/ui-router-core/lib/path/node.js?8b12","webpack:///./~/ui-router-core/lib/params/param.js?ed16","webpack:///./~/ui-router-core/lib/params/paramType.js?33d4","webpack:///./~/ui-router-core/lib/path/pathFactory.js?a7a1","webpack:///./~/ui-router-core/lib/resolve/resolvable.js?1f09","webpack:///./~/ui-router-core/lib/resolve/resolveContext.js?1544","webpack:///./~/ui-router-core/lib/resolve/interface.js?a665","webpack:///./~/ui-router-core/lib/router.js?8102","webpack:///./~/ui-router-core/lib/url/urlMatcherFactory.js?891b","webpack:///./~/ui-router-core/lib/url/urlMatcher.js?d438","webpack:///./~/ui-router-core/lib/params/paramTypes.js?9d59","webpack:///./~/ui-router-core/lib/url/urlRouter.js?3a6c","webpack:///./~/ui-router-core/lib/url/urlRule.js?c28b","webpack:///./~/ui-router-core/lib/state/stateObject.js?c26a","webpack:///./~/ui-router-core/lib/transition/transitionService.js?3f7a","webpack:///./~/ui-router-core/lib/hooks/resolve.js?2c64","webpack:///./~/ui-router-core/lib/hooks/views.js?e195","webpack:///./~/ui-router-core/lib/hooks/url.js?b25f","webpack:///./~/ui-router-core/lib/hooks/redirectTo.js?5ea3","webpack:///./~/ui-router-core/lib/hooks/onEnterExitRetain.js?34a6","webpack:///./~/ui-router-core/lib/hooks/lazyLoad.js?7404","webpack:///./~/ui-router-core/lib/transition/transitionEventType.js?45f4","webpack:///./~/ui-router-core/lib/view/view.js?9313","webpack:///./~/ui-router-core/lib/state/stateRegistry.js?6ad5","webpack:///./~/ui-router-core/lib/state/stateMatcher.js?30f3","webpack:///./~/ui-router-core/lib/state/stateBuilder.js?a704","webpack:///./~/ui-router-core/lib/state/stateQueueManager.js?a439","webpack:///./~/ui-router-core/lib/state/stateService.js?0391","webpack:///./~/ui-router-core/lib/globals.js?0b2e","webpack:///./~/ui-router-core/lib/params/stateParams.js?da15","webpack:///./~/ui-router-core/lib/url/urlService.js?242b","webpack:///./~/ui-router-core/lib/params/index.js?06e6","webpack:///./~/ui-router-core/lib/path/index.js?c60f","webpack:///./~/ui-router-core/lib/resolve/index.js?785f","webpack:///./~/ui-router-core/lib/state/index.js?f8ea","webpack:///./~/ui-router-core/lib/transition/index.js?5aa5","webpack:///./~/ui-router-core/lib/url/index.js?33c0","webpack:///./~/ui-router-core/lib/view/index.js?03f5","webpack:///./~/ui-router-core/lib/interface.js?70a6","webpack:///./src/state_views_builder.coffee?56f9","webpack:///./~/ui-router-core/lib/vanilla.js?67d6","webpack:///./~/ui-router-core/lib/vanilla/index.js?6019","webpack:///./~/ui-router-core/lib/vanilla/$q.js?b905","webpack:///./~/ui-router-core/lib/vanilla/$injector.js?e177","webpack:///./~/ui-router-core/lib/vanilla/baseLocationService.js?6a47","webpack:///./~/ui-router-core/lib/vanilla/utils.js?762f","webpack:///./~/ui-router-core/lib/vanilla/hashLocationService.js?8c71","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationService.js?f52a","webpack:///./~/ui-router-core/lib/vanilla/pushStateLocationService.js?25c4","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationConfig.js?ea76","webpack:///./~/ui-router-core/lib/vanilla/browserLocationConfig.js?3d33","webpack:///./~/ui-router-core/lib/vanilla/plugins.js?4ce6","webpack:///./src/uiview.coffee?2999","webpack:///external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}?4413","webpack:///./src/marionette/behaviors.coffee?4f4a","webpack:///./src/ui_layout_mn2.coffee?372c"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_74__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","$q","Router","UILayoutMn2","UISref","UISrefActive","UIViewMarionette","_","ref","ref1","extend","MnViewConfig","UIRouter","UIRouterMarionette","hashLocationPlugin","mnViewsBuilder","ref2","routerInstance","servicesPlugin","viewConfigFactory","child","parent","ctor","constructor","key","hasProp","prototype","__super__","hasOwnProperty","node","config","superClass","apply","arguments","_started","viewService","_pluginapi","_viewConfigFactory","plugin","stateRegistry","decorator","getInstance","addState","def","register","start","rootRegion","options","Error","handleOptions","uiView","urlMatcherFactory","$get","urlService","listen","sync","onMnRoute","onRoute","oldProcessOnRoute","uiRouter","Marionette","AppRouter","_processOnRoute","mnRouteName","mnRouteArgs","mnRoutePath","invert","getOption","stateService","__export","createProxyFunctions","source","target","bind","fnNames","latebind","bindFunction","fnName","makeLateRebindFn","Object","keys","reduce","acc","name","_inArray","array","obj","indexOf","_removeFrom","idx","splice","_pushTo","arr","val","push","defaults","opts","defaultsList","_i","length","merge","concat","pick","dst","objs","forEach","value","ancestors","first","second","path","n","pickOmitImpl","predicate","objCopy","inArray","restArgs","omit","notInArray","item","pluck","collection","propName","map","hof_1","prop","filter","callback","predicates_1","isArray","result","accept","x","i","find","pushR","assertFn","predicateOrMap","errMsg","isFunction","arrayTuples","arrayArgs","min","Math","Array","ignored","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_copyProps","to","from","_extend","toObj","identity","_equals","o1","o2","t1","t2","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","predicates","any","b","fn","a1","a2","t","coreservices_1","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","equals","noop","inherit","extra","args","slice","curry","removeFrom","pushTo","deregAll","functions","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","uniqR","token","unnest","flatten","assertPredicate","assertMap","pairs","sortBy","propFn","checkFn","a","composeSort","sortFns","prev","silenceUncaughtInPromise","promise","catch","e","silentRejection","error","services","reject","isInjectable","head","not","toStr","tis","isUndefined","isDefined","isNull","o","isNullOrUndefined","or","isNumber","isObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","funcs","reverse","fn1","fn2","invoke","pattern","struct","propEq","split","is","eq","other","v","notImplemented","fnname","$injector","Glob","text","glob","regexpString","seg","join","regexp","RegExp","matches","test","fromString","Queue","_items","_limit","enqueue","items","shift","dequeue","size","clear","current","remove","peekTail","peekHead","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","splitOnDelim","delim","re","common_1","joinNeighborsR","rejectFactory_1","transition_1","resolvable_1","stringifyPatternFn","isTransitionRejectionPromise","Rejection","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","RejectType","strings_1","type","message","detail","detailString","d","toPromise","then","superseded","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","errored","ERROR","trace_1","interface_1","transitionHook_1","hookRegistry_1","hookBuilder_1","node_1","pathFactory_1","targetState_1","param_1","resolveContext_1","router_1","stateSelf","fromPath","targetState","router","_deferred","defer","_registeredHooks","isActive","_options","_targetState","valid","$id","transitionService","_transitionCount","toPath","PathFactory","buildToPath","_treeChanges","treeChanges","reloadState","createTransitionHookRegFns","onCreateHooks","hookBuilder","buildHooksForPhase","TransitionHookPhase","CREATE","TransitionHook","runAllHooks","applyViewConfigs","applyRootResolvables","onBefore","criteria","onStart","onExit","onRetain","onEnter","onFinish","onSuccess","onError","_getEvents","hookPhase","makeEvent","getHooks","hookName","enteringStates","entering","state","$view","rootResolvables","params","rootNode","context","ResolveContext","addResolvables","$from","$to","self","compare","matchState","pathname","freeze","injector","pathName","subPath","getResolveTokens","getTokens","addResolvable","resolvable","stateName","topath","targetNode","resolveContext","redirectedFrom","originalTransition","rf","exiting","retained","views","redirect","redirects","trans","redirectOpts","location","newOptions","TargetState","identifier","$state","newTransition","create","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","includes","matchingEnteringNodes","PathNode","matching","resolvables","_changedParams","tc","reload","pathsDiffer","tuple","nodeSchemas","paramSchema","_a","paramValues","toValues","fromValues","tuples","schema","toVals","fromVals","Param","changed","dynamic","changes","HookBuilder","run","globals","transitionHistory","onBeforeHooks","BEFORE","syncResult","runOnBeforeHooks","rejectReason","trace","traceTransitionIgnored","transitionSuccess","traceSuccess","success","resolve","onSuccessHooks","SUCCESS","transitionError","reason","traceError","_error","onErrorHooks","traceTransitionStart","appendHookToChain","nextHook","invokeHook","asyncHooks","ASYNC","abstract","validates","parameters","fromStateOrName","toStateOrName","avoidEmptyHash","fromParams","toValid","toParams","diToken","uiViewString","viewData","creationContext","fqn","normalizedCat","input","Category","viewConfigString","viewConfig","viewDecl","$context","$uiViewName","$uiViewContextAnchor","Trace","_enabled","approximateDigests","_set","enabled","categories","k","parseInt","isNaN","category","enable","disable","TRANSITION","tid","transitionStr","console","log","traceHookInvocation","step","HOOK","event","registeredHook","traceHookResult","hookResult","transitionOptions","hookResultStr","traceResolvePath","when","RESOLVE","pathStr","traceResolvableResolved","resolvableStr","data","finalState","traceUIViewEvent","UIVIEW","traceUIViewConfigUpdated","traceUIViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUIViewEvent","TransitionHookScope","defaultOptions","transition","traceData","stateContext","rejectIfSuperseded","eventType","hook","_deregistered","errorHandler","getErrorHandler","resultHandler","getResultHandler","handleHookResult","isTargetState","hooks","results","hooks_1","chain","HANDLE_RESULT","IGNORE_RESULT","LOG_ERROR","defaultErrorHandler","REJECT_ERROR","THROW_ERROR","_identifier","_definition","_params","exists","base","relative","isDef","criterion","matchGlobs","_state","globStrings","toMatch","glob_1","matchFn","registry","hookRegistrationFn","matchObject","RegisteredHook","tranSvc","matchCriteria","priority","_matchingNodes","nodes","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","paths","mn","pathtype","isStateHook","scope","STATE","allMatched","every","tupleSort","reverseDepthSort","l","r","factor","depthDelta","toState","fromState","$transitions","baseHookOptions","phase","buildHooks","hookType","matchingHooks","getMatchingHooks","makeTransitionHooks","matchingNodes","criteriaMatchPath","transitionHook","sort","reverseSort","isCreate","registries","reg","stateOrPath","res","clone","applyRawParams","getParamVal","paramDef","pDef","parameter","paramValsEq","pathA","pathB","ignoreDynamicParams","changedParams","param","unwrapShorthand","cfg","isShorthand","$$fn","getType","urlType","paramTypes","DefType","CONFIG","PATH","SEARCH","paramType_1","ParamType","getSquashPolicy","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","hasOwn","getArrayMode","arrayDefaults","arrayParamNomenclature","$asArray","raw","defaultSquashPolicy","isDefaultValue","$$getDefaultValue","defaultValue","$replace","replacement","$normalize","isSearch","normalized","encoded","encode","exec","values1","values2","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","$arrayMode","decode","$subPattern","sub","makeTargetState","buildPath","inheritParams","states","viewDecls","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","applyToParams","retainedNode","cloned","keep","staticParams","nodesMatch","node1","node2","retainedWithToParams","elementIdx","defaultResolvePolicy","async","arg1","resolveFn","deps","policy","resolved","literal","getPolicy","thisPolicy","statePolicy","resolvePolicy","getResolvableDependencies","getDependencies","get","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","cache","take","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","fromData","resolvePolicies","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","getResolvable","subContext","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","promises","nodeResolvables","nowait","wait","getResult","_injector","UIInjectorImpl","availableResolvables","getDependency","fromInjector","getNative","native","getAsync","WAIT","NOWAIT","RXWAIT","urlMatcherFactory_1","urlRouter_1","transitionService_1","view_1","stateRegistry_1","stateService_1","globals_1","urlService_1","_routerInstance","locationService","locationConfig","UrlService","locationServiceStub","locationConfigStub","ViewService","TransitionService","Globals","UrlMatcherFactory","urlRouter","UrlRouter","StateRegistry","StateService","_disposables","_plugins","_rootViewContext","$current","disposable","dispose","pluginInstance","getPlugin","pluginName","urlMatcher_1","paramTypes_1","ParamTypes","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strict","caseInsensitive","paramFactory","fromConfig","fromSearch","UrlMatcher","strictMode","compile","isMatcher","object","definition","definitionFn","_flushTypeQueue","quoteRegExp","string","surroundPattern","memoizeTo","_cache","_children","_segments","_compiled","paramMap","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","makeRegexpType","substring","index","lastIndex","search","append","url","isRoot","hash","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","j","validParamVal","getDetails","urlMatchers","pathSegmentsAndParams","queryParams","pathString","encodeDashes","encodeURIComponent","queryString","charCodeAt","toUpperCase","matcher","staticSegments","splitOnSlash","segments","aSegments","bSegments","weight","cmp","weightPair","initDefaultTypes","makeDefaultType","valToString","defaultTypeBase","String","query","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","json","typeQueue","defaultTypes","makeType","types","appendBasePath","isHtml5","absolute","baseHref","defaultRuleSortFn","urlRule_1","getMatcher","URLMATCHER","REGEXP","RAW","OTHER","_sortFn","_rules","interceptDeferred","_id","_router","urlRuleFactory","UrlRuleFactory","_otherwiseFn","compareFn","rules","best","checkRule","rule","matchPriority","evt","defaultPrevented","$url","applyResult","newurl","go","handler","_stopFn","onChange","update","read","urlMatcher","href","html5Mode","hashPrefix","slash","port","protocol","host","isUrlRule","removeRule","otherwise","handlerFn","deferIntercept","stateObject_1","what","makeRule","_what","fromUrlMatcher","State","fromRegExp","BaseUrlRule","optional","matched","_handler","details","transitionTo","global","sticky","redirectUrlTo","Number","matchingKeys","inherited","resolve_1","views_1","url_1","redirectTo_1","onEnterExitRetain_1","lazyLoad_1","transitionEventType_1","defaultTransOpts","notify","custom","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineDefaultPaths","_defineDefaultEvents","_registerDefaultTransitionHooks","onCreate","hooksArray","Phase","TH","_defineEvent","_definePathType","hookOrder","TransitionEventType","transitionHookTypes","cmpByPhase","hookScope","fns","redirectTo","registerRedirectToHook","registerOnExitHook","registerOnRetainHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","loadViews","registerLoadEnteringViews","activateViews","registerActivateViews","updateUrl","registerUpdateUrl","lazyLoad","registerLazyLoadHook","eagerResolvePath","lazyResolveState","loadEnteringViews","enteringViews","load","exitingViews","vc","deactivateViewConfig","activateViewConfig","$urlRouter","navigable","urlOptions","redirectToHook","handleResult","makeEnterExitRetainHook","hookFn","onExitHook","onRetainHook","onEnterHook","lazyLoadState","updateStateRegistry","lazyLoadFn","$$state","err","lazyLoadHook","retryTransition","orig","parts","_uiViews","_viewConfigs","_viewConfigFactories","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","decl","cfgFactory","$type","cfgs","uiViewDepth","viewConfigDepth","count","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","configUpdated","registerUIView","uiViews","fqnMatches","available","active","normalizeUIViewTarget","rawViewName","viewAtContext","uiViewName","uiViewContextAnchor","relativeViewNameSugar","charAt","relativeMatch","anchor","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","stateMatcher_1","stateBuilder_1","stateQueueManager_1","listeners","StateMatcher","builder","StateBuilder","stateQueue","StateQueueManager","_registerRoot","rootStateDef","#","_root","deregister","onStatesChanged","listener","stateDefinition","_deregisterTree","s","getChildren","children","deregistered","$ur","stateOrName","deregisteredStates","found","func","_states","isRelative","isStr","baseState","splitName","pathLength","relName","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","objects2Tuples","resolveObj","annotate","strictDi","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","parseUrl","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","parsed","paramConfig","reloadOnSearch","getNavigableBuilder","getParamsBuilder","makeConfigParam","urlParams","nonUrlParams","parentBuilder","parentName","builders","build","parentFn","lastSegment","pop","$registry","queue","flush","registered","orphans","previousQueueLength","orphanIdx","existingState","attachRoute","queue_1","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","defineProperty","enumerable","configurable","_handleInvalidTargetState","invokeNextCallback","nextCallback","callbackQueue","callbackResult","checkForRedirect","latestThing","latest","onInvalid","defautGoOpts","transOpts","getCurrentPath","latestSuccess","successfulTransitions","rootPath","transHistory","currentPath","rejectedTransitionHandler","transitionToPromise","include","defaultHrefOpts","lossy","$inherit","nav","stateParams_1","StateParams","beforeNewTransition","$transition$","updateGlobalState","clearCurrentTransition","newParams","parentParams","parents","inheritList","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","lateBind","locationServices","umf","urlParts","UIRouterPluginBase","hasAnyKey","viewConfigId","viewsObject","$default","each","resolveAs","$name","index_1","Promise","deferred","wait4","STRIP_COMMENTS","ARGUMENT_NAMES","has","locals","ensureExist","$inject","utils_1","BaseLocationServices","fireAfterUpdate","_listener","_listeners","_get","getParams","_location","_history","history","evt_1","Event","buildUrl","orEmptyString","splitHash","beforehash","_b","splitQuery","locationPluginFactory","serviceClass","configurationClass","service","configuration","splitEqual","trimHashVal","keyValsToObjectR","accum","loc","searchObject","vals","__extends","__","baseLocationService_1","HashLocationService","_super","addEventListener","title","removeEventListener","MemoryLocationService","_url","PushStateLocationService","_config","fullUrl","replaceState","pushState","MemoryLocationConfig","_baseHref","_port","_protocol","_host","_hashPrefix","newval","BrowserLocationConfig","_isHtml5","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","_injector_1","_q_1","browserLocationConfig_1","hashLocationService_1","pushStateLocationService_1","memoryLocationService_1","memoryLocationConfig_1","pushStateLocationPlugin","memoryLocationPlugin","Mn","initialize","mnLayout","mnRegion","mnRegionName","parentContext","parentFqn","ref3","ref4","ref5","ref6","listenTo","destroy","activeUIView","onConfigUpdated","newConfig","clearPreviousConfig","updateView","controller","getResolved","getView","getController","show","listenToOnce","len","viewOptions","controllerOptions","empty","triggerMethod","onBeforeDestroy","ui","sref","events","click @ui.ref","onClickLink","onAttach","$","attr","Behavior","activeClasses","onStateChange","onRender","el","$el","classFn","compareState","removeListeners","off","on","onAttachUI","onBeforeDestroyUI","regions","me","parentRegion","region","regionName","LayoutView"],"mappings":"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","file":"ui-router-marionette.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, Router, UILayoutMn2, UISref, UISrefActive, UIViewMarionette, _, ref, ref1;\n\t\n\t_ = __webpack_require__(2);\n\t\n\tref = __webpack_require__(3), $q = ref.$q, UIViewMarionette = ref.UIViewMarionette, Router = ref.Router;\n\t\n\tref1 = __webpack_require__(75), UISref = ref1.UISref, UISrefActive = ref1.UISrefActive;\n\t\n\tUILayoutMn2 = __webpack_require__(76);\n\t\n\t_.extend(exports, {\n\t  Router: Router,\n\t  UISref: UISref,\n\t  UISrefActive: UISrefActive,\n\t  UILayoutMn2: UILayoutMn2,\n\t  UIViewMarionette: UIViewMarionette,\n\t  $q: $q\n\t});\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, MnViewConfig, UIRouter, UIRouterMarionette, UIViewMarionette, hashLocationPlugin, mnViewsBuilder, ref, ref1, ref2, routerInstance, servicesPlugin, viewConfigFactory,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tref = __webpack_require__(4), UIRouter = ref.UIRouter, $q = ref.$q;\n\t\n\tref1 = __webpack_require__(60), mnViewsBuilder = ref1.mnViewsBuilder, MnViewConfig = ref1.MnViewConfig;\n\t\n\tref2 = __webpack_require__(61), hashLocationPlugin = ref2.hashLocationPlugin, servicesPlugin = ref2.servicesPlugin;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\trouterInstance = null;\n\t\n\tviewConfigFactory = function(node, config) {\n\t  return new MnViewConfig(node, config);\n\t};\n\t\n\tUIRouterMarionette = (function(superClass) {\n\t  extend(UIRouterMarionette, superClass);\n\t\n\t  UIRouterMarionette.getInstance = function() {\n\t    return routerInstance || (routerInstance = new this);\n\t  };\n\t\n\t  function UIRouterMarionette() {\n\t    UIRouterMarionette.__super__.constructor.apply(this, arguments);\n\t    this._started = false;\n\t    this.viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory);\n\t    this.plugin(servicesPlugin);\n\t    this.plugin(hashLocationPlugin);\n\t    this.stateRegistry.decorator(\"views\", mnViewsBuilder);\n\t    routerInstance = this;\n\t  }\n\t\n\t  UIRouterMarionette.prototype.addState = function(def) {\n\t    this.stateRegistry.register(def);\n\t    return this;\n\t  };\n\t\n\t  UIRouterMarionette.prototype.start = function(rootRegion, options) {\n\t    this.rootRegion = rootRegion;\n\t    if (this._started) {\n\t      throw new Error(\"Router was already started\");\n\t    }\n\t    if (options != null) {\n\t      this.handleOptions(options);\n\t    }\n\t    this.rootRegion.uiView = new UIViewMarionette(this, null, this.rootRegion, \"\");\n\t    this.rootRegion.uiView.register();\n\t    this.urlMatcherFactory.$get();\n\t    this.urlService.listen();\n\t    this.urlService.sync();\n\t    this._started = true;\n\t    return this;\n\t  };\n\t\n\t  UIRouterMarionette.prototype.handleOptions = function(options) {\n\t    if (typeof options.onMnRoute === 'function') {\n\t      return this.onMnRoute(options.onMnRoute);\n\t    }\n\t  };\n\t\n\t  UIRouterMarionette.prototype.onMnRoute = function(onRoute) {\n\t    var oldProcessOnRoute, uiRouter;\n\t    oldProcessOnRoute = Marionette.AppRouter.prototype._processOnRoute;\n\t    uiRouter = this;\n\t    return Marionette.AppRouter.prototype._processOnRoute = function(mnRouteName, mnRouteArgs) {\n\t      var mnRoutePath;\n\t      mnRoutePath = _.invert(this.getOption('appRoutes'))[mnRouteName];\n\t      onRoute.call(this, mnRouteName, mnRouteArgs, mnRoutePath, uiRouter.stateService);\n\t      return oldProcessOnRoute.call(this, mnRouteName, mnRouteArgs);\n\t    };\n\t  };\n\t\n\t  return UIRouterMarionette;\n\t\n\t})(UIRouter);\n\t\n\texports.UIViewMarionette = UIViewMarionette;\n\t\n\texports.Router = UIRouterMarionette;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module common\n\t */ /** */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(52));\n\t__export(__webpack_require__(53));\n\t__export(__webpack_require__(54));\n\t__export(__webpack_require__(55));\n\t__export(__webpack_require__(56));\n\t__export(__webpack_require__(57));\n\t__export(__webpack_require__(58));\n\t__export(__webpack_require__(49));\n\t__export(__webpack_require__(28));\n\t__export(__webpack_require__(59));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module common */ /** for typedoc */\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(12));\n\t__export(__webpack_require__(15));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * These functions are exported, but are subject to change without notice.\n\t *\n\t * @preferred\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\texports.copy = angular.copy || _copy;\n\texports.forEach = angular.forEach || _forEach;\n\texports.extend = angular.extend || _extend;\n\texports.equals = angular.equals || _equals;\n\texports.identity = function (x) { return x; };\n\texports.noop = function () { return undefined; };\n\t/**\n\t * Builds proxy functions on the `to` object which pass through to the `from` object.\n\t *\n\t * For each key in `fnNames`, creates a proxy function on the `to` object.\n\t * The proxy function calls the real function on the `from` object.\n\t *\n\t *\n\t * #### Example:\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * ```js\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * #### Example:\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param source A function that returns the source object which contains the original functions to be bound\n\t * @param target A function that returns the target object which will receive the bound functions\n\t * @param bind A function that returns the object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n\t */\n\tfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n\t    if (latebind === void 0) { latebind = false; }\n\t    var bindFunction = function (fnName) {\n\t        return source()[fnName].bind(bind());\n\t    };\n\t    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n\t        target[fnName] = bindFunction(fnName);\n\t        return target[fnName].apply(null, arguments);\n\t    }; };\n\t    fnNames = fnNames || Object.keys(source());\n\t    return fnNames.reduce(function (acc, name) {\n\t        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n\t        return acc;\n\t    }, target);\n\t}\n\texports.createProxyFunctions = createProxyFunctions;\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\texports.inherit = function (parent, extra) {\n\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t};\n\t/**\n\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t * This is similar to es6 rest parameters.\n\t *\n\t * Optionally, the argument at index idx may itself already be an array.\n\t *\n\t * For example,\n\t * given either:\n\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t * or:\n\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t * then:\n\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t *\n\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t *\n\t * given:\n\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t * then:\n\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t */\n\tvar restArgs = function (args, idx) {\n\t    if (idx === void 0) { idx = 0; }\n\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\texports.inArray = hof_1.curry(_inArray);\n\tfunction _inArray(array, obj) {\n\t    return array.indexOf(obj) !== -1;\n\t}\n\texports._inArray = _inArray;\n\t/**\n\t * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n\t * The same array is returned\n\t */\n\texports.removeFrom = hof_1.curry(_removeFrom);\n\tfunction _removeFrom(array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t}\n\texports._removeFrom = _removeFrom;\n\t/** pushes a values to an array and returns the value */\n\texports.pushTo = hof_1.curry(_pushTo);\n\tfunction _pushTo(arr, val) {\n\t    return (arr.push(val), val);\n\t}\n\texports._pushTo = _pushTo;\n\t/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\n\texports.deregAll = function (functions) {\n\t    return functions.slice().forEach(function (fn) {\n\t        typeof fn === 'function' && fn();\n\t        exports.removeFrom(functions, fn);\n\t    });\n\t};\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    if (opts === void 0) { opts = {}; }\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t}\n\texports.defaults = defaults;\n\t/**\n\t * Merges properties from the list of objects to the destination object.\n\t * If a property already exists in the destination object, then it is not overwritten.\n\t */\n\tfunction merge(dst) {\n\t    var objs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        objs[_i - 1] = arguments[_i];\n\t    }\n\t    exports.forEach(objs, function (obj) {\n\t        exports.forEach(obj, function (value, key) {\n\t            if (!dst.hasOwnProperty(key))\n\t                dst[key] = value;\n\t        });\n\t    });\n\t    return dst;\n\t}\n\texports.merge = merge;\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\texports.ancestors = ancestors;\n\tfunction pickOmitImpl(predicate, obj) {\n\t    var keys = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        keys[_i - 2] = arguments[_i];\n\t    }\n\t    var objCopy = {};\n\t    for (var key in obj) {\n\t        if (predicate(keys, key))\n\t            objCopy[key] = obj[key];\n\t    }\n\t    return objCopy;\n\t}\n\t/** Return a copy of the object only containing the whitelisted properties. */\n\tfunction pick(obj) {\n\t    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n\t}\n\texports.pick = pick;\n\t/** Return a copy of the object omitting the blacklisted properties. */\n\tfunction omit(obj) {\n\t    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n\t    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n\t}\n\texports.omit = omit;\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, hof_1.prop(propName));\n\t}\n\texports.pluck = pluck;\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    exports.forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\texports.filter = filter;\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    exports.forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\texports.find = find;\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\texports.mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\texports.map = map;\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\texports.values = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return obj[key]; });\n\t};\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flattenR = function (memo, elem) {\n\t    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n\t};\n\t/**\n\t * Reduce function that pushes an object to an array, then returns the array.\n\t * Mostly just for [[flattenR]] and [[uniqR]]\n\t */\n\tfunction pushR(arr, obj) {\n\t    arr.push(obj);\n\t    return arr;\n\t}\n\texports.pushR = pushR;\n\t/** Reduce function that filters out duplicates */\n\texports.uniqR = function (acc, token) {\n\t    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n\t};\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\texports.assertPredicate = assertFn;\n\t/**\n\t * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n\t * @example\n\t * ```\n\t *\n\t * var data = { foo: 1, bar: 2 };\n\t *\n\t * let keys = [ 'foo', 'bar' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // values is [1, 2]\n\t *\n\t * let keys = [ 'foo', 'bar', 'baz' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // throws Error(\"Key not found\")\n\t * ```\n\t */\n\texports.assertMap = assertFn;\n\tfunction assertFn(predicateOrMap, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        var result = predicateOrMap(obj);\n\t        if (!result) {\n\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.assertFn = assertFn;\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\texports.pairs = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n\t};\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var arrayArgs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        arrayArgs[_i] = arguments[_i];\n\t    }\n\t    if (arrayArgs.length === 0)\n\t        return [];\n\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t}\n\texports.arrayTuples = arrayTuples;\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (predicates_1.isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!predicates_1.isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\texports.applyPairs = applyPairs;\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\texports.tail = tail;\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return exports.extend(dest, src);\n\t}\n\t/** Naive forEach implementation works with Objects or Arrays */\n\tfunction _forEach(obj, cb, _this) {\n\t    if (predicates_1.isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _copyProps(to, from) {\n\t    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n\t    return to;\n\t}\n\tfunction _extend(toObj) {\n\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t/**\n\t * Create a sort function\n\t *\n\t * Creates a sort function which sorts by a numeric property.\n\t *\n\t * The `propFn` should return the property as a number which can be sorted.\n\t *\n\t * #### Example:\n\t * This example returns the `priority` prop.\n\t * ```js\n\t * var sortfn = sortBy(obj => obj.priority)\n\t * // equivalent to:\n\t * var longhandSortFn = (a, b) => a.priority - b.priority;\n\t * ```\n\t *\n\t * #### Example:\n\t * This example uses [[prop]]\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'))\n\t * ```\n\t *\n\t * The `checkFn` can be used to exclude objects from sorting.\n\t *\n\t * #### Example:\n\t * This example only sorts objects with type === 'FOO'\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n\t * ```\n\t *\n\t * @param propFn a function that returns the property (as a number)\n\t * @param checkFn a predicate\n\t *\n\t * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n\t */\n\texports.sortBy = function (propFn, checkFn) {\n\t    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n\t    return function (a, b) {\n\t        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n\t    };\n\t};\n\t/**\n\t * Composes a list of sort functions\n\t *\n\t * Creates a sort function composed of multiple sort functions.\n\t * Each sort function is invoked in series.\n\t * The first sort function to return non-zero \"wins\".\n\t *\n\t * @param sortFns list of sort functions\n\t */\n\texports.composeSort = function () {\n\t    var sortFns = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sortFns[_i] = arguments[_i];\n\t    }\n\t    return function (a, b) {\n\t        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n\t    };\n\t};\n\t// issue #2676\n\texports.silenceUncaughtInPromise = function (promise) {\n\t    return promise.catch(function (e) { return 0; }) && promise;\n\t};\n\texports.silentRejection = function (error) {\n\t    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n\t};\n\t//# sourceMappingURL=common.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** Predicates\n\t *\n\t * These predicates return true/false based on the input.\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_predicates\n\t */ /** */\n\tvar hof_1 = __webpack_require__(8);\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\texports.isUndefined = tis('undefined');\n\texports.isDefined = hof_1.not(exports.isUndefined);\n\texports.isNull = function (o) { return o === null; };\n\texports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\n\texports.isFunction = tis('function');\n\texports.isNumber = tis('number');\n\texports.isString = tis('string');\n\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\texports.isArray = Array.isArray;\n\texports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\n\texports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val) {\n\t    if (exports.isArray(val) && val.length) {\n\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t    }\n\t    return exports.isFunction(val);\n\t}\n\texports.isInjectable = isInjectable;\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\t//# sourceMappingURL=predicates.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Higher order functions\n\t *\n\t * These utility functions are exported, but are subject to change without notice.\n\t *\n\t * @module common_hof\n\t */ /** */\n\t\"use strict\";\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\texports.curry = curry;\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\texports.compose = compose;\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\texports.pipe = pipe;\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\texports.prop = function (name) {\n\t    return function (obj) { return obj && obj[name]; };\n\t};\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\texports.parse = function (name) {\n\t    return pipe.apply(null, name.split(\".\").map(exports.prop));\n\t};\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\texports.not = function (fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return !fn.apply(null, args);\n\t    };\n\t};\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\texports.and = and;\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\texports.or = or;\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\texports.all = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n\t};\n\texports.any = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n\t};\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\texports.is = function (ctor) {\n\t    return function (obj) {\n\t        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n\t    };\n\t};\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\texports.eq = function (val) { return function (other) {\n\t    return val === other;\n\t}; };\n\t/** Given a value, returns a function which returns the value */\n\texports.val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) {\n\t        return obj[fnName].apply(obj, args);\n\t    };\n\t}\n\texports.invoke = invoke;\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\texports.pattern = pattern;\n\t//# sourceMappingURL=hof.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t};\n\texports.services = services;\n\t//# sourceMappingURL=coreservices.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */\n\t/**\n\t * Matches state names using glob-like pattern strings.\n\t *\n\t * Globs can be used in specific APIs including:\n\t *\n\t * - [[StateService.is]]\n\t * - [[StateService.includes]]\n\t * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n\t *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n\t *\n\t * A `Glob` string is a pattern which matches state names.\n\t * Nested state names are split into segments (separated by a dot) when processing.\n\t * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n\t *\n\t * Globs work according to the following rules:\n\t *\n\t * ### Exact match:\n\t *\n\t * The glob `'A.B'` matches the state named exactly `'A.B'`.\n\t *\n\t * | Glob        |Matches states named|Does not match state named|\n\t * |:------------|:--------------------|:---------------------|\n\t * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n\t * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n\t * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n\t *\n\t * ### Single star (`*`)\n\t *\n\t * A single star (`*`) is a wildcard that matches exactly one segment.\n\t *\n\t * | Glob        |Matches states named  |Does not match state named |\n\t * |:------------|:---------------------|:--------------------------|\n\t * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n\t * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n\t * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n\t *\n\t * ### Double star (`**`)\n\t *\n\t * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n\t *\n\t * | Glob        |Matches states named                           |Does not match state named         |\n\t * |:------------|:----------------------------------------------|:----------------------------------|\n\t * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n\t * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n\t * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n\t * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n\t *\n\t */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t        var regexpString = this.text.split('.')\n\t            .map(function (seg) {\n\t            if (seg === '**')\n\t                return '(?:|(?:\\\\.[^.]*)*)';\n\t            if (seg === '*')\n\t                return '\\\\.[^.]*';\n\t            return '\\\\.' + seg;\n\t        }).join('');\n\t        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        return this.regexp.test('.' + name);\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.is = function (text) {\n\t        return text.indexOf('*') > -1;\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.fromString = function (text) {\n\t        if (!this.is(text))\n\t            return null;\n\t        return new Glob(text);\n\t    };\n\t    return Glob;\n\t}());\n\texports.Glob = Glob;\n\t//# sourceMappingURL=glob.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\texports.Queue = Queue;\n\t//# sourceMappingURL=queue.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Functions that manipulate strings\n\t *\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_strings\n\t */ /** */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar transition_1 = __webpack_require__(14);\n\tvar resolvable_1 = __webpack_require__(25);\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\texports.maxLength = maxLength;\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\texports.padString = padString;\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\texports.kebobString = kebobString;\n\tfunction _toJson(obj) {\n\t    return JSON.stringify(obj);\n\t}\n\tfunction _fromJson(json) {\n\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t}\n\tfunction promiseToString(p) {\n\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t    var fnName = fn['name'] || \"\";\n\t    if (fnName && toStr.match(/function \\(/)) {\n\t        return 'function ' + fnName + toStr.substr(9);\n\t    }\n\t    return toStr;\n\t}\n\texports.functionToString = functionToString;\n\tfunction fnToString(fn) {\n\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\texports.fnToString = fnToString;\n\tvar stringifyPatternFn = null;\n\tvar stringifyPattern = function (value) {\n\t    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\t    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n\t        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t        [predicates_1.isNull, hof_1.val(\"null\")],\n\t        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n\t        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t        [predicates_1.isInjectable, functionToString],\n\t        [hof_1.val(true), common_1.identity]\n\t    ]);\n\t    return stringifyPatternFn(value);\n\t};\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val) {\n\t        if (predicates_1.isObject(val)) {\n\t            if (seen.indexOf(val) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val);\n\t        }\n\t        return stringifyPattern(val);\n\t    }\n\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t}\n\texports.stringify = stringify;\n\t/** Returns a function that splits a string on a character or substring */\n\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\t/**\n\t * Splits on a delimiter, but returns the delimiters in the array\n\t *\n\t * #### Example:\n\t * ```js\n\t * var splitOnSlashes = splitOnDelim('/');\n\t * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n\t * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n\t * ```\n\t */\n\tfunction splitOnDelim(delim) {\n\t    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n\t    return function (str) {\n\t        return str.split(re).filter(common_1.identity);\n\t    };\n\t}\n\texports.splitOnDelim = splitOnDelim;\n\t;\n\t/**\n\t * Reduce fn that joins neighboring strings\n\t *\n\t * Given an array of strings, returns a new array\n\t * where all neighboring strings have been joined.\n\t *\n\t * #### Example:\n\t * ```js\n\t * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n\t * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n\t * ```\n\t */\n\tfunction joinNeighborsR(acc, x) {\n\t    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n\t        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n\t    return common_1.pushR(acc, x);\n\t}\n\texports.joinNeighborsR = joinNeighborsR;\n\t;\n\t//# sourceMappingURL=strings.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar RejectType;\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n\t})(RejectType = exports.RejectType || (exports.RejectType = {}));\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) {\n\t            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n\t        };\n\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition\";\n\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a TransitionRejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid\";\n\t        return new Rejection(RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored\";\n\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition has been aborted\";\n\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.errored = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition errored\";\n\t        return new Rejection(RejectType.ERROR, message, detail);\n\t    };\n\t    return Rejection;\n\t}());\n\texports.Rejection = Rejection;\n\t//# sourceMappingURL=rejectFactory.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar hookBuilder_1 = __webpack_require__(20);\n\tvar node_1 = __webpack_require__(21);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar router_1 = __webpack_require__(28);\n\t/** @hidden */\n\tvar stateSelf = hof_1.prop(\"self\");\n\t/**\n\t * Represents a transition between two states.\n\t *\n\t * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n\t *\n\t * This object contains all contextual information about the to/from states, parameters, resolves.\n\t * It has information about all states being entered and exited as a result of the transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param router The [[UIRouter]] instance\n\t     */\n\t    function Transition(fromPath, targetState, router) {\n\t        var _this = this;\n\t        /** @hidden */\n\t        this._deferred = coreservices_1.services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\t        this._registeredHooks = {};\n\t        /**\n\t         * Checks if this transition is currently active/running.\n\t         */\n\t        this.isActive = function () { return _this === _this._options.current(); };\n\t        this.router = router;\n\t        this._targetState = targetState;\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t        this.$id = router.transitionService._transitionCount++;\n\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        this.createTransitionHookRegFns();\n\t        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n\t        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n\t        this.applyViewConfigs(router);\n\t        this.applyRootResolvables(router);\n\t    }\n\t    /** @hidden */\n\t    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onError = function (criteria, callback, options) { return; };\n\t    /** @hidden\n\t     * Creates the transition-level hook registration functions\n\t     * (which can then be used to register hooks)\n\t     */\n\t    Transition.prototype.createTransitionHookRegFns = function () {\n\t        var _this = this;\n\t        this.router.transitionService._pluginapi._getEvents()\n\t            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n\t            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n\t    };\n\t    /** @internalapi */\n\t    Transition.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    Transition.prototype.applyViewConfigs = function (router) {\n\t        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n\t        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n\t    };\n\t    Transition.prototype.applyRootResolvables = function (router) {\n\t        var _this = this;\n\t        var rootResolvables = [\n\t            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n\t            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n\t        ];\n\t        var rootNode = this._treeChanges.to[0];\n\t        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n\t        context.addResolvables(rootResolvables, rootNode.state);\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal from [State] object\n\t     */\n\t    Transition.prototype.$from = function () {\n\t        return common_1.tail(this._treeChanges.from).state;\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal to [State] object\n\t     */\n\t    Transition.prototype.$to = function () {\n\t        return common_1.tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * Returns the state that the transition is coming *from*.\n\t     *\n\t     * @returns The state declaration object for the Transition's (\"from state\").\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * Returns the state that the transition is going *to*.\n\t     *\n\t     * @returns The state declaration object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Gets the Target State\n\t     *\n\t     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n\t     *\n\t     * @returns the [[TargetState]] of this Transition\n\t     */\n\t    Transition.prototype.targetState = function () {\n\t        return this._targetState;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n\t    };\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    /**\n\t     * Creates a [[UIInjector]] Dependency Injector\n\t     *\n\t     * Returns a Dependency Injector for the Transition's target state (to state).\n\t     * The injector provides resolve values which the target state has access to.\n\t     *\n\t     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ entering: 'myState' }, trans => {\n\t     *   var myResolveValue = trans.injector().get('myResolve');\n\t     *   // Inject a global service from the global/native injector (if it exists)\n\t     *   var MyService = trans.injector().get('MyService');\n\t     * })\n\t     * ```\n\t     *\n\t     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n\t     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n\t     * #### Example:\n\t     * ```js\n\t     * .onBefore({}, trans => {\n\t     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n\t     *     return myResolveValue !== 'ABORT';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n\t     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ to: 'foo.bar' }, trans => {\n\t     *   // returns result of `foo` state's `data` resolve\n\t     *   // even though `foo.bar` also has a `data` resolve\n\t     *   var fooData = trans.injector('foo').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n\t     * The resolve data from the `from` path will be returned.\n\t     * #### Example:\n\t     * ```js\n\t     * .onExit({ exiting: 'foo.bar' }, trans => {\n\t     *   // Gets the resolve value of `data` from the exiting state.\n\t     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n\t     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n\t     *\n\t     * @returns a [[UIInjector]]\n\t     */\n\t    Transition.prototype.injector = function (state, pathName) {\n\t        if (pathName === void 0) { pathName = \"to\"; }\n\t        var path = this._treeChanges[pathName];\n\t        if (state)\n\t            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n\t        return new resolveContext_1.ResolveContext(path).injector();\n\t    };\n\t    /**\n\t     * Gets all available resolve tokens (keys)\n\t     *\n\t     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n\t     * available to the Transition.\n\t     *\n\t     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n\t     * in the Transition's [[TreeChanges.to]] path.\n\t     *\n\t     * #### Example:\n\t     * This example logs all resolve values\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n\t     * ```\n\t     *\n\t     * #### Example:\n\t     * This example creates promises for each resolve value.\n\t     * This triggers fetches of resolves (if any have not yet been fetched).\n\t     * When all promises have all settled, it logs the resolve values.\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * let promise = tokens.map(token => trans.injector().getAsync(token));\n\t     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n\t     * ```\n\t     *\n\t     * Note: Angular 1 users whould use `$q.all()`\n\t     *\n\t     * @param pathname resolve context's path name (e.g., `to` or `from`)\n\t     *\n\t     * @returns an array of resolve tokens (keys)\n\t     */\n\t    Transition.prototype.getResolveTokens = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n\t    };\n\t    /**\n\t     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * transitionService.onBefore({}, transition => {\n\t     *   transition.addResolvable({\n\t     *     token: 'myResolve',\n\t     *     deps: ['MyService'],\n\t     *     resolveFn: myService => myService.getData()\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n\t     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolvable = function (resolvable, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t        var resolveContext = new resolveContext_1.ResolveContext(topath);\n\t        resolveContext.addResolvables([resolvable], targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the transition from which this transition was redirected.\n\t     *\n\t     * If the current transition is a redirect, this method returns the transition that was redirected.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let transitionA = $state.go('A').transition\n\t     * transitionA.onStart({}, () => $state.target('B'));\n\t     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n\t     *   trans.to().name === 'B'; // true\n\t     *   trans.redirectedFrom() === transitionA; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.redirectedFrom = function () {\n\t        return this._options.redirectedFrom || null;\n\t    };\n\t    /**\n\t     * Gets the original transition in a redirect chain\n\t     *\n\t     * A transition might belong to a long chain of multiple redirects.\n\t     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * // states\n\t     * registry.register({ name: 'A', redirectTo: 'B' });\n\t     * registry.register({ name: 'B', redirectTo: 'C' });\n\t     * registry.register({ name: 'C', redirectTo: 'D' });\n\t     * registry.register({ name: 'D' });\n\t     *\n\t     * let transitionA = $state.go('A').transition\n\t     *\n\t     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n\t     *   trans.to().name === 'D'; // true\n\t     *   trans.redirectedFrom().to().name === 'C'; // true\n\t     *   trans.originalTransition() === transitionA; // true\n\t     *   trans.originalTransition().to().name === 'A'; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The original Transition that started a redirect chain\n\t     */\n\t    Transition.prototype.originalTransition = function () {\n\t        var rf = this.redirectedFrom();\n\t        return (rf && rf.originalTransition()) || this;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t    };\n\t    Transition.prototype.treeChanges = function (pathname) {\n\t        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n\t    };\n\t    /**\n\t     * Creates a new transition that is a redirection of the current one.\n\t     *\n\t     * This transition can be returned from a [[TransitionService]] hook to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns Returns a new [[Transition]] instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var redirects = 1, trans = this;\n\t        while ((trans = trans.redirectedFrom()) != null) {\n\t            if (++redirects > 20)\n\t                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n\t        }\n\t        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n\t        // If the original transition was caused by URL sync, then use { location: 'replace' }\n\t        // on the new transition (unless  the target state explicitly specifies location)\n\t        if (this.options().source === 'url') {\n\t            redirectOpts.location = 'replace';\n\t        }\n\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n\t        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n\t        var originalEnteringNodes = this._treeChanges.entering;\n\t        var redirectEnteringNodes = newTransition._treeChanges.entering;\n\t        // --- Re-use resolve data from original transition ---\n\t        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n\t        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n\t        // redirected transition.\n\t        //\n\t        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n\t        // You can wait for the resolve, then redirect to a child state based on the result.\n\t        // The redirected transition does not have to re-fetch the resolve.\n\t        // ---------------------------------------------------------\n\t        var nodeIsReloading = function (reloadState) { return function (node) {\n\t            return reloadState && node.state.includes[reloadState.name];\n\t        }; };\n\t        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\t        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n\t            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n\t        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\t        matchingEnteringNodes.forEach(function (node, idx) {\n\t            node.resolvables = originalEnteringNodes[idx].resolvables;\n\t        });\n\t        return newTransition;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var tc = this._treeChanges;\n\t        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n\t        // If user explicitly wants a reload\n\t        if (this._options.reload)\n\t            return undefined;\n\t        // If any states are exiting or entering\n\t        if (tc.exiting.length || tc.entering.length)\n\t            return undefined;\n\t        // If to/from path lengths differ\n\t        if (tc.to.length !== tc.from.length)\n\t            return undefined;\n\t        // If the to/from paths are different\n\t        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n\t            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n\t            .reduce(common_1.anyTrueR, false);\n\t        if (pathsDiffer)\n\t            return undefined;\n\t        // Find any parameter values that differ\n\t        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n\t        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return param_1.Param.changed(schema, toVals, fromVals);\n\t        }).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.length === 0;\n\t    };\n\t    /**\n\t     * @hidden\n\t     */\n\t    Transition.prototype.hookBuilder = function () {\n\t        return new hookBuilder_1.HookBuilder(this);\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n\t        var hookBuilder = this.hookBuilder();\n\t        var globals = this.router.globals;\n\t        globals.transitionHistory.enqueue(this);\n\t        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n\t        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t            var rejectReason = syncResult._transitionRejection;\n\t            this._deferred.reject(rejectReason);\n\t            return this.promise;\n\t        }\n\t        if (!this.valid()) {\n\t            var error = new Error(this.error());\n\t            this._deferred.reject(error);\n\t            return this.promise;\n\t        }\n\t        if (this.ignored()) {\n\t            trace_1.trace.traceTransitionIgnored(this);\n\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t            return this.promise;\n\t        }\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var transitionSuccess = function () {\n\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this.to());\n\t            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n\t            runAllHooks(onSuccessHooks);\n\t        };\n\t        var transitionError = function (reason) {\n\t            trace_1.trace.traceError(reason, _this);\n\t            _this.success = false;\n\t            _this._deferred.reject(reason);\n\t            _this._error = reason;\n\t            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n\t            runAllHooks(onErrorHooks);\n\t        };\n\t        trace_1.trace.traceTransitionStart(this);\n\t        // Chain the next hook off the previous\n\t        var appendHookToChain = function (prev, nextHook) {\n\t            return prev.then(function () { return nextHook.invokeHook(); });\n\t        };\n\t        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n\t        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n\t        asyncHooks.reduce(appendHookToChain, syncResult)\n\t            .then(transitionSuccess, transitionError);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error() || this.success !== undefined;\n\t    };\n\t    /**\n\t     * The Transition error reason.\n\t     *\n\t     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n\t     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n\t     *\n\t     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self.abstract)\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        if (!param_1.Param.validates(state.parameters(), this.params()))\n\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t        if (this.success === false)\n\t            return this._error;\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    return Transition;\n\t}());\n\t/** @hidden */\n\tTransition.diToken = Transition;\n\texports.Transition = Transition;\n\t//# sourceMappingURL=transition.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * # Transition tracing (debug)\n\t *\n\t * Enable transition tracing to print transition information to the console,\n\t * in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n\t *\n\t * ### ES6\n\t * ```js\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * ### CJS\n\t * ```js\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * ### Globals\n\t * ```js\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * ### Angular 1:\n\t * ```js\n\t * app.run($trace => $trace.enable());\n\t * ```\n\t *\n\t * @coreapi\n\t * @module trace\n\t */ /** for typedoc */\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction uiViewString(viewData) {\n\t    if (!viewData)\n\t        return 'ui-view (defunct)';\n\t    return \"[ui-view#\" + viewData.id + \" tag \" +\n\t        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n\t        (\"fqn: '\" + viewData.fqn + \"', \") +\n\t        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t}\n\t/**\n\t * Trace categories Enum\n\t *\n\t * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\tvar Category;\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n\t})(Category = exports.Category || (exports.Category = {}));\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    /** @hidden */\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(Category)\n\t                .map(function (k) { return parseInt(k, 10); })\n\t                .filter(function (k) { return !isNaN(k); })\n\t                .map(function (key) { return Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    /**\n\t     * Enables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enable(\"TRANSITION\");\n\t     * ```\n\t     *\n\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    /**\n\t     * Disables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.disable(\"VIEWCONFIG\");\n\t     * ```\n\t     *\n\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, when, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceError = function (reason, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewFill = function (viewData, html) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\texports.Trace = Trace;\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * #### Example:\n\t * ```js\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\texports.trace = trace;\n\t//# sourceMappingURL=trace.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar TransitionHookPhase;\n\t(function (TransitionHookPhase) {\n\t    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n\t    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n\t})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\tvar TransitionHookScope;\n\t(function (TransitionHookScope) {\n\t    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n\t    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n\t})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar defaultOptions = {\n\t    current: common_1.noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null\n\t};\n\t/** @hidden */\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(transition, stateContext, registeredHook, options) {\n\t        var _this = this;\n\t        this.transition = transition;\n\t        this.stateContext = stateContext;\n\t        this.registeredHook = registeredHook;\n\t        this.options = options;\n\t        this.stateService = function () { return _this.transition.router.stateService; };\n\t        this.rejectIfSuperseded = function () {\n\t            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n\t        };\n\t        this.options = common_1.defaults(options, defaultOptions);\n\t    }\n\t    TransitionHook.prototype.invokeHook = function () {\n\t        var hook = this.registeredHook;\n\t        if (hook._deregistered)\n\t            return;\n\t        var options = this.options;\n\t        trace_1.trace.traceHookInvocation(this, this.transition, options);\n\t        if (this.rejectIfSuperseded()) {\n\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t        }\n\t        var cb = hook.callback;\n\t        var bind = this.options.bind;\n\t        var trans = this.transition;\n\t        var state = this.stateContext;\n\t        var errorHandler = hook.eventType.getErrorHandler(this);\n\t        var resultHandler = hook.eventType.getResultHandler(this);\n\t        resultHandler = resultHandler || common_1.identity;\n\t        if (!errorHandler) {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        try {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        catch (error) {\n\t            return errorHandler(error);\n\t        }\n\t    };\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false (cancel), a TargetState (redirect),\n\t     * or a promise (which may later resolve to false or a redirect)\n\t     *\n\t     * This also handles \"transition superseded\" -- when a new transition\n\t     * was started while the hook was still running\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (result) {\n\t        // This transition is no longer current.\n\t        // Another transition started while this hook was still running.\n\t        if (this.rejectIfSuperseded()) {\n\t            // Abort this transition\n\t            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n\t        }\n\t        // Hook returned a promise\n\t        if (predicates_1.isPromise(result)) {\n\t            // Wait for the promise, then reprocess the resolved value\n\t            return result.then(this.handleHookResult.bind(this));\n\t        }\n\t        trace_1.trace.traceHookResult(result, this.transition, this.options);\n\t        // Hook returned false\n\t        if (result === false) {\n\t            // Abort this Transition\n\t            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n\t        }\n\t        var isTargetState = hof_1.is(targetState_1.TargetState);\n\t        // hook returned a TargetState\n\t        if (isTargetState(result)) {\n\t            // Halt the current Transition and start a redirected Transition (to the TargetState).\n\t            return rejectFactory_1.Rejection.redirected(result).toPromise();\n\t        }\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t    };\n\t    /**\n\t     * Run all TransitionHooks, ignoring their return value.\n\t     */\n\t    TransitionHook.runAllHooks = function (hooks) {\n\t        hooks.forEach(function (hook) { return hook.invokeHook(); });\n\t    };\n\t    /**\n\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n\t     *\n\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t     */\n\t    TransitionHook.runOnBeforeHooks = function (hooks) {\n\t        var results = [];\n\t        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n\t            var hook = hooks_1[_i];\n\t            var hookResult = hook.invokeHook();\n\t            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n\t                // Break on first thrown error or false/TargetState\n\t                return hookResult;\n\t            }\n\t            results.push(hookResult);\n\t        }\n\t        return results\n\t            .filter(predicates_1.isPromise)\n\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t    };\n\t    return TransitionHook;\n\t}());\n\tTransitionHook.HANDLE_RESULT = function (hook) {\n\t    return function (result) {\n\t        return hook.handleHookResult(result);\n\t    };\n\t};\n\tTransitionHook.IGNORE_RESULT = function (hook) {\n\t    return function (result) { return undefined; };\n\t};\n\tTransitionHook.LOG_ERROR = function (hook) {\n\t    return function (error) {\n\t        return (hook.stateService().defaultErrorHandler()(error), undefined);\n\t    };\n\t};\n\tTransitionHook.REJECT_ERROR = function (hook) {\n\t    return function (error) {\n\t        return rejectFactory_1.Rejection.errored(error).toPromise();\n\t    };\n\t};\n\tTransitionHook.THROW_ERROR = function (hook) {\n\t    return undefined;\n\t};\n\texports.TransitionHook = TransitionHook;\n\t//# sourceMappingURL=transitionHook.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * Encapsulate the target (destination) state/params/options of a [[Transition]].\n\t *\n\t * This class is frequently used to redirect a transition to a new destination.\n\t *\n\t * See:\n\t *\n\t * - [[HookResult]]\n\t * - [[TransitionHookFn]]\n\t * - [[TransitionService.onStart]]\n\t *\n\t * To create a `TargetState`, use [[StateService.target]].\n\t *\n\t * ---\n\t *\n\t * This class wraps:\n\t *\n\t * 1) an identifier for a state\n\t * 2) a set of parameters\n\t * 3) and transition options\n\t * 4) the registered state object (the [[StateDeclaration]])\n\t *\n\t * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n\t * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n\t * The `TargetState` class normalizes those options.\n\t *\n\t * A `TargetState` may be valid (the state being targeted exists in the registry)\n\t * or invalid (the state being targeted is not registered).\n\t */\n\tvar TargetState = (function () {\n\t    /**\n\t     * The TargetState constructor\n\t     *\n\t     * Note: Do not construct a `TargetState` manually.\n\t     * To create a `TargetState`, use the [[StateService.target]] factory method.\n\t     *\n\t     * @param _identifier An identifier for a state.\n\t     *    Either a fully-qualified state name, or the object used to define the state.\n\t     * @param _definition The internal state representation, if exists.\n\t     * @param _params Parameters for the target state\n\t     * @param _options Transition options.\n\t     *\n\t     * @internalapi\n\t     */\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    /** The name of the state this object targets */\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    /** The identifier used when creating this TargetState */\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    /** The target parameter values */\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    /** The internal state object (if it was found) */\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    /** The internal state declaration (if it was found) */\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    /** The target options */\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /** True if the target state was found */\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    /** True if the object is valid */\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /** If the object is invalid, returns the reason why */\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    TargetState.prototype.toString = function () {\n\t        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n\t    };\n\t    return TargetState;\n\t}());\n\t/** Returns true if the object has a state property that might be a state or state name */\n\tTargetState.isDef = function (obj) {\n\t    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n\t};\n\texports.TargetState = TargetState;\n\t//# sourceMappingURL=targetState.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16); // has or is using\n\tvar glob_1 = __webpack_require__(10);\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t *\n\t * @hidden\n\t *\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = new glob_1.Glob(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\texports.matchState = matchState;\n\t/**\n\t * @internalapi\n\t * The registration data for a registered transition hook\n\t */\n\tvar RegisteredHook = (function () {\n\t    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.tranSvc = tranSvc;\n\t        this.eventType = eventType;\n\t        this.callback = callback;\n\t        this.matchCriteria = matchCriteria;\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t        this._deregistered = false;\n\t    }\n\t    /**\n\t     * Gets the matching [[PathNode]]s\n\t     *\n\t     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n\t     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n\t     *\n\t     * Returning `null` is significant to distinguish between the default\n\t     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n\t     * when the nodes is an empty array.\n\t     *\n\t     * This is useful to allow a transition match criteria of `entering: true`\n\t     * to still match a transition, even when `entering === []`.  Contrast that\n\t     * with `entering: (state) => true` which only matches when a state is actually\n\t     * being entered.\n\t     */\n\t    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Gets the default match criteria (all `true`)\n\t     *\n\t     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n\t     *\n\t     * ```js\n\t     * {\n\t     *   to: true,\n\t     *   from: true,\n\t     *   entering: true,\n\t     *   exiting: true,\n\t     *   retained: true,\n\t     * }\n\t     */\n\t    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n\t        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n\t    };\n\t    /**\n\t     * Gets matching nodes as [[IMatchingNodes]]\n\t     *\n\t     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n\t     *\n\t     * ```js\n\t     * let matches: IMatchingNodes = {\n\t     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n\t     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n\t     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n\t     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n\t     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n\t     * };\n\t     * ```\n\t     */\n\t    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n\t        var _this = this;\n\t        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n\t        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n\t        return paths.reduce(function (mn, pathtype) {\n\t            // STATE scope criteria matches against every node in the path.\n\t            // TRANSITION scope criteria matches against only the last node in the path\n\t            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n\t            var path = treeChanges[pathtype.name] || [];\n\t            var nodes = isStateHook ? path : [common_1.tail(path)];\n\t            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n\t            return mn;\n\t        }, {});\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    RegisteredHook.prototype.matches = function (treeChanges) {\n\t        var matches = this._getMatchingNodes(treeChanges);\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = common_1.values(matches).every(common_1.identity);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return RegisteredHook;\n\t}());\n\texports.RegisteredHook = RegisteredHook;\n\t/** @hidden Return a registration function of the requested type. */\n\tfunction makeEvent(registry, transitionService, eventType) {\n\t    // Create the object which holds the registered transition hooks.\n\t    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n\t    var hooks = _registeredHooks[eventType.name] = [];\n\t    // Create hook registration function on the IHookRegistry for the event\n\t    registry[eventType.name] = hookRegistrationFn;\n\t    function hookRegistrationFn(matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n\t        hooks.push(registeredHook);\n\t        return function deregisterEventHook() {\n\t            registeredHook._deregistered = true;\n\t            common_1.removeFrom(hooks)(registeredHook);\n\t        };\n\t    }\n\t    return hookRegistrationFn;\n\t}\n\texports.makeEvent = makeEvent;\n\t//# sourceMappingURL=hookRegistry.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder(transition) {\n\t        this.transition = transition;\n\t        this.treeChanges = transition.treeChanges();\n\t        this.transitionOptions = transition.options();\n\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t        this.$transitions = transition.router.transitionService;\n\t        this.baseHookOptions = {\n\t            transition: transition,\n\t            current: transition.options().current\n\t        };\n\t    }\n\t    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n\t        var _this = this;\n\t        return this.$transitions._pluginapi._getEvents(phase)\n\t            .map(function (type) { return _this.buildHooks(type); })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(common_1.identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[PathNode]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     */\n\t    HookBuilder.prototype.buildHooks = function (hookType) {\n\t        var _this = this;\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(_this.treeChanges);\n\t            // Select the PathNode[] that will be used as TransitionHook context objects\n\t            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n\t            // Return an array of HookTuples\n\t            return matchingNodes.map(function (node) {\n\t                var _options = common_1.extend({\n\t                    bind: hook.bind,\n\t                    traceData: { hookType: hookType.name, context: node }\n\t                }, _this.baseHookOptions);\n\t                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n\t                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(common_1.unnestR, [])\n\t            .sort(tupleSort(hookType.reverseSort))\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all RegisteredHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[RegisteredHook]]s\n\t     */\n\t    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n\t        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n\t        // Instance and Global hook registries\n\t        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n\t        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n\t            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\texports.HookBuilder = HookBuilder;\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\t//# sourceMappingURL=hookBuilder.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module path */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar param_1 = __webpack_require__(22);\n\t/**\n\t * A node in a [[TreeChanges]] path\n\t *\n\t * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n\t * Each PathNode corresponds to a state being entered, exited, or retained.\n\t * The stateful information includes parameter values and resolve data.\n\t */\n\tvar PathNode = (function () {\n\t    function PathNode(stateOrPath) {\n\t        if (stateOrPath instanceof PathNode) {\n\t            var node = stateOrPath;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t            this.resolvables = node.resolvables.slice();\n\t            this.views = node.views && node.views.slice();\n\t        }\n\t        else {\n\t            var state = stateOrPath;\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n\t        }\n\t    }\n\t    /** Sets [[paramValues]] for the node, from the values of an object hash */\n\t    PathNode.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    /** Gets a specific [[Param]] metadata that belongs to the node */\n\t    PathNode.prototype.parameter = function (name) {\n\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t    };\n\t    /**\n\t     * @returns true if the state and parameter values for another PathNode are\n\t     * equal to the state and param values for this PathNode\n\t     */\n\t    PathNode.prototype.equals = function (node, keys) {\n\t        var _this = this;\n\t        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n\t        var paramValsEq = function (key) {\n\t            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n\t        };\n\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t    };\n\t    /** Returns a clone of the PathNode */\n\t    PathNode.clone = function (node) {\n\t        return new PathNode(node);\n\t    };\n\t    /**\n\t     * Returns a new path which is a subpath of the first path which matched the second path.\n\t     *\n\t     * The new path starts from root and contains any nodes that match the nodes in the second path.\n\t     * Nodes are compared using their state property and parameter values.\n\t     *\n\t     * @param pathA the first path\n\t     * @param pathB the second path\n\t     * @param ignoreDynamicParams don't compare dynamic parameter values\n\t     */\n\t    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n\t        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n\t        var matching = [];\n\t        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n\t            var a = pathA[i], b = pathB[i];\n\t            if (a.state !== b.state)\n\t                break;\n\t            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n\t                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n\t            if (changedParams.length)\n\t                break;\n\t            matching.push(a);\n\t        }\n\t        return matching;\n\t    };\n\t    return PathNode;\n\t}());\n\texports.PathNode = PathNode;\n\t//# sourceMappingURL=node.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar isShorthand = function (cfg) {\n\t    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\t};\n\tvar DefType;\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(DefType = exports.DefType || (exports.DefType = {}));\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    return common_1.extend(cfg, {\n\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t    });\n\t}\n\tfunction getType(cfg, urlType, location, id, paramTypes) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n\t        return paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type) {\n\t        var type = location === DefType.CONFIG ? \"any\" :\n\t            location === DefType.PATH ? \"path\" :\n\t                location === DefType.SEARCH ? \"query\" : \"string\";\n\t        return paramTypes.type(type);\n\t    }\n\t    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t        return defaultPolicy;\n\t    if (squash === true || predicates_1.isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t    ];\n\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t    if (predicates_1.isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\tvar Param = (function () {\n\t    function Param(id, type, config, location, urlMatcherFactory) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n\t        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n\t        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n\t        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var $$getDefaultValue = function () {\n\t            if (!coreservices_1.services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\t            return defaultValue;\n\t        };\n\t        var $replace = function (val) {\n\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t            return replacement.length ? replacement[0] : val;\n\t        };\n\t        value = $replace(value);\n\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    Param.values = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\texports.Param = Param;\n\t//# sourceMappingURL=param.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * An internal class which implements [[ParamTypeDefinition]].\n\t *\n\t * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n\t * When a param type definition is registered, an instance of this class is created internally.\n\t *\n\t * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n\t *\n\t * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n\t *\n\t * #### Example:\n\t * ```js\n\t * var paramTypeDef = {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t *\n\t * var paramType = new ParamType(paramTypeDef);\n\t * ```\n\t * @internalapi\n\t */\n\tvar ParamType = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n\t     * @returns a new ParamType object\n\t     */\n\t    function ParamType(def) {\n\t        /** @inheritdoc */\n\t        this.pattern = /.*/;\n\t        /** @inheritdoc */\n\t        this.inherit = true;\n\t        common_1.extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    ParamType.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.equals = function (a, b) { return a == b; };\n\t    ParamType.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    ParamType.prototype.toString = function () {\n\t        return \"{ParamType:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    ParamType.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    ParamType.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t/**\n\t * Wraps up a `ParamType` object to handle array values.\n\t * @internalapi\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) {\n\t        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n\t    }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (predicates_1.isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = common_1.map(arr, callback);\n\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n\t        var paramTypeFn = type[name].bind(type);\n\t        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n\t        _this[name] = wrapperFn(paramTypeFn);\n\t    });\n\t    common_1.extend(this, {\n\t        dynamic: type.dynamic,\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        inherit: type.inherit,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t//# sourceMappingURL=paramType.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module path */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar node_1 = __webpack_require__(21);\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathFactory = (function () {\n\t    function PathFactory() {\n\t    }\n\t    /** Given a PathNode[], create an TargetState */\n\t    PathFactory.makeTargetState = function (path) {\n\t        var state = common_1.tail(path).state;\n\t        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    PathFactory.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathFactory.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    /**\n\t     * Creates ViewConfig objects and adds to nodes.\n\t     *\n\t     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n\t     */\n\t    PathFactory.applyViewConfigs = function ($view, path, states) {\n\t        // Only apply the viewConfigs to the nodes for the given states\n\t        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n\t            var viewDecls = common_1.values(node.state.views || {});\n\t            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n\t            node.views = viewConfigs.reduce(common_1.unnestR, []);\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t            return common_1.extend({}, node && node.paramValues);\n\t        }\n\t        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (param) { return !param.inherit; })\n\t            .map(hof_1.prop('id'));\n\t        /**\n\t         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        function makeInheritedParamsNode(toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n\t            toParamVals = common_1.omit(toParamVals, toKeys);\n\t            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n\t        }\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode);\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var staticParams = function (state) {\n\t            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n\t        };\n\t        var nodesMatch = function (node1, node2) {\n\t            return node1.equals(node2, staticParams(node1.state));\n\t        };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = node_1.PathNode.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        var retainedWithToParams = retained.map(applyToParams);\n\t        entering = toPath.slice(keep);\n\t        to = (retainedWithToParams).concat(entering);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    /**\n\t     * Return a subpath of a path, which stops at the first matching node\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node,\n\t     * stopping when the first node matches the predicate.\n\t     *\n\t     * @param path a path of [[PathNode]]s\n\t     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n\t     * @returns a subpath up to the matching node, or undefined if no match is found\n\t     */\n\t    PathFactory.subPath = function (path, predicate) {\n\t        var node = common_1.find(path, predicate);\n\t        var elementIdx = path.indexOf(node);\n\t        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n\t    };\n\t    return PathFactory;\n\t}());\n\t/** Gets the raw parameter values from a path */\n\tPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\texports.PathFactory = PathFactory;\n\t//# sourceMappingURL=pathFactory.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module resolve\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar trace_1 = __webpack_require__(15);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\t// TODO: explicitly make this user configurable\n\texports.defaultResolvePolicy = {\n\t    when: \"LAZY\",\n\t    async: \"WAIT\"\n\t};\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(arg1, resolveFn, deps, policy, data) {\n\t        this.resolved = false;\n\t        this.promise = undefined;\n\t        if (arg1 instanceof Resolvable) {\n\t            common_1.extend(this, arg1);\n\t        }\n\t        else if (predicates_1.isFunction(resolveFn)) {\n\t            if (arg1 == null || arg1 == undefined)\n\t                throw new Error(\"new Resolvable(): token argument is required\");\n\t            if (!predicates_1.isFunction(resolveFn))\n\t                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\t            this.token = arg1;\n\t            this.policy = policy;\n\t            this.resolveFn = resolveFn;\n\t            this.deps = deps || [];\n\t            this.data = data;\n\t            this.resolved = data !== undefined;\n\t            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n\t        }\n\t        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n\t            var literal = arg1;\n\t            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n\t        }\n\t    }\n\t    Resolvable.prototype.getPolicy = function (state) {\n\t        var thisPolicy = this.policy || {};\n\t        var statePolicy = state && state.resolvePolicy || {};\n\t        return {\n\t            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n\t            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n\t        };\n\t    };\n\t    /**\n\t     * Asynchronously resolve this Resolvable's data\n\t     *\n\t     * Given a ResolveContext that this Resolvable is found in:\n\t     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n\t     * and update the Resolvable's state\n\t     */\n\t    Resolvable.prototype.resolve = function (resolveContext, trans) {\n\t        var _this = this;\n\t        var $q = coreservices_1.services.$q;\n\t        // Gets all dependencies from ResolveContext and wait for them to be resolved\n\t        var getResolvableDependencies = function () {\n\t            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n\t                return r.get(resolveContext, trans);\n\t            }));\n\t        };\n\t        // Invokes the resolve function passing the resolved dependencies as arguments\n\t        var invokeResolveFn = function (resolvedDeps) {\n\t            return _this.resolveFn.apply(null, resolvedDeps);\n\t        };\n\t        /**\n\t         * For RXWAIT policy:\n\t         *\n\t         * Given an observable returned from a resolve function:\n\t         * - enables .cache() mode (this allows multicast subscribers)\n\t         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n\t         * - Waits for the promise, then return the cached observable (not the first emitted value).\n\t         */\n\t        var waitForRx = function (observable$) {\n\t            var cached = observable$.cache(1);\n\t            return cached.take(1).toPromise().then(function () { return cached; });\n\t        };\n\t        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n\t        var node = resolveContext.findNode(this);\n\t        var state = node && node.state;\n\t        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n\t        // After the final value has been resolved, update the state of the Resolvable\n\t        var applyResolvedValue = function (resolvedValue) {\n\t            _this.data = resolvedValue;\n\t            _this.resolved = true;\n\t            trace_1.trace.traceResolvableResolved(_this, trans);\n\t            return _this.data;\n\t        };\n\t        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\t        return this.promise = $q.when()\n\t            .then(getResolvableDependencies)\n\t            .then(invokeResolveFn)\n\t            .then(maybeWaitForRx)\n\t            .then(applyResolvedValue);\n\t    };\n\t    /**\n\t     * Gets a promise for this Resolvable's data.\n\t     *\n\t     * Fetches the data and returns a promise.\n\t     * Returns the existing promise if it has already been fetched once.\n\t     */\n\t    Resolvable.prototype.get = function (resolveContext, trans) {\n\t        return this.promise || this.resolve(resolveContext, trans);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n\t    };\n\t    Resolvable.prototype.clone = function () {\n\t        return new Resolvable(this);\n\t    };\n\t    return Resolvable;\n\t}());\n\tResolvable.fromData = function (token, data) {\n\t    return new Resolvable(token, function () { return data; }, null, null, data);\n\t};\n\texports.Resolvable = Resolvable;\n\t//# sourceMappingURL=resolvable.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar interface_1 = __webpack_require__(27);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar strings_1 = __webpack_require__(12);\n\tvar when = interface_1.resolvePolicies.when;\n\tvar ALL_WHENS = [when.EAGER, when.LAZY];\n\tvar EAGER_WHENS = [when.EAGER];\n\texports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n\t/**\n\t * Encapsulates Depenency Injection for a path of nodes\n\t *\n\t * UI-Router states are organized as a tree.\n\t * A nested state has a path of ancestors to the root of the tree.\n\t * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n\t * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n\t *\n\t * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n\t */\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t    }\n\t    /** Gets all the tokens found in the resolve context, de-duplicated */\n\t    ResolveContext.prototype.getTokens = function () {\n\t        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n\t    };\n\t    /**\n\t     * Gets the Resolvable that matches the token\n\t     *\n\t     * Gets the last Resolvable that matches the token in this context, or undefined.\n\t     * Throws an error if it doesn't exist in the ResolveContext\n\t     */\n\t    ResolveContext.prototype.getResolvable = function (token) {\n\t        var matching = this._path.map(function (node) { return node.resolvables; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (r) { return r.token === token; });\n\t        return common_1.tail(matching);\n\t    };\n\t    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\t    ResolveContext.prototype.getPolicy = function (resolvable) {\n\t        var node = this.findNode(resolvable);\n\t        return resolvable.getPolicy(node.state);\n\t    };\n\t    /**\n\t     * Returns a ResolveContext that includes a portion of this one\n\t     *\n\t     * Given a state, this method creates a new ResolveContext from this one.\n\t     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n\t     *\n\t     * #### Why\n\t     *\n\t     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n\t     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n\t     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n\t     * This method is used to create a narrower context when injecting ancestor nodes.\n\t     *\n\t     * @example\n\t     * `let ABCD = new ResolveContext([A, B, C, D]);`\n\t     *\n\t     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n\t     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n\t     * However, `B` should only be able to access resolvables from `A`, `B`.\n\t     *\n\t     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n\t     * `let AB = ABCD.subcontext(a)`\n\t     */\n\t    ResolveContext.prototype.subContext = function (state) {\n\t        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n\t    };\n\t    /**\n\t     * Adds Resolvables to the node that matches the state\n\t     *\n\t     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n\t     * The resolvable is added to the node matching the `state` parameter.\n\t     *\n\t     * These new resolvables are not automatically fetched.\n\t     * The calling code should either fetch them, fetch something that depends on them,\n\t     * or rely on [[resolvePath]] being called when some state is being entered.\n\t     *\n\t     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n\t     *\n\t     * @param newResolvables the new Resolvables\n\t     * @param state Used to find the node to put the resolvable on\n\t     */\n\t    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n\t        var node = common_1.find(this._path, hof_1.propEq('state', state));\n\t        var keys = newResolvables.map(function (r) { return r.token; });\n\t        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n\t    };\n\t    /**\n\t     * Returns a promise for an array of resolved path Element promises\n\t     *\n\t     * @param when\n\t     * @param trans\n\t     * @returns {Promise<any>|any}\n\t     */\n\t    ResolveContext.prototype.resolvePath = function (when, trans) {\n\t        var _this = this;\n\t        if (when === void 0) { when = \"LAZY\"; }\n\t        // This option determines which 'when' policy Resolvables we are about to fetch.\n\t        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n\t        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n\t        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\t        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\t        // get the subpath to the state argument, if provided\n\t        trace_1.trace.traceResolvePath(this._path, when, trans);\n\t        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n\t            return function (resolvable) {\n\t                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n\t            };\n\t        };\n\t        // Trigger all the (matching) Resolvables in the path\n\t        // Reduce all the \"WAIT\" Resolvables into an array\n\t        var promises = this._path.reduce(function (acc, node) {\n\t            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n\t            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n\t            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n\t            // For the matching Resolvables, start their async fetch process.\n\t            var subContext = _this.subContext(node.state);\n\t            var getResult = function (r) { return r.get(subContext, trans)\n\t                .then(function (value) { return ({ token: r.token, value: value }); }); };\n\t            nowait.forEach(getResult);\n\t            return acc.concat(wait.map(getResult));\n\t        }, []);\n\t        // Wait for all the \"WAIT\" resolvables\n\t        return coreservices_1.services.$q.all(promises);\n\t    };\n\t    ResolveContext.prototype.injector = function () {\n\t        return this._injector || (this._injector = new UIInjectorImpl(this));\n\t    };\n\t    ResolveContext.prototype.findNode = function (resolvable) {\n\t        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n\t    };\n\t    /**\n\t     * Gets the async dependencies of a Resolvable\n\t     *\n\t     * Given a Resolvable, returns its dependencies as a Resolvable[]\n\t     */\n\t    ResolveContext.prototype.getDependencies = function (resolvable) {\n\t        var _this = this;\n\t        var node = this.findNode(resolvable);\n\t        // Find which other resolvables are \"visible\" to the `resolvable` argument\n\t        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\t        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n\t        var availableResolvables = subPath\n\t            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n\t            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n\t        var getDependency = function (token) {\n\t            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n\t            if (matching.length)\n\t                return common_1.tail(matching);\n\t            var fromInjector = _this.injector().getNative(token);\n\t            if (!fromInjector) {\n\t                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n\t            }\n\t            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n\t        };\n\t        return resolvable.deps.map(getDependency);\n\t    };\n\t    return ResolveContext;\n\t}());\n\texports.ResolveContext = ResolveContext;\n\tvar UIInjectorImpl = (function () {\n\t    function UIInjectorImpl(context) {\n\t        this.context = context;\n\t        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n\t    }\n\t    UIInjectorImpl.prototype.get = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable) {\n\t            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n\t                return resolvable.get(this.context);\n\t            }\n\t            if (!resolvable.resolved) {\n\t                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n\t            }\n\t            return resolvable.data;\n\t        }\n\t        return this.native && this.native.get(token);\n\t    };\n\t    UIInjectorImpl.prototype.getAsync = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable)\n\t            return resolvable.get(this.context);\n\t        return coreservices_1.services.$q.when(this.native.get(token));\n\t    };\n\t    UIInjectorImpl.prototype.getNative = function (token) {\n\t        return this.native && this.native.get(token);\n\t    };\n\t    return UIInjectorImpl;\n\t}());\n\t//# sourceMappingURL=resolveContext.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/** @internalapi */\n\texports.resolvePolicies = {\n\t    when: {\n\t        LAZY: \"LAZY\",\n\t        EAGER: \"EAGER\"\n\t    },\n\t    async: {\n\t        WAIT: \"WAIT\",\n\t        NOWAIT: \"NOWAIT\",\n\t        RXWAIT: \"RXWAIT\"\n\t    }\n\t};\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar urlMatcherFactory_1 = __webpack_require__(29);\n\tvar urlRouter_1 = __webpack_require__(32);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar view_1 = __webpack_require__(43);\n\tvar stateRegistry_1 = __webpack_require__(44);\n\tvar stateService_1 = __webpack_require__(48);\n\tvar globals_1 = __webpack_require__(49);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlService_1 = __webpack_require__(51);\n\tvar trace_1 = __webpack_require__(15);\n\t/** @hidden */\n\tvar _routerInstance = 0;\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n\t * This class instantiates and wires the UI-Router services together.\n\t *\n\t * After a new instance of the UIRouter class is created, it should be configured for your app.\n\t * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n\t *\n\t * ---\n\t *\n\t * Normally the framework code will bootstrap UI-Router.\n\t * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n\t * [[UrlService.listen]] then [[UrlService.sync]].\n\t */\n\tvar UIRouter = (function () {\n\t    /**\n\t     * Creates a new `UIRouter` object\n\t     *\n\t     * @param locationService a [[LocationServices]] implementation\n\t     * @param locationConfig a [[LocationConfig]] implementation\n\t     * @internalapi\n\t     */\n\t    function UIRouter(locationService, locationConfig) {\n\t        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n\t        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n\t        this.locationService = locationService;\n\t        this.locationConfig = locationConfig;\n\t        /** @hidden */\n\t        this.$id = _routerInstance++;\n\t        /** Provides trace information to the console */\n\t        this.trace = trace_1.trace;\n\t        /** Provides services related to ui-view synchronization */\n\t        this.viewService = new view_1.ViewService();\n\t        /** Provides services related to Transitions */\n\t        this.transitionService = new transitionService_1.TransitionService(this);\n\t        /** Global router state */\n\t        this.globals = new globals_1.Globals(this.transitionService);\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlRouter = new urlRouter_1.UrlRouter(this);\n\t        /** Provides a registry for states, and related registration services */\n\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n\t        /** Provides services related to states */\n\t        this.stateService = new stateService_1.StateService(this);\n\t        /** Provides services related to the URL */\n\t        this.urlService = new urlService_1.UrlService(this);\n\t        /** @hidden */\n\t        this._disposables = [];\n\t        /** @hidden */\n\t        this._plugins = {};\n\t        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t        this.disposable(this.transitionService);\n\t        this.disposable(this.urlRouter);\n\t        this.disposable(this.stateRegistry);\n\t        this.disposable(locationService);\n\t        this.disposable(locationConfig);\n\t    }\n\t    /** Registers an object to be notified when the router is disposed */\n\t    UIRouter.prototype.disposable = function (disposable) {\n\t        this._disposables.push(disposable);\n\t    };\n\t    /**\n\t     * Disposes this router instance\n\t     *\n\t     * When called, clears resources retained by the router by calling `dispose(this)` on all\n\t     * registered [[disposable]] objects.\n\t     *\n\t     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n\t     *\n\t     * @param disposable (optional) the disposable to dispose\n\t     */\n\t    UIRouter.prototype.dispose = function (disposable) {\n\t        var _this = this;\n\t        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n\t            disposable.dispose(this);\n\t            return undefined;\n\t        }\n\t        this._disposables.slice().forEach(function (d) {\n\t            try {\n\t                typeof d.dispose === 'function' && d.dispose(_this);\n\t                common_1.removeFrom(_this._disposables, d);\n\t            }\n\t            catch (ignored) { }\n\t        });\n\t    };\n\t    /**\n\t     * Adds a plugin to UI-Router\n\t     *\n\t     * This method adds a UI-Router Plugin.\n\t     * A plugin can enhance or change UI-Router behavior using any public API.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n\t     *\n\t     * var plugin = router.addPlugin(MyCoolPlugin);\n\t     * ```\n\t     *\n\t     * ### Plugin authoring\n\t     *\n\t     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n\t     *\n\t     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n\t     * For example, it may configure router options or add a Transition Hook.\n\t     *\n\t     * The plugin can then be published as a separate module.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * export class MyAuthPlugin implements UIRouterPlugin {\n\t     *   constructor(router: UIRouter, options: any) {\n\t     *     this.name = \"MyAuthPlugin\";\n\t     *     let $transitions = router.transitionService;\n\t     *     let $state = router.stateService;\n\t     *\n\t     *     let authCriteria = {\n\t     *       to: (state) => state.data && state.data.requiresAuth\n\t     *     };\n\t     *\n\t     *     function authHook(transition: Transition) {\n\t     *       let authService = transition.injector().get('AuthService');\n\t     *       if (!authService.isAuthenticated()) {\n\t     *         return $state.target('login');\n\t     *       }\n\t     *     }\n\t     *\n\t     *     $transitions.onStart(authCriteria, authHook);\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @param plugin one of:\n\t     *        - a plugin class which implements [[UIRouterPlugin]]\n\t     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n\t     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n\t     * @param options options to pass to the plugin class/factory\n\t     * @returns the registered plugin instance\n\t     */\n\t    UIRouter.prototype.plugin = function (plugin, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var pluginInstance = new plugin(this, options);\n\t        if (!pluginInstance.name)\n\t            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n\t        this._disposables.push(pluginInstance);\n\t        return this._plugins[pluginInstance.name] = pluginInstance;\n\t    };\n\t    UIRouter.prototype.getPlugin = function (pluginName) {\n\t        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n\t    };\n\t    return UIRouter;\n\t}());\n\texports.UIRouter = UIRouter;\n\t//# sourceMappingURL=router.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar param_1 = __webpack_require__(22);\n\tvar paramTypes_1 = __webpack_require__(31);\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n\t        /** @hidden */ this._isCaseInsensitive = false;\n\t        /** @hidden */ this._isStrictMode = true;\n\t        /** @hidden */ this._defaultSquashPolicy = false;\n\t        /** @hidden */\n\t        this._getConfig = function (config) {\n\t            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n\t        };\n\t        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\t        this.paramFactory = {\n\t            /** Creates a new [[Param]] from a CONFIG block */\n\t            fromConfig: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url PATH */\n\t            fromPath: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url SEARCH */\n\t            fromSearch: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n\t            },\n\t        };\n\t        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n\t    }\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!predicates_1.isObject(object))\n\t            return false;\n\t        var result = true;\n\t        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n\t            if (predicates_1.isFunction(val))\n\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    ;\n\t    /**\n\t     * Creates and registers a custom [[ParamType]] object\n\t     *\n\t     * A [[ParamType]] can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app runtime starts.\n\t     *        The result of this function should be a [[ParamTypeDefinition]].\n\t     *        The result is merged into the existing `definition`.\n\t     *        See [[ParamType]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n\t     *\n\t     * Note: Register custom types *before using them* in a state definition.\n\t     *\n\t     * See [[ParamTypeDefinition]] for examples\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = this.paramTypes.type(name, definition, definitionFn);\n\t        return !predicates_1.isDefined(definition) ? type : this;\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        this.paramTypes.enqueue = false;\n\t        this.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    ;\n\t    /** @internalapi */\n\t    UrlMatcherFactory.prototype.dispose = function () {\n\t        this.paramTypes.dispose();\n\t    };\n\t    return UrlMatcherFactory;\n\t}());\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\t//# sourceMappingURL=urlMatcherFactory.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar param_1 = __webpack_require__(22);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\t/** @hidden */\n\tvar memoizeTo = function (obj, prop, fn) {\n\t    return obj[prop] = obj[prop] || fn();\n\t};\n\t/**\n\t * Matches URLs against patterns.\n\t *\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL.\n\t *\n\t * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n\t * parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by [[UrlMatcher.exec]].\n\t *\n\t * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n\t * or colon placeholders (`/somePath/:param`).\n\t *\n\t * - *A parameter RegExp* may be defined for a param after a colon\n\t * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n\t * The regexp must match for the url to be matched.\n\t * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n\t *\n\t * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n\t *   See [[UrlMatcherFactory.type]] for more information.\n\t *\n\t * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n\t *   A catch-all * parameter value will contain the remainder of the URL.\n\t *\n\t * ---\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters).\n\t * A path parameter matches any number of characters other than '/'. For catch-all\n\t * placeholders the path parameter matches any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t */\n\tvar UrlMatcher = (function () {\n\t    /**\n\t     * @param pattern The pattern to compile into a matcher.\n\t     * @param paramTypes The [[ParamTypes]] registry\n\t     * @param config  A configuration object\n\t     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t     */\n\t    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n\t        var _this = this;\n\t        this.config = config;\n\t        /** @hidden */\n\t        this._cache = { path: [this], parent: null, pattern: null };\n\t        /** @hidden */\n\t        this._children = [];\n\t        /** @hidden */\n\t        this._params = [];\n\t        /** @hidden */\n\t        this._segments = [];\n\t        /** @hidden */\n\t        this._compiled = [];\n\t        this.pattern = pattern;\n\t        this.config = common_1.defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: common_1.identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3];\n\t            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n\t                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t            }); };\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern.substring(last, m.index),\n\t                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n\t    }\n\t    /**\n\t     * Creates a new concatenated UrlMatcher\n\t     *\n\t     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n\t     *\n\t     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        url._cache = {\n\t            path: this._cache.path.concat(url),\n\t            parent: this,\n\t            pattern: null,\n\t        };\n\t        return url;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path[0] === this;\n\t    };\n\t    /** Returns the input pattern string */\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * Tests the specified url/path against this matcher.\n\t     *\n\t     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n\t     * parameter values.  Returns null if the path does not match.\n\t     *\n\t     * The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * ```\n\t     *\n\t     * @param path    The URL path to match, e.g. `$location.path()`.\n\t     * @param search  URL search parameters, e.g. `$location.search()`.\n\t     * @param hash    URL hash e.g. `$location.hash()`.\n\t     * @param options\n\t     *\n\t     * @returns The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = common_1.map(split, reverseString);\n\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        }\n\t        searchParams.forEach(function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values[\"#\"] = hash;\n\t        return values;\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns a single parameter from this UrlMatcher by id\n\t     *\n\t     * @param id\n\t     * @param opts\n\t     * @returns {T|Param|any|boolean|UrlMatcher|null}\n\t     */\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var parent = this._cache.parent;\n\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n\t            null);\n\t    };\n\t    /**\n\t     * Validates the input parameter values against this UrlMatcher\n\t     *\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param params The object hash of parameters to validate.\n\t     * @returns Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var _this = this;\n\t        var validParamVal = function (param, val) {\n\t            return !param || param.validates(val);\n\t        };\n\t        return common_1.pairs(params || {}).map(function (_a) {\n\t            var key = _a[0], val = _a[1];\n\t            return validParamVal(_this.parameter(key), val);\n\t        }).reduce(common_1.allTrueR, true);\n\t    };\n\t    /**\n\t     * Given a set of parameter values, creates a URL from this UrlMatcher.\n\t     *\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * ```\n\t     *\n\t     * @param values  the values to substitute for the parameters in this pattern.\n\t     * @returns the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values) {\n\t        if (values === void 0) { values = {}; }\n\t        if (!this.validates(values))\n\t            return null;\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path;\n\t        // Extract all the static segments and Params into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n\t        /**\n\t         * Given a Param,\n\t         * Applies the parameter value, then returns details about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values[param.id]);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (predicates_1.isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (predicates_1.isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (predicates_1.isArray(encoded))\n\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (param) {\n\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!predicates_1.isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.raw)\n\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val) { return param.id + \"=\" + val; });\n\t        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t    };\n\t    /**\n\t     * Compare two UrlMatchers\n\t     *\n\t     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n\t     * Each static path segment is a static string between a path separator (slash character).\n\t     * Each dynamic segment is a path parameter.\n\t     *\n\t     * The comparison function sorts static segments before dynamic ones.\n\t     */\n\t    UrlMatcher.compare = function (a, b) {\n\t        var splitOnSlash = strings_1.splitOnDelim('/');\n\t        /**\n\t         * Turn a UrlMatcher and all its parent matchers into an array\n\t         * of slash literals '/', string literals, and Param objects\n\t         *\n\t         * This example matcher matches strings like \"/foo/:param/tail\":\n\t         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n\t         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n\t         *\n\t         */\n\t        var segments = function (matcher) {\n\t            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n\t                .reduce(common_1.unnestR, [])\n\t                .reduce(strings_1.joinNeighborsR, [])\n\t                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n\t                .reduce(common_1.unnestR, []);\n\t        };\n\t        var aSegments = segments(a), bSegments = segments(b);\n\t        // console.table( { aSegments, bSegments });\n\t        // Sort slashes first, then static strings, the Params\n\t        var weight = hof_1.pattern([\n\t            [hof_1.eq(\"/\"), hof_1.val(1)],\n\t            [predicates_1.isString, hof_1.val(2)],\n\t            [hof_1.is(param_1.Param), hof_1.val(3)]\n\t        ]);\n\t        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n\t        // console.table(pairs);\n\t        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n\t    };\n\t    return UrlMatcher;\n\t}());\n\t/** @hidden */\n\tUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\texports.UrlMatcher = UrlMatcher;\n\t//# sourceMappingURL=urlMatcher.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\t/**\n\t * A registry for parameter types.\n\t *\n\t * This registry manages the built-in (and custom) parameter types.\n\t *\n\t * The built-in parameter types are:\n\t *\n\t * - [[string]]\n\t * - [[path]]\n\t * - [[query]]\n\t * - [[hash]]\n\t * - [[int]]\n\t * - [[bool]]\n\t * - [[date]]\n\t * - [[json]]\n\t * - [[any]]\n\t */\n\tvar ParamTypes = (function () {\n\t    /** @internalapi */\n\t    function ParamTypes() {\n\t        /** @hidden */\n\t        this.enqueue = true;\n\t        /** @hidden */\n\t        this.typeQueue = [];\n\t        /** @internalapi */\n\t        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) {\n\t            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        };\n\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t    }\n\t    /** @internalapi */\n\t    ParamTypes.prototype.dispose = function () {\n\t        this.types = {};\n\t    };\n\t    /**\n\t     * Registers a parameter type\n\t     *\n\t     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n\t     */\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!predicates_1.isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    /** @internalapi */\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\texports.ParamTypes = ParamTypes;\n\t/** @hidden */\n\tfunction initDefaultTypes() {\n\t    var makeDefaultType = function (def) {\n\t        var valToString = function (val) {\n\t            return val != null ? val.toString() : val;\n\t        };\n\t        var defaultTypeBase = {\n\t            encode: valToString,\n\t            decode: valToString,\n\t            is: hof_1.is(String),\n\t            pattern: /.*/,\n\t            equals: function (a, b) { return a == b; },\n\t        };\n\t        return common_1.extend({}, defaultTypeBase, def);\n\t    };\n\t    // Default Parameter Type Definitions\n\t    common_1.extend(ParamTypes.prototype, {\n\t        string: makeDefaultType({}),\n\t        path: makeDefaultType({\n\t            pattern: /[^/]*/,\n\t        }),\n\t        query: makeDefaultType({}),\n\t        hash: makeDefaultType({\n\t            inherit: false,\n\t        }),\n\t        int: makeDefaultType({\n\t            decode: function (val) { return parseInt(val, 10); },\n\t            is: function (val) {\n\t                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n\t            },\n\t            pattern: /-?\\d+/,\n\t        }),\n\t        bool: makeDefaultType({\n\t            encode: function (val) { return val && 1 || 0; },\n\t            decode: function (val) { return parseInt(val, 10) !== 0; },\n\t            is: hof_1.is(Boolean),\n\t            pattern: /0|1/\n\t        }),\n\t        date: makeDefaultType({\n\t            encode: function (val) {\n\t                return !this.is(val) ? undefined : [\n\t                    val.getFullYear(),\n\t                    ('0' + (val.getMonth() + 1)).slice(-2),\n\t                    ('0' + val.getDate()).slice(-2)\n\t                ].join(\"-\");\n\t            },\n\t            decode: function (val) {\n\t                if (this.is(val))\n\t                    return val;\n\t                var match = this.capture.exec(val);\n\t                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t            },\n\t            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t            equals: function (l, r) {\n\t                return ['getFullYear', 'getMonth', 'getDate']\n\t                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t            },\n\t            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t        }),\n\t        json: makeDefaultType({\n\t            encode: common_1.toJson,\n\t            decode: common_1.fromJson,\n\t            is: hof_1.is(Object),\n\t            equals: common_1.equals,\n\t            pattern: /[^/]*/\n\t        }),\n\t        // does not encode/decode\n\t        any: makeDefaultType({\n\t            encode: common_1.identity,\n\t            decode: common_1.identity,\n\t            is: function () { return true; },\n\t            equals: common_1.equals,\n\t        }),\n\t    });\n\t}\n\tinitDefaultTypes();\n\t//# sourceMappingURL=paramTypes.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar hof_1 = __webpack_require__(8);\n\tvar urlRule_1 = __webpack_require__(33);\n\tvar targetState_1 = __webpack_require__(18);\n\t/** @hidden */\n\tfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t/** @hidden */\n\tvar getMatcher = hof_1.prop(\"urlMatcher\");\n\t/**\n\t * Default rule priority sorting function.\n\t *\n\t * Sorts rules by:\n\t *\n\t * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n\t * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n\t * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n\t * - Registration order (for rule types other than STATE and URLMATCHER)\n\t *\n\t * @coreapi\n\t */\n\tvar defaultRuleSortFn;\n\tdefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n\t/**\n\t * Updates URL and responds to URL changes\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class updates the URL when the state changes.\n\t * It also responds to changes in the URL.\n\t */\n\tvar UrlRouter = (function () {\n\t    /** @hidden */\n\t    function UrlRouter(router) {\n\t        /** @hidden */ this._sortFn = defaultRuleSortFn;\n\t        /** @hidden */ this._rules = [];\n\t        /** @hidden */ this.interceptDeferred = false;\n\t        /** @hidden */ this._id = 0;\n\t        this._router = router;\n\t        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n\t        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n\t    }\n\t    /** @internalapi */\n\t    UrlRouter.prototype.dispose = function () {\n\t        this.listen(false);\n\t        this._rules = [];\n\t        delete this._otherwiseFn;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sort = function (compareFn) {\n\t        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n\t    };\n\t    /**\n\t     * Given a URL, check all rules and return the best [[MatchResult]]\n\t     * @param url\n\t     * @returns {MatchResult}\n\t     */\n\t    UrlRouter.prototype.match = function (url) {\n\t        var _this = this;\n\t        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n\t        var rules = this.rules();\n\t        if (this._otherwiseFn)\n\t            rules.push(this._otherwiseFn);\n\t        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n\t        var checkRule = function (rule) {\n\t            var match = rule.match(url, _this._router);\n\t            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n\t        };\n\t        // The rules are pre-sorted.\n\t        // - Find the first matching rule.\n\t        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n\t        // - Choose the rule with the highest match weight.\n\t        var best;\n\t        for (var i = 0; i < rules.length; i++) {\n\t            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n\t            if (best && this._sortFn(rules[i], best.rule) !== 0)\n\t                break;\n\t            var current = checkRule(rules[i]);\n\t            // Pick the best MatchResult\n\t            best = (!best || current && current.weight > best.weight) ? current : best;\n\t        }\n\t        return best;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sync = function (evt) {\n\t        if (evt && evt.defaultPrevented)\n\t            return;\n\t        var router = this._router, $url = router.urlService, $state = router.stateService;\n\t        var url = {\n\t            path: $url.path(), search: $url.search(), hash: $url.hash()\n\t        };\n\t        var best = this.match(url);\n\t        var applyResult = hof_1.pattern([\n\t            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n\t            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n\t            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n\t        ]);\n\t        applyResult(best && best.rule.handler(best.match, url, router));\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.listen = function (enabled) {\n\t        var _this = this;\n\t        if (enabled === false) {\n\t            this._stopFn && this._stopFn();\n\t            delete this._stopFn;\n\t        }\n\t        else {\n\t            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n\t        }\n\t    };\n\t    /**\n\t     * Internal API.\n\t     * @internalapi\n\t     */\n\t    UrlRouter.prototype.update = function (read) {\n\t        var $url = this._router.locationService;\n\t        if (read) {\n\t            this.location = $url.path();\n\t            return;\n\t        }\n\t        if ($url.path() === this.location)\n\t            return;\n\t        $url.url(this.location, true);\n\t    };\n\t    /**\n\t     * Internal API.\n\t     *\n\t     * Pushes a new location to the browser history.\n\t     *\n\t     * @internalapi\n\t     * @param urlMatcher\n\t     * @param params\n\t     * @param options\n\t     */\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        var replace = options && !!options.replace;\n\t        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n\t    };\n\t    /**\n\t     * Builds and returns a URL with interpolated parameters\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * matcher = $umf.compile(\"/about/:person\");\n\t     * params = { person: \"bob\" };\n\t     * $bob = $urlRouter.href(matcher, params);\n\t     * // $bob == \"/about/bob\";\n\t     * ```\n\t     *\n\t     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n\t     * @param params An object of parameter values to fill the matcher's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params))\n\t            return null;\n\t        var url = urlMatcher.format(params);\n\t        options = options || { absolute: false };\n\t        var cfg = this._router.urlService.config;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    /**\n\t     * Manually adds a URL Rule.\n\t     *\n\t     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n\t     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n\t     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n\t     *\n\t     * A rule should have a `match` function which returns truthy if the rule matched.\n\t     * It should also have a `handler` function which is invoked if the rule is the best match.\n\t     *\n\t     * @return a function that deregisters the rule\n\t     */\n\t    UrlRouter.prototype.rule = function (rule) {\n\t        var _this = this;\n\t        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n\t            throw new Error(\"invalid rule\");\n\t        rule.$id = this._id++;\n\t        rule.priority = rule.priority || 0;\n\t        this._rules.push(rule);\n\t        this.sort();\n\t        return function () { return _this.removeRule(rule); };\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.removeRule = function (rule) {\n\t        common_1.removeFrom(this._rules, rule);\n\t        this.sort();\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.otherwise = function (handler) {\n\t        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n\t            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n\t        }\n\t        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n\t        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n\t        this.sort();\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.when = function (matcher, handler, options) {\n\t        var rule = this.urlRuleFactory.create(matcher, handler);\n\t        if (predicates_1.isDefined(options && options.priority))\n\t            rule.priority = options.priority;\n\t        this.rule(rule);\n\t        return rule;\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    ;\n\t    return UrlRouter;\n\t}());\n\texports.UrlRouter = UrlRouter;\n\t//# sourceMappingURL=urlRouter.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/**\n\t * Creates a [[UrlRule]]\n\t *\n\t * Creates a [[UrlRule]] from a:\n\t *\n\t * - `string`\n\t * - [[UrlMatcher]]\n\t * - `RegExp`\n\t * - [[State]]\n\t * @internalapi\n\t */\n\tvar UrlRuleFactory = (function () {\n\t    function UrlRuleFactory(router) {\n\t        this.router = router;\n\t    }\n\t    UrlRuleFactory.prototype.compile = function (str) {\n\t        return this.router.urlMatcherFactory.compile(str);\n\t    };\n\t    UrlRuleFactory.prototype.create = function (what, handler) {\n\t        var _this = this;\n\t        var makeRule = hof_1.pattern([\n\t            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n\t            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n\t            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n\t            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n\t            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n\t        ]);\n\t        var rule = makeRule(what);\n\t        if (!rule)\n\t            throw new Error(\"invalid 'what' in when()\");\n\t        return rule;\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a UrlMatcher\n\t     *\n\t     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     *\n\t     * ## Handler as UrlMatcher\n\t     *\n\t     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n\t     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n\t     * The url is replaced with the result.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n\t        var _handler = handler;\n\t        if (predicates_1.isString(handler))\n\t            handler = this.router.urlMatcherFactory.compile(handler);\n\t        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n\t            _handler = function (match) { return handler.format(match); };\n\t        function match(url) {\n\t            var match = urlMatcher.exec(url.path, url.search, url.hash);\n\t            return urlMatcher.validates(match) && match;\n\t        }\n\t        // Prioritize URLs, lowest to highest:\n\t        // - Some optional URL parameters, but none matched\n\t        // - No optional parameters in URL\n\t        // - Some optional parameters, some matched\n\t        // - Some optional parameters, all matched\n\t        function matchPriority(params) {\n\t            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n\t            if (!optional.length)\n\t                return 0.000001;\n\t            var matched = optional.filter(function (param) { return params[param.id]; });\n\t            return matched.length / optional.length;\n\t        }\n\t        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches a state by its url\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromState($state.get('foo'), router);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match);\n\t     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromState = function (state, router) {\n\t        /**\n\t         * Handles match by transitioning to matched state\n\t         *\n\t         * First checks if the router should start a new transition.\n\t         * A new transition is not required if the current state's URL\n\t         * and the new URL are already identical\n\t         */\n\t        var handler = function (match) {\n\t            var $state = router.stateService;\n\t            var globals = router.globals;\n\t            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n\t                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n\t            }\n\t        };\n\t        var details = { state: state, type: \"STATE\" };\n\t        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a regular expression\n\t     *\n\t     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - regexp match array (from `regexp`)\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     *\n\t     * ## Handler as string\n\t     *\n\t     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n\t     * The string is first interpolated using `string.replace()` style pattern.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n\t        if (regexp.global || regexp.sticky)\n\t            throw new Error(\"Rule RegExp must not be global or sticky\");\n\t        /**\n\t         * If handler is a string, the url will be replaced by the string.\n\t         * If the string has any String.replace() style variables in it (like `$2`),\n\t         * they will be replaced by the captures from [[match]]\n\t         */\n\t        var redirectUrlTo = function (match) {\n\t            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n\t            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t                return match[what === '$' ? 0 : Number(what)];\n\t            });\n\t        };\n\t        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n\t        var match = function (url) {\n\t            return regexp.exec(url.path);\n\t        };\n\t        var details = { regexp: regexp, type: \"REGEXP\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    return UrlRuleFactory;\n\t}());\n\tUrlRuleFactory.isUrlRule = function (obj) {\n\t    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n\t};\n\texports.UrlRuleFactory = UrlRuleFactory;\n\t/**\n\t * A base rule which calls `match`\n\t *\n\t * The value from the `match` function is passed through to the `handler`.\n\t * @internalapi\n\t */\n\tvar BaseUrlRule = (function () {\n\t    function BaseUrlRule(match, handler) {\n\t        var _this = this;\n\t        this.match = match;\n\t        this.type = \"RAW\";\n\t        this.matchPriority = function (match) { return 0 - _this.$id; };\n\t        this.handler = handler || common_1.identity;\n\t    }\n\t    return BaseUrlRule;\n\t}());\n\texports.BaseUrlRule = BaseUrlRule;\n\t//# sourceMappingURL=urlRule.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Internal representation of a UI-Router state.\n\t *\n\t * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n\t *\n\t * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n\t *\n\t * This class prototypally inherits from the corresponding [[StateDeclaration]].\n\t * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n\t */\n\tvar State = (function () {\n\t    function State(config) {\n\t        common_1.extend(this, config);\n\t        // Object.freeze(this);\n\t    }\n\t    /**\n\t     * Returns true if the provided parameter is the same state.\n\t     *\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    State.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @deprecated this does not properly handle dot notation\n\t     * @returns Returns a dot-separated name of the state.\n\t     */\n\t    State.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns The root of this state's tree.\n\t     */\n\t    State.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    /**\n\t     * Gets the state's `Param`eters\n\t     *\n\t     * Gets [[Param]] information that is owned by the state.\n\t     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n\t     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n\t     *\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameters = function (opts) {\n\t        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(common_1.values(this.params))\n\t            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n\t    };\n\t    /**\n\t     * Returns a single [[Param]] that is owned by the state\n\t     *\n\t     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n\t     * @param id the name of the [[Param]] to return\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    State.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    return State;\n\t}());\n\texports.State = State;\n\t//# sourceMappingURL=stateObject.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar interface_1 = __webpack_require__(16);\n\tvar transition_1 = __webpack_require__(14);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar resolve_1 = __webpack_require__(36);\n\tvar views_1 = __webpack_require__(37);\n\tvar url_1 = __webpack_require__(38);\n\tvar redirectTo_1 = __webpack_require__(39);\n\tvar onEnterExitRetain_1 = __webpack_require__(40);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar transitionEventType_1 = __webpack_require__(42);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * The default [[Transition]] options.\n\t *\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\texports.defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; },\n\t    source: \"unknown\"\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * - Most importantly, it allows global Transition Hooks to be registered.\n\t * - It allows the default transition error handler to be set.\n\t * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n\t *\n\t * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n\t */\n\tvar TransitionService = (function () {\n\t    /** @hidden */\n\t    function TransitionService(_router) {\n\t        /** @hidden */\n\t        this._transitionCount = 0;\n\t        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n\t        this._eventTypes = [];\n\t        /** @hidden The registered transition hooks */\n\t        this._registeredHooks = {};\n\t        /** @hidden The  paths on a criteria object */\n\t        this._criteriaPaths = {};\n\t        this._router = _router;\n\t        this.$view = _router.viewService;\n\t        this._deregisterHookFns = {};\n\t        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n\t            '_definePathType',\n\t            '_defineEvent',\n\t            '_getPathTypes',\n\t            '_getEvents',\n\t            'getHooks',\n\t        ]);\n\t        this._defineDefaultPaths();\n\t        this._defineDefaultEvents();\n\t        this._registerDefaultTransitionHooks();\n\t    }\n\t    /**\n\t     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n\t     *\n\t     * Registers a transition lifecycle hook, which is invoked during transition construction.\n\t     *\n\t     * This low level hook should only be used by plugins.\n\t     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n\t     * The Sticky States plugin uses this hook to modify the treechanges.\n\t     *\n\t     * ### Lifecycle\n\t     *\n\t     * `onCreate` hooks are invoked *while a transition is being constructed*.\n\t     *\n\t     * ### Return value\n\t     *\n\t     * The hook's return value is ignored\n\t     *\n\t     * @internalapi\n\t     * @param criteria defines which Transitions the Hook should be invoked for.\n\t     * @param callback the hook function which will be invoked.\n\t     * @param options the registration options\n\t     * @returns a function which deregisters the hook.\n\t     */\n\t    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n\t    /**\n\t     * dispose\n\t     * @internalapi\n\t     */\n\t    TransitionService.prototype.dispose = function (router) {\n\t        delete router.globals.transition;\n\t        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n\t            hook._deregistered = true;\n\t            common_1.removeFrom(hooksArray, hook);\n\t        }); });\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     * It is used internally by the [[StateService]] and should generally not be called by application code.\n\t     *\n\t     * @param fromPath the path to the current state (the from state)\n\t     * @param targetState the target state (destination)\n\t     * @returns a Transition\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new transition_1.Transition(fromPath, targetState, this._router);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultEvents = function () {\n\t        var Phase = interface_1.TransitionHookPhase;\n\t        var TH = transitionHook_1.TransitionHook;\n\t        var paths = this._criteriaPaths;\n\t        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n\t        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n\t        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n\t        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n\t        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n\t        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n\t        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n\t        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultPaths = function () {\n\t        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n\t        this._definePathType(\"to\", TRANSITION);\n\t        this._definePathType(\"from\", TRANSITION);\n\t        this._definePathType(\"exiting\", STATE);\n\t        this._definePathType(\"retained\", STATE);\n\t        this._definePathType(\"entering\", STATE);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n\t        this._eventTypes.push(eventType);\n\t        hookRegistry_1.makeEvent(this, this, eventType);\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    TransitionService.prototype._getEvents = function (phase) {\n\t        var transitionHookTypes = predicates_1.isDefined(phase) ?\n\t            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n\t            this._eventTypes.slice();\n\t        return transitionHookTypes.sort(function (l, r) {\n\t            var cmpByPhase = l.hookPhase - r.hookPhase;\n\t            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n\t        });\n\t    };\n\t    /**\n\t     * Adds a Path to be used as a criterion against a TreeChanges path\n\t     *\n\t     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n\t     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n\t     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * @hidden\n\t     */\n\t    TransitionService.prototype._definePathType = function (name, hookScope) {\n\t        this._criteriaPaths[name] = { name: name, scope: hookScope };\n\t    };\n\t    /** * @hidden */\n\t    TransitionService.prototype._getPathTypes = function () {\n\t        return this._criteriaPaths;\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n\t        var fns = this._deregisterHookFns;\n\t        // Wire up redirectTo hook\n\t        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n\t        // Wire up onExit/Retain/Enter state hooks\n\t        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n\t        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n\t        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n\t        // Wire up Resolve hooks\n\t        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n\t        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n\t        // Wire up the View management hooks\n\t        fns.loadViews = views_1.registerLoadEnteringViews(this);\n\t        fns.activateViews = views_1.registerActivateViews(this);\n\t        // After globals.current is updated at priority: 10000\n\t        fns.updateUrl = url_1.registerUpdateUrl(this);\n\t        // Lazy load state trees\n\t        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n\t    };\n\t    return TransitionService;\n\t}());\n\texports.TransitionService = TransitionService;\n\t//# sourceMappingURL=transitionService.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n\t *\n\t * Registered using `transitionService.onStart({}, eagerResolvePath);`\n\t *\n\t * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar eagerResolvePath = function (trans) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .resolvePath(\"EAGER\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerEagerResolvePath = function (transitionService) {\n\t    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n\t *\n\t * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n\t *\n\t * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar lazyResolveState = function (trans, state) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .subContext(state)\n\t        .resolvePath(\"LAZY\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerLazyResolveState = function (transitionService) {\n\t    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n\t};\n\t//# sourceMappingURL=resolve.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] which waits for the views to load\n\t *\n\t * Registered using `transitionService.onStart({}, loadEnteringViews);`\n\t *\n\t * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n\t * In angular 1, this includes loading the templates.\n\t */\n\tvar loadEnteringViews = function (transition) {\n\t    var $q = coreservices_1.services.$q;\n\t    var enteringViews = transition.views(\"entering\");\n\t    if (!enteringViews.length)\n\t        return;\n\t    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n\t};\n\texports.registerLoadEnteringViews = function (transitionService) {\n\t    return transitionService.onFinish({}, loadEnteringViews);\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n\t *\n\t * Registered using `transitionService.onSuccess({}, activateViews);`\n\t *\n\t * After a transition is complete, this hook deactivates the old views from the previous state,\n\t * and activates the new views from the destination state.\n\t *\n\t * See [[ViewService]]\n\t */\n\tvar activateViews = function (transition) {\n\t    var enteringViews = transition.views(\"entering\");\n\t    var exitingViews = transition.views(\"exiting\");\n\t    if (!enteringViews.length && !exitingViews.length)\n\t        return;\n\t    var $view = transition.router.viewService;\n\t    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n\t    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n\t    $view.sync();\n\t};\n\texports.registerActivateViews = function (transitionService) {\n\t    return transitionService.onSuccess({}, activateViews);\n\t};\n\t//# sourceMappingURL=views.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A [[TransitionHookFn]] which updates the URL after a successful transition\n\t *\n\t * Registered using `transitionService.onSuccess({}, updateUrl);`\n\t */\n\tvar updateUrl = function (transition) {\n\t    var options = transition.options();\n\t    var $state = transition.router.stateService;\n\t    var $urlRouter = transition.router.urlRouter;\n\t    // Dont update the url in these situations:\n\t    // The transition was triggered by a URL sync (options.source === 'url')\n\t    // The user doesn't want the url to update (options.location === false)\n\t    // The destination state, and all parents have no navigable url\n\t    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n\t        var urlOptions = { replace: options.location === 'replace' };\n\t        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n\t    }\n\t    $urlRouter.update(true);\n\t};\n\texports.registerUpdateUrl = function (transitionService) {\n\t    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n\t};\n\t//# sourceMappingURL=url.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar targetState_1 = __webpack_require__(18);\n\t/**\n\t * A [[TransitionHookFn]] that redirects to a different state or params\n\t *\n\t * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n\t *\n\t * See [[StateDeclaration.redirectTo]]\n\t */\n\tvar redirectToHook = function (trans) {\n\t    var redirect = trans.to().redirectTo;\n\t    if (!redirect)\n\t        return;\n\t    var $state = trans.router.stateService;\n\t    function handleResult(result) {\n\t        if (!result)\n\t            return;\n\t        if (result instanceof targetState_1.TargetState)\n\t            return result;\n\t        if (predicates_1.isString(result))\n\t            return $state.target(result, trans.params(), trans.options());\n\t        if (result['state'] || result['params'])\n\t            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n\t    }\n\t    if (predicates_1.isFunction(redirect)) {\n\t        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n\t    }\n\t    return handleResult(redirect);\n\t};\n\texports.registerRedirectToHook = function (transitionService) {\n\t    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n\t};\n\t//# sourceMappingURL=redirectTo.js.map\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A factory which creates an onEnter, onExit or onRetain transition hook function\n\t *\n\t * The returned function invokes the (for instance) state.onEnter hook when the\n\t * state is being entered.\n\t *\n\t * @hidden\n\t */\n\tfunction makeEnterExitRetainHook(hookName) {\n\t    return function (transition, state) {\n\t        var hookFn = state[hookName];\n\t        return hookFn(transition, state);\n\t    };\n\t}\n\t/**\n\t * The [[TransitionStateHookFn]] for onExit\n\t *\n\t * When the state is being exited, the state's .onExit function is invoked.\n\t *\n\t * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n\t *\n\t * See: [[IHookRegistry.onExit]]\n\t */\n\tvar onExitHook = makeEnterExitRetainHook('onExit');\n\texports.registerOnExitHook = function (transitionService) {\n\t    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onRetain\n\t *\n\t * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n\t *\n\t * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n\t *\n\t * See: [[IHookRegistry.onRetain]]\n\t */\n\tvar onRetainHook = makeEnterExitRetainHook('onRetain');\n\texports.registerOnRetainHook = function (transitionService) {\n\t    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onEnter\n\t *\n\t * When the state is being entered, the state's .onEnter function is invoked.\n\t *\n\t * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n\t *\n\t * See: [[IHookRegistry.onEnter]]\n\t */\n\tvar onEnterHook = makeEnterExitRetainHook('onEnter');\n\texports.registerOnEnterHook = function (transitionService) {\n\t    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n\t};\n\t//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] that performs lazy loading\n\t *\n\t * When entering a state \"abc\" which has a `lazyLoad` function defined:\n\t * - Invoke the `lazyLoad` function (unless it is already in process)\n\t *   - Flag the hook function as \"in process\"\n\t *   - The function should return a promise (that resolves when lazy loading is complete)\n\t * - Wait for the promise to settle\n\t *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n\t *   - Flag the hook function as \"not in process\"\n\t * - If the hook was successful\n\t *   - Remove the `lazyLoad` function from the state declaration\n\t * - If all the hooks were successful\n\t *   - Retry the transition (by returning a TargetState)\n\t *\n\t * ```\n\t * .state('abc', {\n\t *   component: 'fooComponent',\n\t *   lazyLoad: () => System.import('./fooComponent')\n\t *   });\n\t * ```\n\t *\n\t * See [[StateDeclaration.lazyLoad]]\n\t */\n\tvar lazyLoadHook = function (transition) {\n\t    var router = transition.router;\n\t    function retryTransition() {\n\t        if (transition.originalTransition().options().source !== 'url') {\n\t            // The original transition was not triggered via url sync\n\t            // The lazy state should be loaded now, so re-try the original transition\n\t            var orig = transition.targetState();\n\t            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n\t        }\n\t        // The original transition was triggered via url sync\n\t        // Run the URL rules and find the best match\n\t        var $url = router.urlService;\n\t        var result = $url.match($url.parts());\n\t        var rule = result && result.rule;\n\t        // If the best match is a state, redirect the transition (instead\n\t        // of calling sync() which supersedes the current transition)\n\t        if (rule && rule.type === \"STATE\") {\n\t            var state = rule.state;\n\t            var params = result.match;\n\t            return router.stateService.target(state, params, transition.options());\n\t        }\n\t        // No matching state found, so let .sync() choose the best non-state match/otherwise\n\t        router.urlService.sync();\n\t    }\n\t    var promises = transition.entering()\n\t        .filter(function (state) { return !!state.$$state().lazyLoad; })\n\t        .map(function (state) { return lazyLoadState(transition, state); });\n\t    return coreservices_1.services.$q.all(promises).then(retryTransition);\n\t};\n\texports.registerLazyLoadHook = function (transitionService) {\n\t    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n\t};\n\t/**\n\t * Invokes a state's lazy load function\n\t *\n\t * @param transition a Transition context\n\t * @param state the state to lazy load\n\t * @returns A promise for the lazy load result\n\t */\n\tfunction lazyLoadState(transition, state) {\n\t    var lazyLoadFn = state.$$state().lazyLoad;\n\t    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\t    var promise = lazyLoadFn['_promise'];\n\t    if (!promise) {\n\t        var success = function (result) {\n\t            delete state.lazyLoad;\n\t            delete state.$$state().lazyLoad;\n\t            delete lazyLoadFn['_promise'];\n\t            return result;\n\t        };\n\t        var error = function (err) {\n\t            delete lazyLoadFn['_promise'];\n\t            return coreservices_1.services.$q.reject(err);\n\t        };\n\t        promise = lazyLoadFn['_promise'] =\n\t            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n\t                .then(updateStateRegistry)\n\t                .then(success, error);\n\t    }\n\t    /** Register any lazy loaded state definitions */\n\t    function updateStateRegistry(result) {\n\t        if (result && Array.isArray(result.states)) {\n\t            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n\t        }\n\t        return result;\n\t    }\n\t    return promise;\n\t}\n\texports.lazyLoadState = lazyLoadState;\n\t//# sourceMappingURL=lazyLoad.js.map\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class defines a type of hook, such as `onBefore` or `onEnter`.\n\t * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n\t *\n\t * @interalapi\n\t */\n\tvar TransitionEventType = (function () {\n\t    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        this.name = name;\n\t        this.hookPhase = hookPhase;\n\t        this.hookOrder = hookOrder;\n\t        this.criteriaMatchPath = criteriaMatchPath;\n\t        this.reverseSort = reverseSort;\n\t        this.getResultHandler = getResultHandler;\n\t        this.getErrorHandler = getErrorHandler;\n\t        this.rejectIfSuperseded = rejectIfSuperseded;\n\t    }\n\t    return TransitionEventType;\n\t}());\n\texports.TransitionEventType = TransitionEventType;\n\t//# sourceMappingURL=transitionEventType.js.map\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module view\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar trace_1 = __webpack_require__(15);\n\t/**\n\t * The View service\n\t *\n\t * This service pairs existing `ui-view` components (which live in the DOM)\n\t * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n\t *\n\t * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n\t *   The views from exited states are deactivated via [[deactivateViewConfig]].\n\t *   (See: the [[registerActivateViews]] Transition Hook)\n\t *\n\t * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n\t *\n\t * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n\t * are configured with the matching [[ViewConfig]](s)\n\t *\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this._uiViews = [];\n\t        this._viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this._pluginapi = {\n\t            _rootViewContext: this._rootViewContext.bind(this),\n\t            _viewConfigFactory: this._viewConfigFactory.bind(this),\n\t            _registeredUIViews: function () { return _this._uiViews; },\n\t            _activeViewConfigs: function () { return _this._viewConfigs; },\n\t        };\n\t    }\n\t    ViewService.prototype._rootViewContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    ;\n\t    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (path, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(path, decl);\n\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * Deactivates a ViewConfig.\n\t     *\n\t     * This function deactivates a `ViewConfig`.\n\t     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        common_1.removeFrom(this._viewConfigs, viewConfig);\n\t    };\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this._viewConfigs.push(viewConfig);\n\t    };\n\t    ViewService.prototype.sync = function () {\n\t        var _this = this;\n\t        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t        // Return the number of dots in the fully qualified name\n\t        function uiViewDepth(uiView) {\n\t            return uiView.fqn.split(\".\").length;\n\t        }\n\t        // Return the ViewConfig's context's depth in the context tree.\n\t        function viewConfigDepth(config) {\n\t            var context = config.viewDecl.$context, count = 0;\n\t            while (++count && context.parent)\n\t                context = context.parent;\n\t            return count;\n\t        }\n\t        // Given a depth function, returns a compare function which can return either ascending or descending order\n\t        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t        var matchingConfigPair = function (uiView) {\n\t            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n\t            if (matchingConfigs.length > 1) {\n\t                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n\t                // Sort by depth and return the match from the deepest child\n\t                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n\t                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t            }\n\t            return [uiView, matchingConfigs[0]];\n\t        };\n\t        var configureUIView = function (_a) {\n\t            var uiView = _a[0], viewConfig = _a[1];\n\t            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t            if (_this._uiViews.indexOf(uiView) !== -1)\n\t                uiView.configUpdated(viewConfig);\n\t        };\n\t        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n\t    };\n\t    ;\n\t    /**\n\t     * Registers a `ui-view` component\n\t     *\n\t     * When a `ui-view` component is created, it uses this method to register itself.\n\t     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n\t     *\n\t     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n\t     * and what the view's state context is.\n\t     *\n\t     * Note: There is no corresponding `deregisterUIView`.\n\t     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n\t     *\n\t     * @param uiView The metadata for a UIView\n\t     * @return a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUIView = function (uiView) {\n\t        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this._uiViews;\n\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t        if (uiViews.filter(fqnMatches).length)\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx === -1) {\n\t                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n\t            common_1.removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    ;\n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this._uiViews.map(hof_1.prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * This should be used by a framework implementation to calculate the values for\n\t     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        else if (uiViewContextAnchor === '.') {\n\t            uiViewContextAnchor = context.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    return ViewService;\n\t}());\n\t/**\n\t * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t *\n\t * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t *\n\t * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t *\n\t * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t *\n\t * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t * - the ui-view's name matches the ViewConfig's target name\n\t * - the ui-view's context matches the ViewConfig's anchor\n\t *\n\t * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t * - There exists a parent ui-view where:\n\t *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t *    - the parent ui-view's context matches the ViewConfig's anchor\n\t * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t *\n\t * Example:\n\t *\n\t * DOM:\n\t * <ui-view>                        <!-- created in the root context (name: \"\") -->\n\t *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t *       </ui-view>\n\t *     </ui-view>\n\t *   </ui-view>\n\t * </ui-view>\n\t *\n\t * uiViews: [\n\t *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t * ]\n\t *\n\t * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t *\n\t * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t *\n\t * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t *   the tail of the ui-view's fqn \"default.bar\"\n\t *\n\t * @internalapi\n\t */\n\tViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n\t    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t    if (uiView.$type !== viewConfig.viewDecl.$type)\n\t        return false;\n\t    // Split names apart from both viewConfig and uiView into segments\n\t    var vc = viewConfig.viewDecl;\n\t    var vcSegments = vc.$uiViewName.split(\".\");\n\t    var uivSegments = uiView.fqn.split(\".\");\n\t    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t        return false;\n\t    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t    var negOffset = (1 - vcSegments.length) || undefined;\n\t    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t}; };\n\texports.ViewService = ViewService;\n\t//# sourceMappingURL=view.js.map\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar stateMatcher_1 = __webpack_require__(45);\n\tvar stateBuilder_1 = __webpack_require__(46);\n\tvar stateQueueManager_1 = __webpack_require__(47);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar StateRegistry = (function () {\n\t    /** @internalapi */\n\t    function StateRegistry(_router) {\n\t        this._router = _router;\n\t        this.states = {};\n\t        this.listeners = [];\n\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n\t        this._registerRoot();\n\t    }\n\t    /** @internalapi */\n\t    StateRegistry.prototype._registerRoot = function () {\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    };\n\t    /** @internalapi */\n\t    StateRegistry.prototype.dispose = function () {\n\t        var _this = this;\n\t        this.stateQueue.dispose();\n\t        this.listeners = [];\n\t        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n\t    };\n\t    /**\n\t     * Listen for a State Registry events\n\t     *\n\t     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let allStates = registry.get();\n\t     *\n\t     * // Later, invoke deregisterFn() to remove the listener\n\t     * let deregisterFn = registry.onStatesChanged((event, states) => {\n\t     *   switch(event) {\n\t     *     case: 'registered':\n\t     *       states.forEach(state => allStates.push(state));\n\t     *       break;\n\t     *     case: 'deregistered':\n\t     *       states.forEach(state => {\n\t     *         let idx = allStates.indexOf(state);\n\t     *         if (idx !== -1) allStates.splice(idx, 1);\n\t     *       });\n\t     *       break;\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param listener a callback function invoked when the registered states changes.\n\t     *        The function receives two parameters, `event` and `state`.\n\t     *        See [[StateRegistryListener]]\n\t     * @return a function that deregisters the listener\n\t     */\n\t    StateRegistry.prototype.onStatesChanged = function (listener) {\n\t        this.listeners.push(listener);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.listeners)(listener);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Gets the implicit root state\n\t     *\n\t     * Gets the root of the state tree.\n\t     * The root state is implicitly created by UI-Router.\n\t     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n\t     *\n\t     * @return the root [[State]]\n\t     */\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    /**\n\t     * Adds a state to the registry\n\t     *\n\t     * Registers a [[StateDeclaration]] or queues it for registration.\n\t     *\n\t     * Note: a state will be queued if the state's parent isn't yet registered.\n\t     *\n\t     * @param stateDefinition the definition of the state to register.\n\t     * @returns the internal [[State]] object.\n\t     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n\t     *          If the state was only queued, then the object is not fully built.\n\t     */\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    /** @hidden */\n\t    StateRegistry.prototype._deregisterTree = function (state) {\n\t        var _this = this;\n\t        var all = this.get().map(function (s) { return s.$$state(); });\n\t        var getChildren = function (states) {\n\t            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n\t            return children.length === 0 ? children : children.concat(getChildren(children));\n\t        };\n\t        var children = getChildren([state]);\n\t        var deregistered = [state].concat(children).reverse();\n\t        deregistered.forEach(function (state) {\n\t            var $ur = _this._router.urlRouter;\n\t            // Remove URL rule\n\t            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n\t            // Remove state from registry\n\t            delete _this.states[state.name];\n\t        });\n\t        return deregistered;\n\t    };\n\t    /**\n\t     * Removes a state from the registry\n\t     *\n\t     * This removes a state from the registry.\n\t     * If the state has children, they are are also removed from the registry.\n\t     *\n\t     * @param stateOrName the state's name or object representation\n\t     * @returns {State[]} a list of removed states\n\t     */\n\t    StateRegistry.prototype.deregister = function (stateOrName) {\n\t        var _state = this.get(stateOrName);\n\t        if (!_state)\n\t            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\t        var deregisteredStates = this._deregisterTree(_state.$$state());\n\t        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n\t        return deregisteredStates;\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\texports.StateRegistry = StateRegistry;\n\t//# sourceMappingURL=stateRegistry.js.map\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar glob_1 = __webpack_require__(10);\n\tvar common_1 = __webpack_require__(6);\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = predicates_1.isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        else if (isStr) {\n\t            var matches = common_1.values(this._states)\n\t                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n\t            if (matches.length > 1) {\n\t                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n\t            }\n\t            return matches[0];\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\texports.StateMatcher = StateMatcher;\n\t//# sourceMappingURL=stateMatcher.js.map\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\tvar hof_1 = __webpack_require__(8);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar parseUrl = function (url) {\n\t    if (!predicates_1.isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\tfunction nameBuilder(state) {\n\t    return state.name;\n\t}\n\tfunction selfBuilder(state) {\n\t    state.self.$$state = function () { return state; };\n\t    return state.self;\n\t}\n\tfunction dataBuilder(state) {\n\t    if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t    }\n\t    return state.data;\n\t}\n\tvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n\t    return function urlBuilder(state) {\n\t        var stateDec = state;\n\t        // For future states, i.e., states whose name ends with `.**`,\n\t        // match anything that starts with the url prefix\n\t        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n\t            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n\t        }\n\t        var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t            params: state.params || {},\n\t            paramMap: function (paramConfig, isSearch) {\n\t                if (stateDec.reloadOnSearch === false && isSearch)\n\t                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t                return paramConfig;\n\t            }\n\t        });\n\t        if (!url)\n\t            return null;\n\t        if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t    };\n\t};\n\tvar getNavigableBuilder = function (isRoot) {\n\t    return function navigableBuilder(state) {\n\t        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    };\n\t};\n\tvar getParamsBuilder = function (paramFactory) {\n\t    return function paramsBuilder(state) {\n\t        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n\t        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t};\n\tfunction pathBuilder(state) {\n\t    return state.parent ? state.parent.path.concat(state) : [state];\n\t}\n\tfunction includesBuilder(state) {\n\t    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t    includes[state.name] = true;\n\t    return includes;\n\t}\n\t/**\n\t * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * validates the `resolve` property and converts it to a [[Resolvable]] array.\n\t *\n\t * resolve: input value can be:\n\t *\n\t * {\n\t *   // analyzed but not injected\n\t *   myFooResolve: function() { return \"myFooData\"; },\n\t *\n\t *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n\t *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; \"DependencyName\" dep as string\n\t *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; DependencyType dep as token (compared using ===)\n\t *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n\t *\n\t *   // val.$inject used as deps\n\t *   // where:\n\t *   //     corgeResolve.$inject = [\"DependencyName\"];\n\t *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n\t *   // then \"DependencyName\" dep as string\n\t *   myCorgeResolve: corgeResolve,\n\t *\n\t *  // inject service by name\n\t *  // When a string is found, desugar creating a resolve that injects the named service\n\t *   myGraultResolve: \"SomeService\"\n\t * }\n\t *\n\t * or:\n\t *\n\t * [\n\t *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n\t *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n\t *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n\t * ]\n\t */\n\tfunction resolvablesBuilder(state) {\n\t    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n\t    var objects2Tuples = function (resolveObj, resolvePolicies) {\n\t        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n\t    };\n\t    /** fetch DI annotations from a function or ng1-style array */\n\t    var annotate = function (fn) {\n\t        var $injector = coreservices_1.services.$injector;\n\t        // ng1 doesn't have an $injector until runtime.\n\t        // If the $injector doesn't exist, use \"deferred\" literal as a\n\t        // marker indicating they should be annotated when runtime starts\n\t        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n\t    };\n\t    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\t    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n\t    /** true if the object looks like a provide literal, or a ng2 Provider */\n\t    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n\t    /** true if the object looks like a tuple from obj2Tuples */\n\t    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n\t    /** extracts the token from a Provider or provide literal */\n\t    var token = function (p) { return p.provide || p.token; };\n\t    /** Given a literal resolve or provider object, returns a Resolvable */\n\t    var literal2Resolvable = hof_1.pattern([\n\t        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n\t        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n\t        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n\t        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n\t        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n\t    ]);\n\t    var tuple2Resolvable = hof_1.pattern([\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n\t    ]);\n\t    var item2Resolvable = hof_1.pattern([\n\t        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n\t        [isResolveLiteral, literal2Resolvable],\n\t        [isLikeNg2Provider, literal2Resolvable],\n\t        [isTupleFromObj, tuple2Resolvable],\n\t        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n\t    ]);\n\t    // If resolveBlock is already an array, use it as-is.\n\t    // Otherwise, assume it's an object and convert to an Array of tuples\n\t    var decl = state.resolve;\n\t    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n\t    return items.map(item2Resolvable);\n\t}\n\texports.resolvablesBuilder = resolvablesBuilder;\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[State]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[State]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, urlMatcherFactory) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var root = function () { return matcher.find(\"\"); };\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        function parentBuilder(state) {\n\t            if (isRoot(state))\n\t                return null;\n\t            return matcher.find(self.parentName(state)) || root();\n\t        }\n\t        this.builders = {\n\t            name: [nameBuilder],\n\t            self: [selfBuilder],\n\t            parent: [parentBuilder],\n\t            data: [dataBuilder],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [getUrlBuilder(urlMatcherFactory, root)],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [getNavigableBuilder(isRoot)],\n\t            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/statebuilders/views.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [pathBuilder],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [includesBuilder],\n\t            resolvables: [resolvablesBuilder]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent))\n\t            return null;\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        var name = state.name || \"\";\n\t        var segments = name.split('.');\n\t        if (segments.length > 1) {\n\t            if (state.parent) {\n\t                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n\t            }\n\t            var lastSegment = segments.pop();\n\t            if (lastSegment === '**')\n\t                segments.pop();\n\t            return segments.join(\".\");\n\t        }\n\t        if (!state.parent)\n\t            return \"\";\n\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\texports.StateBuilder = StateBuilder;\n\t//# sourceMappingURL=stateBuilder.js.map\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/** @internalapi */\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n\t        this.$registry = $registry;\n\t        this.$urlRouter = $urlRouter;\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.listeners = listeners;\n\t        this.queue = [];\n\t    }\n\t    /** @internalapi */\n\t    StateQueueManager.prototype.dispose = function () {\n\t        this.queue = [];\n\t    };\n\t    StateQueueManager.prototype.register = function (config) {\n\t        var _a = this, states = _a.states, queue = _a.queue;\n\t        // Wrap a new object around the state so we can store our private details easily.\n\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n\t            self: config,\n\t            resolve: config.resolve || [],\n\t            toString: function () { return config.name; }\n\t        }));\n\t        if (!predicates_1.isString(state.name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t        queue.push(state);\n\t        this.flush();\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function () {\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var registered = [], // states that got registered\n\t        orphans = [], // states that don't yet have a parent registered\n\t        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\t        while (queue.length > 0) {\n\t            var state = queue.shift();\n\t            var result = builder.build(state);\n\t            var orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                var existingState = this.$registry.get(state.name);\n\t                if (existingState && existingState.name === state.name) {\n\t                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t                }\n\t                if (existingState && existingState.name === state.name + \".**\") {\n\t                    // Remove future state of the same name\n\t                    this.$registry.deregister(existingState);\n\t                }\n\t                states[state.name] = state;\n\t                this.attachRoute(state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                registered.push(state);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[state.name];\n\t            previousQueueLength[state.name] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t                queue.push(state);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        if (registered.length) {\n\t            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function (state) {\n\t        if (state.abstract || !state.url)\n\t            return;\n\t        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n\t    };\n\t    return StateQueueManager;\n\t}());\n\texports.StateQueueManager = StateQueueManager;\n\t//# sourceMappingURL=stateQueueManager.js.map\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar queue_1 = __webpack_require__(11);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar node_1 = __webpack_require__(21);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar glob_1 = __webpack_require__(10);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Provides state related service functions\n\t *\n\t * This class provides services related to ui-router states.\n\t * An instance of this class is located on the global [[UIRouter]] object.\n\t */\n\tvar StateService = (function () {\n\t    /** @internalapi */\n\t    function StateService(router) {\n\t        this.router = router;\n\t        /** @internalapi */\n\t        this.invalidCallbacks = [];\n\t        /** @hidden */\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error && $error$.stack) {\n\t                console.error($error$);\n\t                console.error($error$.stack);\n\t            }\n\t            else if ($error$ instanceof rejectFactory_1.Rejection) {\n\t                console.error($error$.toString());\n\t                if ($error$.detail && $error$.detail.stack)\n\t                    console.error($error$.detail.stack);\n\t            }\n\t            else {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n\t        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        /**\n\t         * The [[Transition]] currently in progress (or null)\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.transition]]\n\t         */\n\t        get: function () { return this.router.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        /**\n\t         * The latest successful state parameters\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.params]]\n\t         */\n\t        get: function () { return this.router.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        /**\n\t         * The current [[StateDeclaration]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.current]]\n\t         */\n\t        get: function () { return this.router.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        /**\n\t         * The current [[State]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.$current]]\n\t         */\n\t        get: function () { return this.router.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /** @internalapi */\n\t    StateService.prototype.dispose = function () {\n\t        this.defaultErrorHandler(common_1.noop);\n\t        this.invalidCallbacks = [];\n\t    };\n\t    /**\n\t     * Handler for when [[transitionTo]] is called with an invalid state.\n\t     *\n\t     * Invokes the [[onInvalid]] callbacks, in natural order.\n\t     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n\t     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n\t     *\n\t     * @internalapi\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n\t        var _this = this;\n\t        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t        var globals = this.router.globals;\n\t        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n\t        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof targetState_1.TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid())\n\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t            if (latestThing() !== latest)\n\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n\t            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n\t            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * Registers an Invalid State handler\n\t     *\n\t     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n\t     * has been called with an invalid state reference parameter\n\t     *\n\t     * Example:\n\t     * ```js\n\t     * stateService.onInvalid(function(to, from, injector) {\n\t     *   if (to.name() === 'foo') {\n\t     *     let lazyLoader = injector.get('LazyLoadService');\n\t     *     return lazyLoader.load('foo')\n\t     *         .then(() => stateService.target('foo'));\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param {function} callback invoked when the toState is invalid\n\t     *   This function receives the (invalid) toState, the fromState, and an injector.\n\t     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n\t     *   If one is returned, it is treated as a redirect.\n\t     *\n\t     * @returns a function which deregisters the callback\n\t     */\n\t    StateService.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.invalidCallbacks)(callback);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Reloads the current state\n\t     *\n\t     * A method that force reloads the current state, or a partial state hierarchy.\n\t     * All resolves are re-resolved, and components reinstantiated.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * Note: `reload()` is just an alias for:\n\t     *\n\t     * ```js\n\t     * $state.transitionTo($state.current, $state.params, {\n\t     *   reload: true, inherit: false\n\t     * });\n\t     * ```\n\t     *\n\t     * @param reloadState A state name or a state object.\n\t     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Transition to a different state or parameters\n\t     *\n\t     * Convenience method for transitioning to a new state.\n\t     *\n\t     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t     * This allows you to easily use an absolute or relative to path and specify\n\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param to Absolute state name, state object, or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n\t     *\n\t     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n\t     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n\t     *\n\t     *    Parameter inheritance only works between common ancestor states, I.e.\n\t     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     *    will get you all current parameters, etc.\n\t     *\n\t     * @param options Transition options\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * - Possible success values:\n\t     *    - $state.current\n\t     *\n\t     * - Possible rejection reasons:\n\t     *   - transition superseded - when a newer transition has been started after this one\n\t     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n\t     *   - transition failed - when a transition hook errors\n\t     *   - resolve error - when a resolve has errored or rejected\n\t     *\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a [[TargetState]]\n\t     *\n\t     * This is a factory method for creating a TargetState\n\t     *\n\t     * This may be returned from a Transition Hook to redirect a transition, for example.\n\t     */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        var reg = this.router.stateRegistry;\n\t        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = reg.matcher.find(identifier, options.relative);\n\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    ;\n\t    StateService.prototype.getCurrentPath = function () {\n\t        var _this = this;\n\t        var globals = this.router.globals;\n\t        var latestSuccess = globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n\t        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t    };\n\t    /**\n\t     * Low-level method for transitioning to a new state.\n\t     *\n\t     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to State name or state object.\n\t     * @param toParams A map of the parameters that will be sent to the state,\n\t     *      will populate $stateParams.\n\t     * @param options Transition options\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[go]]\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var router = this.router;\n\t        var globals = router.globals;\n\t        var transHistory = globals.transitionHistory;\n\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t        var ref = this.target(to, toParams, options);\n\t        var currentPath = this.getCurrentPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return common_1.silentRejection(ref.error());\n\t        /**\n\t         * Special handling for Ignored, Aborted, and Redirected transitions\n\t         *\n\t         * The semantics for the transition.run() promise and the StateService.transitionTo()\n\t         * promise differ. For instance, the run() promise may be rejected because it was\n\t         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n\t         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n\t         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n\t         */\n\t        var rejectedTransitionHandler = function (transition) { return function (error) {\n\t            if (error instanceof rejectFactory_1.Rejection) {\n\t                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n\t                    router.urlRouter.update();\n\t                    return coreservices_1.services.$q.when(globals.current);\n\t                }\n\t                var detail = error.detail;\n\t                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n\t                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n\t                    // by returning the promise for the new (redirect) `Transition.run()`.\n\t                    var redirect = transition.redirect(detail);\n\t                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n\t                }\n\t                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t                    router.urlRouter.update();\n\t                }\n\t            }\n\t            var errorHandler = _this.defaultErrorHandler();\n\t            errorHandler(error);\n\t            return coreservices_1.services.$q.reject(error);\n\t        }; };\n\t        var transition = this.router.transitionService.create(currentPath, ref);\n\t        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n\t        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return common_1.extend(transitionToPromise, { transition: transition });\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *is* the provided state\n\t     *\n\t     * Similar to [[includes]] but only checks for the full state name.\n\t     * If params is supplied then it will be tested for strict equality against the current\n\t     * active params object, so all params must match with none missing and no extras.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     * ```\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * ```html\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *includes* the provided state\n\t     *\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * #### Example when `$state.$current.name === 'contacts.details.item'`\n\t     * ```js\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     * ```\n\t     *\n\t     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n\t     * ```js\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * ```\n\t     *\n\t     * @param stateOrName A partial name, relative name, glob pattern,\n\t     *   or state object to be searched for within the current state name.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`,\n\t     *   that you'd like to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (!predicates_1.isDefined(include[state.name]))\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Generates a URL for a state and parameters\n\t     *\n\t     * Returns the url for the given state populated with the given params.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param params An object of parameter values to fill the state's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current\n\t        };\n\t        options = common_1.defaults(options, defaultHrefOpts);\n\t        params = params || {};\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t            absolute: options.absolute\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Sets or gets the default [[transitionTo]] error handler.\n\t     *\n\t     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n\t     * This includes errors caused by resolves and transition hooks.\n\t     *\n\t     * Note:\n\t     * This handler does not receive certain Transition rejections.\n\t     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n\t     *\n\t     * The built-in default error handler logs the error to the console.\n\t     *\n\t     * You can provide your own custom handler.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * stateService.defaultErrorHandler(function() {\n\t     *   // Do not log transitionTo errors\n\t     * });\n\t     * ```\n\t     *\n\t     * @param handler a global error handler function\n\t     * @returns the current global error handler\n\t     */\n\t    StateService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        var reg = this.router.stateRegistry;\n\t        if (arguments.length === 0)\n\t            return reg.get();\n\t        return reg.get(stateOrName, base || this.$current);\n\t    };\n\t    /**\n\t     * Lazy loads a state\n\t     *\n\t     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n\t     *\n\t     * @param stateOrName the state that should be lazy loaded\n\t     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n\t     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n\t     * This noop transition is not actually run.\n\t     *\n\t     * @returns a promise to lazy load\n\t     */\n\t    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n\t        var state = this.get(stateOrName);\n\t        if (!state || !state.lazyLoad)\n\t            throw new Error(\"Can not lazy load \" + stateOrName);\n\t        var currentPath = this.getCurrentPath();\n\t        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n\t        transition = transition || this.router.transitionService.create(currentPath, target);\n\t        return lazyLoad_1.lazyLoadState(transition, state);\n\t    };\n\t    return StateService;\n\t}());\n\texports.StateService = StateService;\n\t//# sourceMappingURL=stateService.js.map\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar stateParams_1 = __webpack_require__(50);\n\tvar queue_1 = __webpack_require__(11);\n\tvar common_1 = __webpack_require__(6);\n\t/**\n\t * Global router state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, etc.\n\t */\n\tvar Globals = (function () {\n\t    /** @hidden */\n\t    function Globals(transitionService) {\n\t        var _this = this;\n\t        /** @inheritdoc */\n\t        this.params = new stateParams_1.StateParams();\n\t        /** @internalapi */\n\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t        /** @internalapi */\n\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t        // TODO: This probably belongs in a hooks/globals.ts\n\t        var beforeNewTransition = function ($transition$) {\n\t            _this.transition = $transition$;\n\t            _this.transitionHistory.enqueue($transition$);\n\t            var updateGlobalState = function () {\n\t                _this.successfulTransitions.enqueue($transition$);\n\t                _this.$current = $transition$.$to();\n\t                _this.current = _this.$current.self;\n\t                common_1.copy($transition$.params(), _this.params);\n\t            };\n\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t                _this.transition = null; };\n\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t        };\n\t        transitionService.onBefore({}, beforeNewTransition);\n\t    }\n\t    return Globals;\n\t}());\n\texports.Globals = Globals;\n\t//# sourceMappingURL=globals.js.map\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        common_1.extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return common_1.extend({}, inherited, newParams);\n\t    };\n\t    ;\n\t    return StateParams;\n\t}());\n\texports.StateParams = StateParams;\n\t//# sourceMappingURL=stateParams.js.map\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\t/** @hidden */\n\tvar makeStub = function (keys) {\n\t    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n\t};\n\t/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n\t/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n\t/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n\t/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n\t/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n\t/**\n\t * API for URL management\n\t */\n\tvar UrlService = (function () {\n\t    /** @hidden */\n\t    function UrlService(router, lateBind) {\n\t        if (lateBind === void 0) { lateBind = true; }\n\t        this.router = router;\n\t        this.rules = {};\n\t        this.config = {};\n\t        // proxy function calls from UrlService to the LocationService/LocationConfig\n\t        var locationServices = function () { return router.locationService; };\n\t        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n\t        var locationConfig = function () { return router.locationConfig; };\n\t        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n\t        var umf = function () { return router.urlMatcherFactory; };\n\t        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n\t        var urlRouter = function () { return router.urlRouter; };\n\t        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n\t        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n\t    }\n\t    UrlService.prototype.url = function (newurl, replace, state) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.path = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.search = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.hash = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.onChange = function (callback) { return; };\n\t    ;\n\t    /**\n\t     * Returns the current URL parts\n\t     *\n\t     * This method returns the current URL components as a [[UrlParts]] object.\n\t     *\n\t     * @returns the current url parts\n\t     */\n\t    UrlService.prototype.parts = function () {\n\t        return { path: this.path(), search: this.search(), hash: this.hash() };\n\t    };\n\t    UrlService.prototype.dispose = function () { };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.sync = function (evt) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.listen = function (enabled) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.deferIntercept = function (defer) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.match = function (urlParts) { return; };\n\t    return UrlService;\n\t}());\n\t/** @hidden */\n\tUrlService.locationServiceStub = makeStub(locationServicesFns);\n\t/** @hidden */\n\tUrlService.locationConfigStub = makeStub(locationConfigFns);\n\texports.UrlService = UrlService;\n\t//# sourceMappingURL=urlService.js.map\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(22));\n\t__export(__webpack_require__(31));\n\t__export(__webpack_require__(50));\n\t__export(__webpack_require__(23));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module path */ /** for typedoc */\n\t__export(__webpack_require__(21));\n\t__export(__webpack_require__(24));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module resolve */ /** for typedoc */\n\t__export(__webpack_require__(27));\n\t__export(__webpack_require__(25));\n\t__export(__webpack_require__(26));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(46));\n\t__export(__webpack_require__(34));\n\t__export(__webpack_require__(45));\n\t__export(__webpack_require__(47));\n\t__export(__webpack_require__(44));\n\t__export(__webpack_require__(48));\n\t__export(__webpack_require__(18));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * # Transition subsystem\n\t *\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See:\n\t * - [[TransitionService]]\n\t * - [[Transition]]\n\t * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module transition\n\t */ /** for typedoc */\n\t__export(__webpack_require__(16));\n\t__export(__webpack_require__(20));\n\t__export(__webpack_require__(19));\n\t__export(__webpack_require__(13));\n\t__export(__webpack_require__(14));\n\t__export(__webpack_require__(17));\n\t__export(__webpack_require__(42));\n\t__export(__webpack_require__(35));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(30));\n\t__export(__webpack_require__(29));\n\t__export(__webpack_require__(32));\n\t__export(__webpack_require__(33));\n\t__export(__webpack_require__(51));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(43));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t/**\n\t * # Core classes and interfaces\n\t *\n\t * The classes and interfaces that are core to ui-router and do not belong\n\t * to a more specific subsystem (such as resolve).\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module core\n\t */ /** for typedoc */\n\t\"use strict\";\n\t/** @internalapi */\n\tvar UIRouterPluginBase = (function () {\n\t    function UIRouterPluginBase() {\n\t    }\n\t    UIRouterPluginBase.prototype.dispose = function (router) { };\n\t    return UIRouterPluginBase;\n\t}());\n\texports.UIRouterPluginBase = UIRouterPluginBase;\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MnViewConfig, Resolvable, ResolveContext, ViewService, hasAnyKey, ref, services, viewConfigId;\n\t\n\tref = __webpack_require__(4), services = ref.services, ViewService = ref.ViewService, ResolveContext = ref.ResolveContext, Resolvable = ref.Resolvable;\n\t\n\tviewConfigId = 0;\n\t\n\thasAnyKey = function(keys, obj) {\n\t  return _.reduce(keys, (function(memo, key) {\n\t    return memo || (obj[key] != null);\n\t  }), false);\n\t};\n\t\n\texports.mnViewsBuilder = function(state) {\n\t  var keys, views, viewsObject;\n\t  if (!state.parent) {\n\t    return;\n\t  }\n\t  keys = ['view', 'controller'];\n\t  views = {};\n\t  viewsObject = state.views || {\n\t    $default: _.pick(state, keys)\n\t  };\n\t  _.each(viewsObject, function(config, name) {\n\t    var normalized;\n\t    name = name || '$default';\n\t    config.resolveAs = config.resolveAs || '$resolve';\n\t    config.$type = 'backbone';\n\t    config.$context = state;\n\t    config.$name = name;\n\t    normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n\t    config.$uiViewName = normalized.uiViewName;\n\t    config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t    return views[name] = config;\n\t  });\n\t  return views;\n\t};\n\t\n\texports.MnViewConfig = MnViewConfig = (function() {\n\t  function MnViewConfig(path, viewDecl) {\n\t    this.path = path;\n\t    this.viewDecl = viewDecl;\n\t    this.loaded = true;\n\t    this.$id = viewConfigId++;\n\t  }\n\t\n\t  MnViewConfig.prototype.load = function() {\n\t    return services.$q.when(this);\n\t  };\n\t\n\t  return MnViewConfig;\n\n\t})();\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(62));\n\t//# sourceMappingURL=vanilla.js.map\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * Naive, pure JS implementation of core ui-router services\n\t *\n\t *\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t__export(__webpack_require__(63));\n\t__export(__webpack_require__(64));\n\t__export(__webpack_require__(65));\n\t__export(__webpack_require__(67));\n\t__export(__webpack_require__(68));\n\t__export(__webpack_require__(69));\n\t__export(__webpack_require__(70));\n\t__export(__webpack_require__(71));\n\t__export(__webpack_require__(72));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t/**\n\t * An angular1-like promise api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This API provides native ES6 promise support wrapped as a $q-like API.\n\t * Internally, UI-Router uses this $q object to perform promise operations.\n\t * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n\t *\n\t * $q-like promise api\n\t */\n\texports.$q = {\n\t    /** Normalizes a value as a promise */\n\t    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n\t    /** Normalizes a value as a promise rejection */\n\t    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n\t    /** @returns a deferred object, which has `resolve` and `reject` functions */\n\t    defer: function () {\n\t        var deferred = {};\n\t        deferred.promise = new Promise(function (resolve, reject) {\n\t            deferred.resolve = resolve;\n\t            deferred.reject = reject;\n\t        });\n\t        return deferred;\n\t    },\n\t    /** Like Promise.all(), but also supports object key/promise notation like $q */\n\t    all: function (promises) {\n\t        if (index_1.isArray(promises)) {\n\t            return new Promise(function (resolve, reject) {\n\t                var results = [];\n\t                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n\t                    .then(function () { resolve(results); }, reject);\n\t            });\n\t        }\n\t        if (index_1.isObject(promises)) {\n\t            // Convert promises map to promises array.\n\t            // When each promise resolves, map it to a tuple { key: key, val: val }\n\t            var chain = Object.keys(promises)\n\t                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n\t            // Then wait for all promises to resolve, and convert them back to an object\n\t            return exports.$q.all(chain).then(function (values) {\n\t                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n\t            });\n\t        }\n\t    }\n\t};\n\t//# sourceMappingURL=$q.js.map\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t// globally available injectables\n\tvar globals = {};\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t/**\n\t * A basic angular1-like injector api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This object provides a naive implementation of a globally scoped dependency injection system.\n\t * It supports the following DI approaches:\n\t *\n\t * ### Function parameter names\n\t *\n\t * A function's `.toString()` is called, and the parameter names are parsed.\n\t * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n\t *\n\t * ```js\n\t * function injectedFunction(FooService, BarService) {\n\t *   // FooService and BarService are injected\n\t * }\n\t * ```\n\t *\n\t * ### Function annotation\n\t *\n\t * A function may be annotated with an array of dependency names as the `$inject` property.\n\t *\n\t * ```js\n\t * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n\t * function injectedFunction(fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }\n\t * ```\n\t *\n\t * ### Array notation\n\t *\n\t * An array provides the names of the dependencies to inject (as strings).\n\t * The function is the last element of the array.\n\t *\n\t * ```js\n\t * [ 'FooService', 'BarService', function (fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }]\n\t * ```\n\t *\n\t * @type {$InjectorLike}\n\t */\n\texports.$injector = {\n\t    /** Gets an object from DI based on a string token */\n\t    get: function (name) { return globals[name]; },\n\t    /** Returns true if an object named `name` exists in global DI */\n\t    has: function (name) { return exports.$injector.get(name) != null; },\n\t    /**\n\t     * Injects a function\n\t     *\n\t     * @param fn the function to inject\n\t     * @param context the function's `this` binding\n\t     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n\t     */\n\t    invoke: function (fn, context, locals) {\n\t        var all = index_1.extend({}, globals, locals || {});\n\t        var params = exports.$injector.annotate(fn);\n\t        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n\t        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n\t        if (index_1.isFunction(fn))\n\t            return fn.apply(context, args);\n\t        else\n\t            return fn.slice(-1)[0].apply(context, args);\n\t    },\n\t    /**\n\t     * Returns a function's dependencies\n\t     *\n\t     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n\t     * @return an array of `string`s\n\t     */\n\t    annotate: function (fn) {\n\t        if (!index_1.isInjectable(fn))\n\t            throw new Error(\"Not an injectable function: \" + fn);\n\t        if (fn && fn.$inject)\n\t            return fn.$inject;\n\t        if (index_1.isArray(fn))\n\t            return fn.slice(0, -1);\n\t        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n\t        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\t        return result || [];\n\t    }\n\t};\n\t//# sourceMappingURL=$injector.js.map\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */ /** */\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(66);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A base `LocationServices` */\n\tvar BaseLocationServices = (function () {\n\t    function BaseLocationServices(router, fireAfterUpdate) {\n\t        var _this = this;\n\t        this.fireAfterUpdate = fireAfterUpdate;\n\t        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n\t        this._listeners = [];\n\t        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n\t        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n\t        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n\t        this._location = window && window.location;\n\t        this._history = window && window.history;\n\t    }\n\t    BaseLocationServices.prototype.url = function (url, replace) {\n\t        if (replace === void 0) { replace = true; }\n\t        if (predicates_1.isDefined(url) && url !== this._get()) {\n\t            this._set(null, null, url, replace);\n\t            if (this.fireAfterUpdate) {\n\t                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n\t                this._listeners.forEach(function (cb) { return cb(evt_1); });\n\t            }\n\t        }\n\t        return utils_1.buildUrl(this);\n\t    };\n\t    BaseLocationServices.prototype.onChange = function (cb) {\n\t        var _this = this;\n\t        this._listeners.push(cb);\n\t        return function () { return common_1.removeFrom(_this._listeners, cb); };\n\t    };\n\t    BaseLocationServices.prototype.dispose = function (router) {\n\t        common_1.deregAll(this._listeners);\n\t    };\n\t    return BaseLocationServices;\n\t}());\n\texports.BaseLocationServices = BaseLocationServices;\n\t//# sourceMappingURL=baseLocationService.js.map\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\tvar common_1 = __webpack_require__(6);\n\tvar beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\texports.splitHash = beforeAfterSubstr(\"#\");\n\texports.splitQuery = beforeAfterSubstr(\"?\");\n\texports.splitEqual = beforeAfterSubstr(\"=\");\n\texports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\n\texports.keyValsToObjectR = function (accum, _a) {\n\t    var key = _a[0], val = _a[1];\n\t    if (!accum.hasOwnProperty(key)) {\n\t        accum[key] = val;\n\t    }\n\t    else if (index_1.isArray(accum[key])) {\n\t        accum[key].push(val);\n\t    }\n\t    else {\n\t        accum[key] = [accum[key], val];\n\t    }\n\t    return accum;\n\t};\n\texports.getParams = function (queryString) {\n\t    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n\t};\n\tfunction parseUrl(url) {\n\t    var orEmptyString = function (x) { return x || \"\"; };\n\t    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n\t    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n\t    return { path: path, search: search, hash: hash, url: url };\n\t}\n\texports.parseUrl = parseUrl;\n\texports.buildUrl = function (loc) {\n\t    var path = loc.path();\n\t    var searchObject = loc.search();\n\t    var hash = loc.hash();\n\t    var search = Object.keys(searchObject).map(function (key) {\n\t        var param = searchObject[key];\n\t        var vals = index_1.isArray(param) ? param : [param];\n\t        return vals.map(function (val) { return key + \"=\" + val; });\n\t    }).reduce(common_1.unnestR, []).join(\"&\");\n\t    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n\t};\n\tfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n\t    return function (router) {\n\t        var service = router.locationService = new serviceClass(router);\n\t        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n\t        function dispose(router) {\n\t            router.dispose(service);\n\t            router.dispose(configuration);\n\t        }\n\t        return { name: name, service: service, configuration: configuration, dispose: dispose };\n\t    };\n\t}\n\texports.locationPluginFactory = locationPluginFactory;\n\t//# sourceMappingURL=utils.js.map\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\n\tvar HashLocationService = (function (_super) {\n\t    __extends(HashLocationService, _super);\n\t    function HashLocationService(router) {\n\t        var _this = _super.call(this, router, false) || this;\n\t        window.addEventListener('hashchange', _this._listener, false);\n\t        return _this;\n\t    }\n\t    HashLocationService.prototype._get = function () {\n\t        return utils_1.trimHashVal(this._location.hash);\n\t    };\n\t    HashLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._location.hash = url;\n\t    };\n\t    HashLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener('hashchange', this._listener);\n\t    };\n\t    return HashLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.HashLocationService = HashLocationService;\n\t//# sourceMappingURL=hashLocationService.js.map\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that gets/sets the current location from an in-memory object */\n\tvar MemoryLocationService = (function (_super) {\n\t    __extends(MemoryLocationService, _super);\n\t    function MemoryLocationService(router) {\n\t        return _super.call(this, router, true) || this;\n\t    }\n\t    MemoryLocationService.prototype._get = function () {\n\t        return this._url;\n\t    };\n\t    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._url = url;\n\t    };\n\t    return MemoryLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.MemoryLocationService = MemoryLocationService;\n\t//# sourceMappingURL=memoryLocationService.js.map\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/**\n\t * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n\t *\n\t * Uses `history.pushState` and `history.replaceState`\n\t */\n\tvar PushStateLocationService = (function (_super) {\n\t    __extends(PushStateLocationService, _super);\n\t    function PushStateLocationService(router) {\n\t        var _this = _super.call(this, router, true) || this;\n\t        _this._config = router.urlService.config;\n\t        window.addEventListener(\"popstate\", _this._listener, false);\n\t        return _this;\n\t    }\n\t    ;\n\t    PushStateLocationService.prototype._get = function () {\n\t        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n\t        search = utils_1.splitQuery(search)[1]; // strip ? if found\n\t        hash = utils_1.splitHash(hash)[1]; // strip # if found\n\t        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n\t    };\n\t    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n\t        var _a = this, _config = _a._config, _history = _a._history;\n\t        var fullUrl = _config.baseHref() + url;\n\t        if (replace) {\n\t            _history.replaceState(state, title, fullUrl);\n\t        }\n\t        else {\n\t            _history.pushState(state, title, fullUrl);\n\t        }\n\t    };\n\t    PushStateLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener(\"popstate\", this._listener);\n\t    };\n\t    return PushStateLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.PushStateLocationService = PushStateLocationService;\n\t//# sourceMappingURL=pushStateLocationService.js.map\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\n\tvar MemoryLocationConfig = (function () {\n\t    function MemoryLocationConfig() {\n\t        var _this = this;\n\t        this._baseHref = '';\n\t        this._port = 80;\n\t        this._protocol = \"http\";\n\t        this._host = \"localhost\";\n\t        this._hashPrefix = \"\";\n\t        this.port = function () { return _this._port; };\n\t        this.protocol = function () { return _this._protocol; };\n\t        this.host = function () { return _this._host; };\n\t        this.baseHref = function () { return _this._baseHref; };\n\t        this.html5Mode = function () { return false; };\n\t        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n\t        this.dispose = common_1.noop;\n\t    }\n\t    return MemoryLocationConfig;\n\t}());\n\texports.MemoryLocationConfig = MemoryLocationConfig;\n\t//# sourceMappingURL=memoryLocationConfig.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar predicates_1 = __webpack_require__(7);\n\t/** A `LocationConfig` that delegates to the browser's `location` object */\n\tvar BrowserLocationConfig = (function () {\n\t    function BrowserLocationConfig(router, _isHtml5) {\n\t        if (_isHtml5 === void 0) { _isHtml5 = false; }\n\t        this._isHtml5 = _isHtml5;\n\t        this._baseHref = undefined;\n\t        this._hashPrefix = \"\";\n\t    }\n\t    BrowserLocationConfig.prototype.port = function () {\n\t        return parseInt(location.port);\n\t    };\n\t    BrowserLocationConfig.prototype.protocol = function () {\n\t        return location.protocol;\n\t    };\n\t    BrowserLocationConfig.prototype.host = function () {\n\t        return location.host;\n\t    };\n\t    BrowserLocationConfig.prototype.html5Mode = function () {\n\t        return this._isHtml5;\n\t    };\n\t    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n\t        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n\t    };\n\t    ;\n\t    BrowserLocationConfig.prototype.baseHref = function (href) {\n\t        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n\t    };\n\t    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n\t        var baseTags = document.getElementsByTagName(\"base\");\n\t        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n\t    };\n\t    BrowserLocationConfig.prototype.dispose = function () { };\n\t    return BrowserLocationConfig;\n\t}());\n\texports.BrowserLocationConfig = BrowserLocationConfig;\n\t//# sourceMappingURL=browserLocationConfig.js.map\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar browserLocationConfig_1 = __webpack_require__(71);\n\tvar hashLocationService_1 = __webpack_require__(67);\n\tvar utils_1 = __webpack_require__(66);\n\tvar pushStateLocationService_1 = __webpack_require__(69);\n\tvar memoryLocationService_1 = __webpack_require__(68);\n\tvar memoryLocationConfig_1 = __webpack_require__(70);\n\tvar _injector_1 = __webpack_require__(64);\n\tvar _q_1 = __webpack_require__(63);\n\tvar coreservices_1 = __webpack_require__(9);\n\tfunction servicesPlugin(router) {\n\t    coreservices_1.services.$injector = _injector_1.$injector;\n\t    coreservices_1.services.$q = _q_1.$q;\n\t    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n\t}\n\texports.servicesPlugin = servicesPlugin;\n\t/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\n\texports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\n\texports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\n\texports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n\t//# sourceMappingURL=plugins.js.map\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, ResolveContext, UIViewMarionette, id,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tid = 0;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tResolveContext = __webpack_require__(4).ResolveContext;\n\t\n\texports.UIViewMarionette = UIViewMarionette = (function(superClass) {\n\t  extend(UIViewMarionette, superClass);\n\t\n\t  function UIViewMarionette() {\n\t    return UIViewMarionette.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UIViewMarionette.prototype.initialize = function(router, mnLayout, mnRegion, mnRegionName) {\n\t    var name, parentContext, parentFqn, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n\t    this.router = router;\n\t    this.mnRegion = mnRegion;\n\t    console.log('new uiview ' + mnRegionName);\n\t    this.listenTo(mnLayout, \"before:destroy\", this.destroy);\n\t    name = mnRegionName || '$default';\n\t    parentContext = mnLayout != null ? (ref = mnLayout.parent) != null ? (ref1 = ref.uiView) != null ? (ref2 = ref1.activeUIView.config) != null ? (ref3 = ref2.viewDecl) != null ? ref3.$context : void 0 : void 0 : void 0 : void 0 : void 0;\n\t    parentFqn = mnLayout != null ? (ref4 = mnLayout.parent) != null ? (ref5 = ref4.uiView) != null ? (ref6 = ref5.activeUIView) != null ? ref6.fqn : void 0 : void 0 : void 0 : void 0;\n\t    return this.activeUIView = {\n\t      $type: 'backbone',\n\t      id: id++,\n\t      name: name,\n\t      fqn: parentFqn ? parentFqn + \".\" + name : name,\n\t      creationContext: parentContext || this.router.stateRegistry.root(),\n\t      configUpdated: (function(_this) {\n\t        return function(config) {\n\t          return _this.onConfigUpdated(config);\n\t        };\n\t      })(this),\n\t      config: void 0\n\t    };\n\t  };\n\t\n\t  UIViewMarionette.prototype.register = function() {\n\t    return this.deregister = this.router.viewService.registerUIView(this.activeUIView);\n\t  };\n\t\n\t  UIViewMarionette.prototype.onConfigUpdated = function(newConfig) {\n\t    if (!newConfig) {\n\t      return this.clearPreviousConfig();\n\t    }\n\t    if (newConfig.viewDecl.$type !== 'backbone') {\n\t      return;\n\t    }\n\t    if (this.activeUIView.config === newConfig) {\n\t      return;\n\t    }\n\t    return this.updateView(newConfig);\n\t  };\n\t\n\t  UIViewMarionette.prototype.updateView = function(newConfig) {\n\t    var controller, resolved, view;\n\t    this.activeUIView.config = newConfig;\n\t    resolved = this.getResolved(newConfig);\n\t    view = this.getView(newConfig, {\n\t      resolved: resolved\n\t    });\n\t    controller = this.getController(newConfig, {\n\t      resolved: resolved,\n\t      view: view\n\t    });\n\t    if (view != null) {\n\t      this.mnRegion.show(view);\n\t      if (controller != null) {\n\t        return this.listenToOnce(view, \"destroy\", function() {\n\t          return controller.destroy();\n\t        });\n\t      }\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getResolved = function(config) {\n\t    var context, i, key, keys, len, resolved;\n\t    context = new ResolveContext(config.path);\n\t    resolved = {};\n\t    keys = _.filter(context.getTokens(), function(token) {\n\t      return typeof token === 'string';\n\t    });\n\t    for (i = 0, len = keys.length; i < len; i++) {\n\t      key = keys[i];\n\t      resolved[key] = context.getResolvable(key).data;\n\t    }\n\t    return resolved;\n\t  };\n\t\n\t  UIViewMarionette.prototype.getView = function(config, viewOptions) {\n\t    var ref, view;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.view : void 0 : void 0) != null) {\n\t      return view = new config.viewDecl.view(viewOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getController = function(config, controllerOptions) {\n\t    var ref;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.controller : void 0 : void 0) != null) {\n\t      return new config.viewDecl.controller(controllerOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.clearPreviousConfig = function() {\n\t    var ref;\n\t    this.mnRegion.empty();\n\t    (this.activeUIView.view != null) && ((ref = this.activeUIView.controller) != null ? ref.triggerMethod('view:destroyed') : void 0);\n\t    return this.activeUIView.config = void 0;\n\t  };\n\t\n\t  UIViewMarionette.prototype.onBeforeDestroy = function() {\n\t    return typeof this.deregister === \"function\" ? this.deregister() : void 0;\n\t  };\n\t\n\t  return UIViewMarionette;\n\t\n\t})(Mn.Object);\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UIRouterMarionette, UISref, UISrefActive,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tUIRouterMarionette = __webpack_require__(1).UIRouterMarionette;\n\t\n\texports.UISref = UISref = (function(superClass) {\n\t  extend(UISref, superClass);\n\t\n\t  function UISref() {\n\t    return UISref.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISref.prototype.ui = {\n\t    sref: '[ui-sref]'\n\t  };\n\t\n\t  UISref.prototype.events = {\n\t    'click @ui.ref': 'onClickLink'\n\t  };\n\t\n\t  UISref.prototype.onClickLink = function() {};\n\t\n\t  UISref.prototype.onAttach = function() {\n\t    var router;\n\t    router = UIRouterMarionette.getInstance();\n\t    return this.ui.sref.each(function(i, e) {\n\t      var params, state, url;\n\t      e = $(e);\n\t      state = e.attr('ui-sref');\n\t      try {\n\t        params = JSON.parse(e.attr('ui-sparams'));\n\t      } catch (undefined) {}\n\t      url = router.stateService.href(state, params);\n\t      return e.attr('href', url);\n\t    });\n\t  };\n\t\n\t  return UISref;\n\t\n\t})(Mn.Behavior);\n\t\n\texports.UISrefActive = UISrefActive = (function(superClass) {\n\t  extend(UISrefActive, superClass);\n\t\n\t  function UISrefActive() {\n\t    return UISrefActive.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISrefActive.prototype.ui = {\n\t    active: '[ui-sref-active]'\n\t  };\n\t\n\t  UISrefActive.prototype.defaults = {\n\t    activeClasses: 'ui-state-active'\n\t  };\n\t\n\t  UISrefActive.prototype.initialize = function() {\n\t    this.router = UIRouterMarionette.getInstance();\n\t    return this.deregister = this.router.transitionService.onSuccess({}, (function(_this) {\n\t      return function(transition) {\n\t        return _this.onStateChange();\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onRender = function() {\n\t    return this.onStateChange();\n\t  };\n\t\n\t  UISrefActive.prototype.onStateChange = function() {\n\t    return this.ui.active.each((function(_this) {\n\t      return function(i, el) {\n\t        var $el, classFn, compareState, params;\n\t        $el = $(el);\n\t        params = $el.attr('ui-sparams');\n\t        if (params) {\n\t          params = JSON.parse(params);\n\t        }\n\t        compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref');\n\t        classFn = _this.router.stateService.includes(compareState, params) ? 'addClass' : 'removeClass';\n\t        return $el[classFn](_this.options.activeClasses);\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onBeforeDestroy = function() {\n\t    return this.deregister();\n\t  };\n\t\n\t  UISrefActive.prototype.removeListeners = function() {\n\t    return this.ui.active.off('ui:state:change');\n\t  };\n\t\n\t  return UISrefActive;\n\t\n\t})(Mn.Behavior);\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UILayoutMn2, UIRouterMarionette, UIViewMarionette,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\tUIRouterMarionette = __webpack_require__(3).UIRouterMarionette;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tmodule.exports = UILayoutMn2 = (function(superClass) {\n\t  extend(UILayoutMn2, superClass);\n\t\n\t  function UILayoutMn2() {\n\t    UILayoutMn2.__super__.constructor.apply(this, arguments);\n\t    this.on(\"attach\", this.onAttachUI);\n\t    this.on(\"before:destroy\", this.onBeforeDestroyUI);\n\t  }\n\t\n\t  UILayoutMn2.prototype.regions = {\n\t    \"$default\": \"[ui-view]\"\n\t  };\n\t\n\t  UILayoutMn2.prototype.onAttachUI = function(me, parentRegion) {\n\t    var ref, region, regionName;\n\t    this.parent = parentRegion;\n\t    ref = this.regions;\n\t    for (regionName in ref) {\n\t      if (!hasProp.call(ref, regionName)) continue;\n\t      region = ref[regionName];\n\t      this[regionName].uiView = new UIViewMarionette(UIRouterMarionette.getInstance(), this, this[regionName], regionName);\n\t      this[regionName].uiView.register();\n\t    }\n\t  };\n\t\n\t  UILayoutMn2.prototype.onBeforeDestroyUI = function() {\n\t    return this.parent = null;\n\t  };\n\t\n\t  return UILayoutMn2;\n\t\n\t})(Mn.LayoutView);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ui-router-marionette.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1620402356dec27c4931","_ = require('underscore')\n{\n  $q\n  UIViewMarionette\n  Router\n} = require('./router')\n\n{\n  UISref\n  UISrefActive\n} = require('./marionette/behaviors')\n\nUILayoutMn2 = require('./ui_layout_mn2')\n\n\n_.extend exports, {\n  Router\n  UISref\n  UISrefActive\n  UILayoutMn2\n  UIViewMarionette\n  $q\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}\n// module id = 2\n// module chunks = 0 1","{ UIRouter, $q } = require('ui-router-core')\n{ mnViewsBuilder, MnViewConfig } = require('./state_views_builder')\n{ hashLocationPlugin, servicesPlugin } = require('ui-router-core/lib/vanilla')\n{ UIViewMarionette } = require('./uiview')\n\nrouterInstance = null\n\nviewConfigFactory = (node, config) ->\n  new MnViewConfig(node, config)\n\n\nclass UIRouterMarionette extends UIRouter\n  @getInstance: ->\n    routerInstance or= new @\n\n  constructor: ->\n    super\n    @_started = false\n    @viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory)\n    @plugin(servicesPlugin)\n    @plugin(hashLocationPlugin)\n\n    @stateRegistry.decorator(\"views\", mnViewsBuilder)\n    routerInstance = @\n\n  addState: (def) ->\n    # shortcut for adding a new state definition\n    @stateRegistry.register(def)\n    return @\n\n  start: (@rootRegion, options) ->\n    throw new Error(\"Router was already started\") if @_started\n\n    if options?\n      @handleOptions(options)\n\n    @rootRegion.uiView = new UIViewMarionette(@, null, @rootRegion, \"\")\n    @rootRegion.uiView.register()\n\n    @urlMatcherFactory.$get()\n    @urlService.listen()\n    @urlService.sync()\n    @_started = true\n    return @\n\n  handleOptions: (options) ->\n    if typeof options.onMnRoute is 'function'\n      @onMnRoute(options.onMnRoute)\n\n  onMnRoute: (onRoute) ->\n    oldProcessOnRoute = Marionette.AppRouter::_processOnRoute\n    uiRouter = @\n    Marionette.AppRouter::_processOnRoute = (mnRouteName, mnRouteArgs) ->\n      mnRoutePath = _.invert(this.getOption('appRoutes'))[mnRouteName]\n      onRoute.call(@, mnRouteName, mnRouteArgs, mnRoutePath, uiRouter.stateService)\n      oldProcessOnRoute.call(@, mnRouteName, mnRouteArgs)\n\n\nexports.UIViewMarionette = UIViewMarionette\nexports.Router = UIRouterMarionette\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.coffee","/**\n * @coreapi\n * @module common\n */ /** */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./common/index\"));\n__export(require(\"./params/index\"));\n__export(require(\"./path/index\"));\n__export(require(\"./resolve/index\"));\n__export(require(\"./state/index\"));\n__export(require(\"./transition/index\"));\n__export(require(\"./url/index\"));\n__export(require(\"./view/index\"));\n__export(require(\"./globals\"));\n__export(require(\"./router\"));\n__export(require(\"./interface\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/index.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module common */ /** for typedoc */\n__export(require(\"./common\"));\n__export(require(\"./coreservices\"));\n__export(require(\"./glob\"));\n__export(require(\"./hof\"));\n__export(require(\"./predicates\"));\n__export(require(\"./queue\"));\n__export(require(\"./strings\"));\n__export(require(\"./trace\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/index.js\n// module id = 5\n// module chunks = 0 1","/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar hof_1 = require(\"./hof\");\nvar coreservices_1 = require(\"./coreservices\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = angular.extend || _extend;\nexports.equals = angular.equals || _equals;\nexports.identity = function (x) { return x; };\nexports.noop = function () { return undefined; };\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    if (opts === void 0) { opts = {}; }\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var defaults = merge.apply(null, [{}].concat(defaultsList));\n    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n}\nexports.defaults = defaults;\n/**\n * Merges properties from the list of objects to the destination object.\n * If a property already exists in the destination object, then it is not overwritten.\n */\nfunction merge(dst) {\n    var objs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objs[_i - 1] = arguments[_i];\n    }\n    exports.forEach(objs, function (obj) {\n        exports.forEach(obj, function (value, key) {\n            if (!dst.hasOwnProperty(key))\n                dst[key] = value;\n        });\n    });\n    return dst;\n}\nexports.merge = merge;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\nfunction pickOmitImpl(predicate, obj) {\n    var keys = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        keys[_i - 2] = arguments[_i];\n    }\n    var objCopy = {};\n    for (var key in obj) {\n        if (predicate(keys, key))\n            objCopy[key] = obj[key];\n    }\n    return objCopy;\n}\n/** Return a copy of the object only containing the whitelisted properties. */\nfunction pick(obj) {\n    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n}\nexports.pick = pick;\n/** Return a copy of the object omitting the blacklisted properties. */\nfunction omit(obj) {\n    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var arrayArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrayArgs[_i] = arguments[_i];\n    }\n    if (arrayArgs.length === 0)\n        return [];\n    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _copyProps(to, from) {\n    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n    return to;\n}\nfunction _extend(toObj) {\n    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n}\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function (a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/common.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */ /** */\nvar hof_1 = require(\"./hof\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/predicates.js\n// module id = 7\n// module chunks = 0 1","/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\n\"use strict\";\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/hof.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/coreservices.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** @deprecated whats the point? */\n    Glob.is = function (text) {\n        return text.indexOf('*') > -1;\n    };\n    /** @deprecated whats the point? */\n    Glob.fromString = function (text) {\n        if (!this.is(text))\n            return null;\n        return new Glob(text);\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/glob.js\n// module id = 10\n// module chunks = 0 1","/**\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/queue.js\n// module id = 11\n// module chunks = 0 1","/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar common_1 = require(\"./common\");\nvar hof_1 = require(\"./hof\");\nvar transition_1 = require(\"../transition/transition\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/strings.js\n// module id = 12\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var type = this.type, message = this.message, detail = detailString(this.detail);\n        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isTransitionRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n    };\n    /** Returns a TransitionRejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a TransitionRejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a TransitionRejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a TransitionRejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/rejectFactory.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar hookBuilder_1 = require(\"./hookBuilder\");\nvar node_1 = require(\"../path/node\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar param_1 = require(\"../params/param\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar router_1 = require(\"../router\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /**\n         * Checks if this transition is currently active/running.\n         */\n        this.isActive = function () { return _this === _this._options.current(); };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n        this.applyViewConfigs(router);\n        this.applyRootResolvables(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    Transition.prototype.applyRootResolvables = function (router) {\n        var _this = this;\n        var rootResolvables = [\n            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n        ];\n        var rootNode = this._treeChanges.to[0];\n        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n        context.addResolvables(rootResolvables, rootNode.state);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless  the target state explicitly specifies location)\n        if (this.options().source === 'url') {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.length === 0;\n    };\n    /**\n     * @hidden\n     */\n    Transition.prototype.hookBuilder = function () {\n        return new hookBuilder_1.HookBuilder(this);\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        var hookBuilder = this.hookBuilder();\n        var globals = this.router.globals;\n        globals.transitionHistory.enqueue(this);\n        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n            syncResult.catch(function () { return 0; }); // issue #2676\n            var rejectReason = syncResult._transitionRejection;\n            this._deferred.reject(rejectReason);\n            return this.promise;\n        }\n        if (!this.valid()) {\n            var error = new Error(this.error());\n            this._deferred.reject(error);\n            return this.promise;\n        }\n        if (this.ignored()) {\n            trace_1.trace.traceTransitionIgnored(this);\n            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n            return this.promise;\n        }\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n            runAllHooks(onSuccessHooks);\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n            runAllHooks(onErrorHooks);\n        };\n        trace_1.trace.traceTransitionStart(this);\n        // Chain the next hook off the previous\n        var appendHookToChain = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n        asyncHooks.reduce(appendHookToChain, syncResult)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transition.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"./strings\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/trace.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/interface.js\n// module id = 16\n// module chunks = 0 1","\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.stateService = function () { return _this.transition.router.stateService; };\n        this.rejectIfSuperseded = function () {\n            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n    }\n    TransitionHook.prototype.invokeHook = function () {\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        if (this.rejectIfSuperseded()) {\n            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n        }\n        var cb = hook.callback;\n        var bind = this.options.bind;\n        var trans = this.transition;\n        var state = this.stateContext;\n        var errorHandler = hook.eventType.getErrorHandler(this);\n        var resultHandler = hook.eventType.getResultHandler(this);\n        resultHandler = resultHandler || common_1.identity;\n        if (!errorHandler) {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        try {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        catch (error) {\n            return errorHandler(error);\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.rejectIfSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess the resolved value\n            return result.then(this.handleHookResult.bind(this));\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and start a redirected Transition (to the TargetState).\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n     *\n     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n     */\n    TransitionHook.runOnBeforeHooks = function (hooks) {\n        var results = [];\n        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n            var hook = hooks_1[_i];\n            var hookResult = hook.invokeHook();\n            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n                // Break on first thrown error or false/TargetState\n                return hookResult;\n            }\n            results.push(hookResult);\n        }\n        return results\n            .filter(predicates_1.isPromise)\n            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n    };\n    return TransitionHook;\n}());\nTransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n        return hook.handleHookResult(result);\n    };\n};\nTransitionHook.IGNORE_RESULT = function (hook) {\n    return function (result) { return undefined; };\n};\nTransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n        return (hook.stateService().defaultErrorHandler()(error), undefined);\n    };\n};\nTransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n        return rejectFactory_1.Rejection.errored(error).toPromise();\n    };\n};\nTransitionHook.THROW_ERROR = function (hook) {\n    return undefined;\n};\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionHook.js\n// module id = 17\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/targetState.js\n// module id = 18\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar glob_1 = require(\"../common/glob\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookRegistry.js\n// module id = 19\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n        this.treeChanges = transition.treeChanges();\n        this.transitionOptions = transition.options();\n        this.toState = common_1.tail(this.treeChanges.to).state;\n        this.fromState = common_1.tail(this.treeChanges.from).state;\n        this.$transitions = transition.router.transitionService;\n        this.baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        return this.$transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var _this = this;\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n        if (!matchingHooks)\n            return [];\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(_this.treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, _this.baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookBuilder.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\n/** @module path */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar param_1 = require(\"../params/param\");\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrPath) {\n        if (stateOrPath instanceof PathNode) {\n            var node = stateOrPath;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrPath;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, keys) {\n        var _this = this;\n        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n        var paramValsEq = function (key) {\n            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n        };\n        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    /**\n     * Returns a new path which is a subpath of the first path which matched the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * Nodes are compared using their state property and parameter values.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param ignoreDynamicParams don't compare dynamic parameter values\n     */\n    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n        var matching = [];\n        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n            var a = pathA[i], b = pathB[i];\n            if (a.state !== b.state)\n                break;\n            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n            if (changedParams.length)\n                break;\n            matching.push(a);\n        }\n        return matching;\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=node.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/node.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n    });\n}\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var $$getDefaultValue = function () {\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            return defaultValue;\n        };\n        var $replace = function (val) {\n            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n            return replacement.length ? replacement[0] : val;\n        };\n        value = $replace(value);\n        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/param.js\n// module id = 22\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramType.js\n// module id = 23\n// module chunks = 0 1","/** @module path */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar targetState_1 = require(\"../state/targetState\");\nvar node_1 = require(\"../path/node\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathFactory = (function () {\n    function PathFactory() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathFactory.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathFactory.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathFactory.buildToPath = function (fromPath, targetState) {\n        var toPath = PathFactory.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathFactory.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var staticParams = function (state) {\n            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n        };\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, staticParams(node1.state));\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = node_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathFactory.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathFactory;\n}());\n/** Gets the raw parameter values from a path */\nPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\nexports.PathFactory = PathFactory;\n//# sourceMappingURL=pathFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/pathFactory.js\n// module id = 24\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar trace_1 = require(\"../common/trace\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n                return r.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolvable.js\n// module id = 25\n// module chunks = 0 1","\"use strict\";\n/** @module resolve */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar interface_1 = require(\"./interface\");\nvar resolvable_1 = require(\"./resolvable\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar strings_1 = require(\"../common/strings\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Depenency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolveContext.js\n// module id = 26\n// module chunks = 0 1","\"use strict\";\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/interface.js\n// module id = 27\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = require(\"./url/urlMatcherFactory\");\nvar urlRouter_1 = require(\"./url/urlRouter\");\nvar transitionService_1 = require(\"./transition/transitionService\");\nvar view_1 = require(\"./view/view\");\nvar stateRegistry_1 = require(\"./state/stateRegistry\");\nvar stateService_1 = require(\"./state/stateService\");\nvar globals_1 = require(\"./globals\");\nvar common_1 = require(\"./common/common\");\nvar predicates_1 = require(\"./common/predicates\");\nvar urlService_1 = require(\"./url/urlService\");\nvar trace_1 = require(\"./common/trace\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */\n        this.$id = _routerInstance++;\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.Globals(this.transitionService);\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._disposables = [];\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(this.stateRegistry);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/router.js\n// module id = 28\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar param_1 = require(\"../params/param\");\nvar paramTypes_1 = require(\"../params/paramTypes\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcherFactory.js\n// module id = 29\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar param_1 = require(\"../params/param\");\nvar strings_1 = require(\"../common/strings\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this], parent: null, pattern: null };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        var parent = this._cache.parent;\n        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n            null);\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var _this = this;\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        return common_1.pairs(params || {}).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return validParamVal(_this.parameter(key), val);\n        }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        if (!this.validates(values))\n            return null;\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n        /**\n         * Given a Param,\n         * Applies the parameter value, then returns details about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a Param.  Fetch details about the parameter value\n            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (param) {\n            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        var splitOnSlash = strings_1.splitOnDelim('/');\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         */\n        var segments = function (matcher) {\n            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                .reduce(common_1.unnestR, [])\n                .reduce(strings_1.joinNeighborsR, [])\n                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                .reduce(common_1.unnestR, []);\n        };\n        var aSegments = segments(a), bSegments = segments(b);\n        // console.table( { aSegments, bSegments });\n        // Sort slashes first, then static strings, the Params\n        var weight = hof_1.pattern([\n            [hof_1.eq(\"/\"), hof_1.val(1)],\n            [predicates_1.isString, hof_1.val(2)],\n            [hof_1.is(param_1.Param), hof_1.val(3)]\n        ]);\n        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n        // console.table(pairs);\n        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcher.js\n// module id = 30\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramTypes.js\n// module id = 31\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar hof_1 = require(\"../common/hof\");\nvar urlRule_1 = require(\"./urlRule\");\nvar targetState_1 = require(\"../state/targetState\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash()\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        if (!urlMatcher.validates(params))\n            return null;\n        var url = urlMatcher.format(params);\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this.sort();\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n        this.sort();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n        }\n        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this.sort();\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\n//# sourceMappingURL=urlRouter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRouter.js\n// module id = 32\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar stateObject_1 = require(\"../state/stateObject\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[State]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRule.js\n// module id = 33\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar State = (function () {\n    function State(config) {\n        common_1.extend(this, config);\n        // Object.freeze(this);\n    }\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    State.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    State.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    State.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param`eters\n     *\n     * Gets [[Param]] information that is owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    State.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    State.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    State.prototype.toString = function () {\n        return this.fqn();\n    };\n    return State;\n}());\nexports.State = State;\n//# sourceMappingURL=stateObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateObject.js\n// module id = 34\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar transition_1 = require(\"./transition\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar resolve_1 = require(\"../hooks/resolve\");\nvar views_1 = require(\"../hooks/views\");\nvar url_1 = require(\"../hooks/url\");\nvar redirectTo_1 = require(\"../hooks/redirectTo\");\nvar onEnterExitRetain_1 = require(\"../hooks/onEnterExitRetain\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar transitionEventType_1 = require(\"./transitionEventType\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineDefaultPaths();\n        this._defineDefaultEvents();\n        this._registerDefaultTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        delete router.globals.transition;\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultPaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionService.js\n// module id = 35\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state)\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/resolve.js\n// module id = 36\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/views.js\n// module id = 37\n// module chunks = 0 1","\"use strict\";\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/url.js\n// module id = 38\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** */\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar targetState_1 = require(\"../state/targetState\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/redirectTo.js\n// module id = 39\n// module chunks = 0 1","\"use strict\";\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var hookFn = state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/onEnterExitRetain.js\n// module id = 40\n// module chunks = 0 1","\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/lazyLoad.js\n// module id = 41\n// module chunks = 0 1","\"use strict\";\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.rejectIfSuperseded = rejectIfSuperseded;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionEventType.js\n// module id = 42\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar trace_1 = require(\"../common/trace\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return the number of dots in the fully qualified name\n        function uiViewDepth(uiView) {\n            return uiView.fqn.split(\".\").length;\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/view.js\n// module id = 43\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar stateMatcher_1 = require(\"./stateMatcher\");\nvar stateBuilder_1 = require(\"./stateBuilder\");\nvar stateQueueManager_1 = require(\"./stateQueueManager\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[State]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[State]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {State[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateRegistry.js\n// module id = 44\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar predicates_1 = require(\"../common/predicates\");\nvar glob_1 = require(\"../common/glob\");\nvar common_1 = require(\"../common/common\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base) {\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr) {\n            var matches = common_1.values(this._states)\n                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateMatcher.js\n// module id = 45\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[State]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[State]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent))\n            return null;\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateBuilder.js\n// module id = 46\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar stateObject_1 = require(\"./stateObject\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (config) {\n        var _a = this, states = _a.states, queue = _a.queue;\n        // Wrap a new object around the state so we can store our private details easily.\n        // @TODO: state = new State(extend({}, config, { ... }))\n        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n            self: config,\n            resolve: config.resolve || [],\n            toString: function () { return config.name; }\n        }));\n        if (!predicates_1.isString(state.name))\n            throw new Error(\"State must have a valid name\");\n        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n            throw new Error(\"State '\" + state.name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = this.$registry.get(state.name);\n                if (existingState && existingState.name === state.name) {\n                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n                }\n                if (existingState && existingState.name === state.name + \".**\") {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingState);\n                }\n                states[state.name] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[state.name];\n            previousQueueLength[state.name] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateQueueManager.js\n// module id = 47\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar queue_1 = require(\"../common/queue\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar node_1 = require(\"../path/node\");\nvar transitionService_1 = require(\"../transition/transitionService\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar targetState_1 = require(\"./targetState\");\nvar param_1 = require(\"../params/param\");\nvar glob_1 = require(\"../common/glob\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[State]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid())\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            if (latestThing() !== latest)\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false\n        });\n    };\n    ;\n    /**\n     * Transition to a different state or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n     * This allows you to easily use an absolute or relative to path and specify\n     * only the parameters you'd like to update (while letting unspecified parameters\n     * inherit from the currently active ancestor states).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     *\n     * @param to Absolute state name, state object, or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n     *\n     *    Parameter inheritance only works between common ancestor states, I.e.\n     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     *    will get you all current parameters, etc.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * - Possible success values:\n     *    - $state.current\n     *\n     * - Possible rejection reasons:\n     *   - transition superseded - when a newer transition has been started after this one\n     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n     *   - transition failed - when a transition hook errors\n     *   - resolve error - when a resolve has errored or rejected\n     *\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        var transHistory = globals.transitionHistory;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    router.urlRouter.update();\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    router.urlRouter.update();\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n            absolute: options.absolute\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateService.js\n// module id = 48\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = require(\"./params/stateParams\");\nvar queue_1 = require(\"./common/queue\");\nvar common_1 = require(\"./common/common\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar Globals = (function () {\n    /** @hidden */\n    function Globals(transitionService) {\n        var _this = this;\n        /** @inheritdoc */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n        // TODO: This probably belongs in a hooks/globals.ts\n        var beforeNewTransition = function ($transition$) {\n            _this.transition = $transition$;\n            _this.transitionHistory.enqueue($transition$);\n            var updateGlobalState = function () {\n                _this.successfulTransitions.enqueue($transition$);\n                _this.$current = $transition$.$to();\n                _this.current = _this.$current.self;\n                common_1.copy($transition$.params(), _this.params);\n            };\n            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n                _this.transition = null; };\n            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n        };\n        transitionService.onBefore({}, beforeNewTransition);\n    }\n    return Globals;\n}());\nexports.Globals = Globals;\n//# sourceMappingURL=globals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/globals.js\n// module id = 49\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/stateParams.js\n// module id = 50\n// module chunks = 0 1","/**\n * @coreapi\n * @module url\n */ /** */\n\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlService.js\n// module id = 51\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./param\"));\n__export(require(\"./paramTypes\"));\n__export(require(\"./stateParams\"));\n__export(require(\"./paramType\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/index.js\n// module id = 52\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module path */ /** for typedoc */\n__export(require(\"./node\"));\n__export(require(\"./pathFactory\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/index.js\n// module id = 53\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module resolve */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./resolvable\"));\n__export(require(\"./resolveContext\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/index.js\n// module id = 54\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./stateBuilder\"));\n__export(require(\"./stateObject\"));\n__export(require(\"./stateMatcher\"));\n__export(require(\"./stateQueueManager\"));\n__export(require(\"./stateRegistry\"));\n__export(require(\"./stateService\"));\n__export(require(\"./targetState\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/index.js\n// module id = 55\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./hookBuilder\"));\n__export(require(\"./hookRegistry\"));\n__export(require(\"./rejectFactory\"));\n__export(require(\"./transition\"));\n__export(require(\"./transitionHook\"));\n__export(require(\"./transitionEventType\"));\n__export(require(\"./transitionService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/index.js\n// module id = 56\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./urlMatcher\"));\n__export(require(\"./urlMatcherFactory\"));\n__export(require(\"./urlRouter\"));\n__export(require(\"./urlRule\"));\n__export(require(\"./urlService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/index.js\n// module id = 57\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./view\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/index.js\n// module id = 58\n// module chunks = 0 1","/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\n\"use strict\";\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/interface.js\n// module id = 59\n// module chunks = 0 1","# state->view logic specific to backbone (marionette)\n# ref: ui-router-ng1/statebuilders/views.ts\n\n# guess there's some missing magic here\n\n{ services, ViewService, ResolveContext, Resolvable } = require('ui-router-core')\n# AppLayout = require('javascripts/lib/views/layout')\nviewConfigId = 0\n\nhasAnyKey = (keys, obj) ->\n  # unused, copied from ui-router for ng1\n  _.reduce keys, ((memo, key) -> memo or obj[key]?), false\n\n\n\nexports.mnViewsBuilder = (state) ->\n  return if not state.parent\n\n  keys = ['view', 'controller']\n\n  views = {}\n  viewsObject = state.views or {$default: _.pick(state, keys)}\n\n  _.each viewsObject, (config, name) ->\n    name = name or '$default'\n\n    config.resolveAs = config.resolveAs or '$resolve'\n    config.$type = 'backbone'\n    config.$context = state\n    config.$name = name\n\n    normalized = ViewService.normalizeUIViewTarget config.$context, config.$name\n    config.$uiViewName = normalized.uiViewName\n    config.$uiViewContextAnchor = normalized.uiViewContextAnchor\n    views[name] = config\n\n  return views\n\n\n\nexports.MnViewConfig = class MnViewConfig\n  constructor: (@path, @viewDecl) ->\n    @loaded = true\n    @$id = viewConfigId++\n\n  load: ->\n    services.$q.when(@)\n\n\n\n// WEBPACK FOOTER //\n// ./src/state_views_builder.coffee","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./vanilla/index\"));\n//# sourceMappingURL=vanilla.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla.js\n// module id = 61\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * Naive, pure JS implementation of core ui-router services\n *\n *\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(require(\"./$q\"));\n__export(require(\"./$injector\"));\n__export(require(\"./baseLocationService\"));\n__export(require(\"./hashLocationService\"));\n__export(require(\"./memoryLocationService\"));\n__export(require(\"./pushStateLocationService\"));\n__export(require(\"./memoryLocationConfig\"));\n__export(require(\"./browserLocationConfig\"));\n__export(require(\"./plugins\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/index.js\n// module id = 62\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return new Promise(function (resolve, reject) {\n                var results = [];\n                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n                    .then(function () { resolve(results); }, reject);\n            });\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=$q.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$q.js\n// module id = 63\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=$injector.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$injector.js\n// module id = 64\n// module chunks = 0 1","/**\n * @internalapi\n * @module vanilla\n */ /** */\n\"use strict\";\nvar utils_1 = require(\"./utils\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/baseLocationService.js\n// module id = 65\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\nvar common_1 = require(\"../common/common\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/utils.js\n// module id = 66\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/hashLocationService.js\n// module id = 67\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationService.js\n// module id = 68\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/pushStateLocationService.js\n// module id = 69\n// module chunks = 0 1","\"use strict\";\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationConfig.js\n// module id = 70\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = require(\"../common/predicates\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        return parseInt(location.port);\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol;\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/browserLocationConfig.js\n// module id = 71\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = require(\"./browserLocationConfig\");\nvar hashLocationService_1 = require(\"./hashLocationService\");\nvar utils_1 = require(\"./utils\");\nvar pushStateLocationService_1 = require(\"./pushStateLocationService\");\nvar memoryLocationService_1 = require(\"./memoryLocationService\");\nvar memoryLocationConfig_1 = require(\"./memoryLocationConfig\");\nvar _injector_1 = require(\"./$injector\");\nvar _q_1 = require(\"./$q\");\nvar coreservices_1 = require(\"../common/coreservices\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = _injector_1.$injector;\n    coreservices_1.services.$q = _q_1.$q;\n    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/plugins.js\n// module id = 72\n// module chunks = 0 1","id = 0\nMn = require('backbone.marionette')\n{ ResolveContext } = require('ui-router-core')\n\n\n\nexports.UIViewMarionette = class UIViewMarionette extends Mn.Object\n  # Side note:\n  # If Marionette provided a way to use custom Region subclasses on a per-View\n  # basis I could register ui-views directly in the Region constructor instead\n  # of having this separate UIViewMarionette class and a custom\n  # LayoutView subclass, but I don't want to do that globally and attempt to\n  # register regions that aren't going to be managed by ui-router.\n\n  initialize: (@router, mnLayout, @mnRegion, mnRegionName) ->\n    console.log 'new uiview ' + mnRegionName\n    # Leverage Marionette's view lifecycle to know when to unregister\n    # the ui-view\n    @listenTo mnLayout, \"before:destroy\", @destroy\n\n    # Except for the top-level region passed to router.start(), a name should\n    # always be provided (even if it is '$default')\n    name = mnRegionName || '$default'\n    # TBH I'm not entirely sure what the context is for.\n    parentContext = mnLayout?.parent?.uiView?.activeUIView.config?.viewDecl?.$context\n    # nested FQNs will end up as something like\n    # '$default.$default.myNamedUIView.$default'\n    parentFqn = mnLayout?.parent?.uiView?.activeUIView?.fqn\n\n    @activeUIView =\n      $type: 'backbone'\n      id: id++\n      name: name\n      fqn: if parentFqn then \"#{parentFqn}.#{name}\" else name\n      creationContext: parentContext || @router.stateRegistry.root()\n      configUpdated: (config) => @onConfigUpdated(config)\n      config: undefined\n\n  register: ->\n    @deregister = @router.viewService.registerUIView(@activeUIView)\n\n  onConfigUpdated: (newConfig) ->\n    # If no config was provided (which happens right after registering this view\n    # or or when entering a state that has nothing to put in this slot), we want\n    # to make sure that the ui-view element is empty.\n    return @clearPreviousConfig() if not newConfig\n\n    # We somehow got a config for a different framework's ui-router integration\n    # (I imagine this is mainly an angular 1 to 2 migration thing?)\n    return if newConfig.viewDecl.$type isnt 'backbone'\n\n    # Got the currently active view config again.\n    return if @activeUIView.config is newConfig\n\n    @updateView(newConfig)\n\n  updateView: (newConfig) ->\n    @activeUIView.config = newConfig\n\n    # Create view and controller instances if they were specified in the\n    # state config.\n    resolved = @getResolved(newConfig)\n    view = @getView(newConfig, resolved: resolved)\n    controller = @getController(newConfig, resolved: resolved, view: view)\n\n    if view?\n      @mnRegion.show view\n      if controller?\n        @listenToOnce view, \"destroy\", ->\n          controller.destroy()\n\n  getResolved: (config) ->\n    # Map all resolved objects (plus $stateParams and $transition$)\n    # to a plain object to pass to the view and controller\n    context = new ResolveContext(config.path)\n    resolved = {}\n    keys = _.filter context.getTokens(), (token) -> typeof token is 'string'\n    resolved[key] = context.getResolvable(key).data for key in keys\n\n    return resolved\n\n  getView: (config, viewOptions) ->\n    if config?.viewDecl?.view?\n      view = new config.viewDecl.view(viewOptions)\n\n  getController: (config, controllerOptions) ->\n    if config?.viewDecl?.controller?\n      return new config.viewDecl.controller(controllerOptions)\n\n  clearPreviousConfig: ->\n    @mnRegion.empty()\n    @activeUIView.view? && @activeUIView.controller?.triggerMethod('view:destroyed')\n    @activeUIView.config = undefined\n\n  onBeforeDestroy: ->\n    @deregister?()\n\n\n\n// WEBPACK FOOTER //\n// ./src/uiview.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}\n// module id = 74\n// module chunks = 0 1","Mn = require('backbone.marionette')\n{ UIRouterMarionette } = require('../index')\n\n\n# A helper behavior for linking to states with or without state parameters.\n# Element attributes:\n#   ui-sref=\"app.state.substate\"\n#   ui-sparams='{\"client_id\": 5}' - optional if state doesn't need params or\n#                                   you're linking to a sibling/child state\n#                                   with the same parameters.\n#                                   The value should be HTML-encoded JSON.\n#                                   A template helper method is helpful here.\n# Behavior options: none\n#\nexports.UISref = class UISref extends Mn.Behavior\n  ui:\n    sref: '[ui-sref]'\n\n  events:\n    'click @ui.ref': 'onClickLink'\n\n  onClickLink: ->\n    # maybe parse and navigate to state if this element was inserted after\n    # original dom insertion (through data binding or whatever)\n\n  onAttach: ->\n    # Go through all the ui-sref links and turn their ui-sref and HTML-escaped\n    # ui-sparams attributes into a functioning app state link\n    router = UIRouterMarionette.getInstance()\n    @ui.sref.each (i, e) ->\n      e = $(e)\n      state = e.attr('ui-sref')\n      try\n        params = JSON.parse(e.attr 'ui-sparams')\n      url = router.stateService.href(state, params)\n\n      e.attr('href', url)\n\n\n\n# A behavior to toggle CSS classes on an element when a particular state\n# (with or without specific state parameters) is active.\n# Targets elements with a ui-sref-active attribute.\n# ui-sref-active can optionally have a value selecting the specific state\n# you want to watch for. If no value is provided, it will look to the state\n# referenced by ui-sref.\n# To help with lists that point at the same state with different state params,\n# the behavior will also compare the contents of ui-sparams, if present.\n# The default class is 'ui-state-active' but this can be customized in the\n# behavior options:\n# class MyView extends Marionette.ItemView\n#   behaviors:\n#     UISref: {}\n#     UISrefActive: {activeClasses: 'state-is-active'}\n#\nexports.UISrefActive = class UISrefActive extends Mn.Behavior\n  ui:\n    active: '[ui-sref-active]'\n\n  defaults:\n    activeClasses: 'ui-state-active'\n\n  initialize: ->\n    @router = UIRouterMarionette.getInstance()\n    @deregister = @router.transitionService.onSuccess {}, (transition) => @onStateChange()\n\n  onRender: ->\n    @onStateChange()\n\n  onStateChange: ->\n    @ui.active.each (i, el) =>\n      $el = $(el)\n      params = $el.attr('ui-sparams')\n      if params\n        params = JSON.parse(params)\n      compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref') # fall back to the state in ui-sref if the ui-sref-active attribute is present but empty\n      classFn = if @router.stateService.includes(compareState, params) then 'addClass' else 'removeClass'\n      $el[classFn](@options.activeClasses)\n\n  onBeforeDestroy: ->\n    @deregister()\n\n  removeListeners: ->\n    @ui.active.off('ui:state:change')\n\n\n\n// WEBPACK FOOTER //\n// ./src/marionette/behaviors.coffee","{ UIViewMarionette } = require('./uiview')\n{ UIRouterMarionette } = require('./router')\nMn = require('backbone.marionette')\n# A layout view for Marionette 2.x apps.\n# When the regions are created they also get registered as UIViews.\nmodule.exports = class UILayoutMn2 extends Mn.LayoutView\n  constructor: ->\n    super\n\n    @on \"attach\", @onAttachUI\n\n    @on \"before:destroy\", @onBeforeDestroyUI\n\n  regions:\n    # Register the first element with a ui-view attribute as the\n    # default region and UIView.\n    \"$default\": \"[ui-view]\"\n\n  onAttachUI: (me, parentRegion) ->\n    @parent = parentRegion\n    for own regionName, region of @regions\n      @[regionName].uiView = new UIViewMarionette UIRouterMarionette.getInstance(), @, @[regionName], regionName\n      @[regionName].uiView.register()\n    return\n\n  onBeforeDestroyUI: ->\n    @parent = null\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui_layout_mn2.coffee"],"sourceRoot":""}