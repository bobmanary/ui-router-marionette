{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///ui-router-marionette.min.js","webpack:///webpack/bootstrap 862003ef0328f95c200a?118b","webpack:///./src/index.coffee?3d3c","webpack:///external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}?8e93","webpack:///./src/router.coffee?5584","webpack:///./~/ui-router-core/lib/index.js?eb25","webpack:///./~/ui-router-core/lib/common/index.js?0a2c","webpack:///./~/ui-router-core/lib/common/common.js?cf4d","webpack:///./~/ui-router-core/lib/common/predicates.js?d043","webpack:///./~/ui-router-core/lib/common/hof.js?f100","webpack:///./~/ui-router-core/lib/common/coreservices.js?cdcd","webpack:///./~/ui-router-core/lib/common/glob.js?6b30","webpack:///./~/ui-router-core/lib/common/queue.js?d4a0","webpack:///./~/ui-router-core/lib/common/strings.js?311e","webpack:///./~/ui-router-core/lib/transition/rejectFactory.js?f278","webpack:///./~/ui-router-core/lib/transition/transition.js?cb73","webpack:///./~/ui-router-core/lib/common/trace.js?439e","webpack:///./~/ui-router-core/lib/transition/interface.js?90d0","webpack:///./~/ui-router-core/lib/transition/transitionHook.js?f358","webpack:///./~/ui-router-core/lib/state/targetState.js?a35d","webpack:///./~/ui-router-core/lib/transition/hookRegistry.js?e1c9","webpack:///./~/ui-router-core/lib/transition/hookBuilder.js?a5b9","webpack:///./~/ui-router-core/lib/path/node.js?8b12","webpack:///./~/ui-router-core/lib/params/param.js?ed16","webpack:///./~/ui-router-core/lib/params/paramType.js?33d4","webpack:///./~/ui-router-core/lib/path/pathFactory.js?a7a1","webpack:///./~/ui-router-core/lib/resolve/resolvable.js?1f09","webpack:///./~/ui-router-core/lib/resolve/resolveContext.js?1544","webpack:///./~/ui-router-core/lib/resolve/interface.js?a665","webpack:///./~/ui-router-core/lib/router.js?8102","webpack:///./~/ui-router-core/lib/url/urlMatcherFactory.js?891b","webpack:///./~/ui-router-core/lib/url/urlMatcher.js?d438","webpack:///./~/ui-router-core/lib/params/paramTypes.js?9d59","webpack:///./~/ui-router-core/lib/url/urlRouter.js?3a6c","webpack:///./~/ui-router-core/lib/url/urlRule.js?c28b","webpack:///./~/ui-router-core/lib/state/stateObject.js?c26a","webpack:///./~/ui-router-core/lib/transition/transitionService.js?3f7a","webpack:///./~/ui-router-core/lib/hooks/resolve.js?2c64","webpack:///./~/ui-router-core/lib/hooks/views.js?e195","webpack:///./~/ui-router-core/lib/hooks/url.js?b25f","webpack:///./~/ui-router-core/lib/hooks/redirectTo.js?5ea3","webpack:///./~/ui-router-core/lib/hooks/onEnterExitRetain.js?34a6","webpack:///./~/ui-router-core/lib/hooks/lazyLoad.js?7404","webpack:///./~/ui-router-core/lib/transition/transitionEventType.js?45f4","webpack:///./~/ui-router-core/lib/view/view.js?9313","webpack:///./~/ui-router-core/lib/state/stateRegistry.js?6ad5","webpack:///./~/ui-router-core/lib/state/stateMatcher.js?30f3","webpack:///./~/ui-router-core/lib/state/stateBuilder.js?a704","webpack:///./~/ui-router-core/lib/state/stateQueueManager.js?a439","webpack:///./~/ui-router-core/lib/state/stateService.js?0391","webpack:///./~/ui-router-core/lib/globals.js?0b2e","webpack:///./~/ui-router-core/lib/params/stateParams.js?da15","webpack:///./~/ui-router-core/lib/url/urlService.js?242b","webpack:///./~/ui-router-core/lib/params/index.js?06e6","webpack:///./~/ui-router-core/lib/path/index.js?c60f","webpack:///./~/ui-router-core/lib/resolve/index.js?785f","webpack:///./~/ui-router-core/lib/state/index.js?f8ea","webpack:///./~/ui-router-core/lib/transition/index.js?5aa5","webpack:///./~/ui-router-core/lib/url/index.js?33c0","webpack:///./~/ui-router-core/lib/view/index.js?03f5","webpack:///./~/ui-router-core/lib/interface.js?70a6","webpack:///./src/state_views_builder.coffee?56f9","webpack:///./~/ui-router-core/lib/vanilla.js?67d6","webpack:///./~/ui-router-core/lib/vanilla/index.js?6019","webpack:///./~/ui-router-core/lib/vanilla/$q.js?b905","webpack:///./~/ui-router-core/lib/vanilla/$injector.js?e177","webpack:///./~/ui-router-core/lib/vanilla/baseLocationService.js?6a47","webpack:///./~/ui-router-core/lib/vanilla/utils.js?762f","webpack:///./~/ui-router-core/lib/vanilla/hashLocationService.js?8c71","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationService.js?f52a","webpack:///./~/ui-router-core/lib/vanilla/pushStateLocationService.js?25c4","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationConfig.js?ea76","webpack:///./~/ui-router-core/lib/vanilla/browserLocationConfig.js?3d33","webpack:///./~/ui-router-core/lib/vanilla/plugins.js?4ce6","webpack:///./src/uiview.coffee?2999","webpack:///external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}?4413","webpack:///./src/marionette/behaviors.coffee?4f4a","webpack:///./src/ui_layout_mn2.coffee?372c"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_74__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","$q","Router","UILayoutMn2","UISref","UISrefActive","UIViewMarionette","_","ref","ref1","extend","MnViewConfig","UIRouter","UIRouterMarionette","hashLocationPlugin","mnViewsBuilder","ref2","routerInstance","servicesPlugin","viewConfigFactory","child","parent","ctor","constructor","key","hasProp","prototype","__super__","hasOwnProperty","node","config","superClass","apply","arguments","_started","viewService","_pluginapi","_viewConfigFactory","plugin","stateRegistry","decorator","getInstance","start","rootRegion","options","Error","handleOptions","uiView","register","urlMatcherFactory","$get","urlService","listen","sync","onMnRoute","onRoute","oldProcessOnRoute","uiRouter","Marionette","AppRouter","_processOnRoute","mnRouteName","mnRouteArgs","mnRoutePath","invert","getOption","stateService","__export","createProxyFunctions","source","target","bind","fnNames","latebind","bindFunction","fnName","makeLateRebindFn","Object","keys","reduce","acc","name","_inArray","array","obj","indexOf","_removeFrom","idx","splice","_pushTo","arr","val","push","defaults","opts","defaultsList","_i","length","merge","concat","pick","dst","objs","forEach","value","ancestors","first","second","path","n","pickOmitImpl","predicate","objCopy","inArray","restArgs","omit","notInArray","item","pluck","collection","propName","map","hof_1","prop","filter","callback","predicates_1","isArray","result","accept","x","i","find","pushR","assertFn","predicateOrMap","errMsg","isFunction","arrayTuples","arrayArgs","min","Math","Array","ignored","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_copyProps","to","from","_extend","toObj","identity","_equals","o1","o2","t1","t2","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","predicates","any","b","fn","a1","a2","t","coreservices_1","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","equals","noop","inherit","extra","args","slice","curry","removeFrom","pushTo","deregAll","functions","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","uniqR","token","unnest","flatten","assertPredicate","assertMap","pairs","sortBy","propFn","checkFn","a","composeSort","sortFns","prev","silenceUncaughtInPromise","promise","catch","e","silentRejection","error","services","reject","isInjectable","head","not","toStr","tis","isUndefined","isDefined","isNull","o","isNullOrUndefined","or","isNumber","isObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","funcs","reverse","fn1","fn2","invoke","pattern","struct","propEq","split","is","eq","other","v","notImplemented","fnname","$injector","Glob","text","glob","regexpString","seg","join","regexp","RegExp","matches","test","fromString","Queue","_items","_limit","enqueue","items","shift","dequeue","size","clear","current","remove","peekTail","peekHead","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","splitOnDelim","delim","re","common_1","joinNeighborsR","rejectFactory_1","transition_1","resolvable_1","stringifyPatternFn","isTransitionRejectionPromise","Rejection","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","RejectType","strings_1","type","message","detail","detailString","d","toPromise","then","superseded","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","errored","ERROR","trace_1","interface_1","transitionHook_1","hookRegistry_1","hookBuilder_1","node_1","pathFactory_1","targetState_1","param_1","resolveContext_1","router_1","stateSelf","fromPath","targetState","router","_deferred","defer","_registeredHooks","isActive","_options","_targetState","valid","$id","transitionService","_transitionCount","toPath","PathFactory","buildToPath","_treeChanges","treeChanges","reloadState","createTransitionHookRegFns","onCreateHooks","hookBuilder","buildHooksForPhase","TransitionHookPhase","CREATE","TransitionHook","runAllHooks","applyViewConfigs","applyRootResolvables","onBefore","criteria","onStart","onExit","onRetain","onEnter","onFinish","onSuccess","onError","_getEvents","hookPhase","makeEvent","getHooks","hookName","enteringStates","entering","state","$view","rootResolvables","params","rootNode","context","ResolveContext","addResolvables","$from","$to","self","compare","matchState","pathname","freeze","injector","pathName","subPath","getResolveTokens","getTokens","addResolvable","resolvable","stateName","topath","targetNode","resolveContext","redirectedFrom","originalTransition","rf","exiting","retained","views","redirect","redirects","trans","redirectOpts","location","newOptions","TargetState","identifier","$state","newTransition","create","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","includes","matchingEnteringNodes","PathNode","matching","resolvables","_changedParams","tc","reload","pathsDiffer","tuple","nodeSchemas","paramSchema","_a","paramValues","toValues","fromValues","tuples","schema","toVals","fromVals","Param","changed","dynamic","changes","HookBuilder","run","globals","transitionHistory","onBeforeHooks","BEFORE","syncResult","runOnBeforeHooks","rejectReason","trace","traceTransitionIgnored","transitionSuccess","traceSuccess","success","resolve","onSuccessHooks","SUCCESS","transitionError","reason","traceError","_error","onErrorHooks","traceTransitionStart","appendHookToChain","nextHook","invokeHook","asyncHooks","ASYNC","abstract","validates","parameters","fromStateOrName","toStateOrName","avoidEmptyHash","fromParams","toValid","toParams","diToken","uiViewString","viewData","creationContext","fqn","normalizedCat","input","Category","viewConfigString","viewConfig","viewDecl","$context","$uiViewName","$uiViewContextAnchor","Trace","_enabled","approximateDigests","_set","enabled","categories","k","parseInt","isNaN","category","enable","disable","TRANSITION","tid","transitionStr","console","log","traceHookInvocation","step","HOOK","event","registeredHook","traceHookResult","hookResult","transitionOptions","hookResultStr","traceResolvePath","when","RESOLVE","pathStr","traceResolvableResolved","resolvableStr","data","finalState","traceUIViewEvent","UIVIEW","traceUIViewConfigUpdated","traceUIViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUIViewEvent","TransitionHookScope","defaultOptions","transition","traceData","stateContext","rejectIfSuperseded","eventType","hook","_deregistered","errorHandler","getErrorHandler","resultHandler","getResultHandler","handleHookResult","isTargetState","hooks","results","hooks_1","chain","HANDLE_RESULT","IGNORE_RESULT","LOG_ERROR","defaultErrorHandler","REJECT_ERROR","THROW_ERROR","_identifier","_definition","_params","exists","base","relative","isDef","criterion","matchGlobs","_state","globStrings","toMatch","glob_1","matchFn","registry","hookRegistrationFn","matchObject","RegisteredHook","tranSvc","matchCriteria","priority","_matchingNodes","nodes","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","paths","mn","pathtype","isStateHook","scope","STATE","allMatched","every","tupleSort","reverseDepthSort","l","r","factor","depthDelta","toState","fromState","$transitions","baseHookOptions","phase","buildHooks","hookType","matchingHooks","getMatchingHooks","makeTransitionHooks","matchingNodes","criteriaMatchPath","transitionHook","sort","reverseSort","isCreate","registries","reg","stateOrPath","res","clone","applyRawParams","getParamVal","paramDef","pDef","parameter","paramValsEq","pathA","pathB","ignoreDynamicParams","changedParams","param","unwrapShorthand","cfg","isShorthand","$$fn","getType","urlType","paramTypes","DefType","CONFIG","PATH","SEARCH","paramType_1","ParamType","getSquashPolicy","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","hasOwn","getArrayMode","arrayDefaults","arrayParamNomenclature","$asArray","raw","defaultSquashPolicy","isDefaultValue","$$getDefaultValue","defaultValue","$replace","replacement","$normalize","isSearch","normalized","encoded","encode","exec","values1","values2","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","$arrayMode","def","decode","$subPattern","sub","makeTargetState","buildPath","inheritParams","states","viewDecls","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","applyToParams","retainedNode","cloned","keep","staticParams","nodesMatch","node1","node2","retainedWithToParams","elementIdx","defaultResolvePolicy","async","arg1","resolveFn","deps","policy","resolved","literal","getPolicy","thisPolicy","statePolicy","resolvePolicy","getResolvableDependencies","getDependencies","get","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","cache","take","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","fromData","resolvePolicies","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","getResolvable","subContext","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","promises","nodeResolvables","nowait","wait","getResult","_injector","UIInjectorImpl","availableResolvables","getDependency","fromInjector","getNative","native","getAsync","WAIT","NOWAIT","RXWAIT","urlMatcherFactory_1","urlRouter_1","transitionService_1","view_1","stateRegistry_1","stateService_1","globals_1","urlService_1","_routerInstance","locationService","locationConfig","UrlService","locationServiceStub","locationConfigStub","ViewService","TransitionService","Globals","UrlMatcherFactory","urlRouter","UrlRouter","StateRegistry","StateService","_disposables","_plugins","_rootViewContext","$current","disposable","dispose","pluginInstance","getPlugin","pluginName","urlMatcher_1","paramTypes_1","ParamTypes","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strict","caseInsensitive","paramFactory","fromConfig","fromSearch","UrlMatcher","strictMode","compile","isMatcher","object","definition","definitionFn","_flushTypeQueue","quoteRegExp","string","surroundPattern","memoizeTo","_cache","_children","_segments","_compiled","paramMap","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","makeRegexpType","substring","index","lastIndex","search","append","url","isRoot","hash","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","j","validParamVal","getDetails","urlMatchers","pathSegmentsAndParams","queryParams","pathString","encodeDashes","encodeURIComponent","queryString","charCodeAt","toUpperCase","matcher","staticSegments","splitOnSlash","segments","aSegments","bSegments","weight","cmp","weightPair","initDefaultTypes","makeDefaultType","valToString","defaultTypeBase","String","query","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","json","typeQueue","defaultTypes","makeType","types","appendBasePath","isHtml5","absolute","baseHref","defaultRuleSortFn","urlRule_1","getMatcher","URLMATCHER","REGEXP","RAW","OTHER","_sortFn","_rules","interceptDeferred","_id","_router","urlRuleFactory","UrlRuleFactory","_otherwiseFn","compareFn","rules","best","checkRule","rule","matchPriority","evt","defaultPrevented","$url","applyResult","newurl","go","handler","_stopFn","onChange","update","read","urlMatcher","href","html5Mode","hashPrefix","slash","port","protocol","host","isUrlRule","removeRule","otherwise","handlerFn","deferIntercept","stateObject_1","what","makeRule","_what","fromUrlMatcher","State","fromRegExp","BaseUrlRule","optional","matched","_handler","details","transitionTo","global","sticky","redirectUrlTo","Number","matchingKeys","inherited","resolve_1","views_1","url_1","redirectTo_1","onEnterExitRetain_1","lazyLoad_1","transitionEventType_1","defaultTransOpts","notify","custom","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineDefaultPaths","_defineDefaultEvents","_registerDefaultTransitionHooks","onCreate","hooksArray","Phase","TH","_defineEvent","_definePathType","hookOrder","TransitionEventType","transitionHookTypes","cmpByPhase","hookScope","fns","redirectTo","registerRedirectToHook","registerOnExitHook","registerOnRetainHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","loadViews","registerLoadEnteringViews","activateViews","registerActivateViews","updateUrl","registerUpdateUrl","lazyLoad","registerLazyLoadHook","eagerResolvePath","lazyResolveState","loadEnteringViews","enteringViews","load","exitingViews","vc","deactivateViewConfig","activateViewConfig","$urlRouter","navigable","urlOptions","redirectToHook","handleResult","makeEnterExitRetainHook","hookFn","onExitHook","onRetainHook","onEnterHook","lazyLoadState","updateStateRegistry","lazyLoadFn","$$state","err","lazyLoadHook","retryTransition","orig","parts","_uiViews","_viewConfigs","_viewConfigFactories","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","decl","cfgFactory","$type","cfgs","uiViewDepth","viewConfigDepth","count","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","configUpdated","registerUIView","uiViews","fqnMatches","available","active","normalizeUIViewTarget","rawViewName","viewAtContext","uiViewName","uiViewContextAnchor","relativeViewNameSugar","charAt","relativeMatch","anchor","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","stateMatcher_1","stateBuilder_1","stateQueueManager_1","listeners","StateMatcher","builder","StateBuilder","stateQueue","StateQueueManager","_registerRoot","rootStateDef","#","_root","deregister","onStatesChanged","listener","stateDefinition","_deregisterTree","s","getChildren","children","deregistered","$ur","stateOrName","deregisteredStates","found","func","_states","isRelative","isStr","baseState","splitName","pathLength","relName","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","objects2Tuples","resolveObj","annotate","strictDi","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","parseUrl","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","parsed","paramConfig","reloadOnSearch","getNavigableBuilder","getParamsBuilder","makeConfigParam","urlParams","nonUrlParams","parentBuilder","parentName","builders","build","parentFn","lastSegment","pop","$registry","queue","flush","registered","orphans","previousQueueLength","orphanIdx","existingState","attachRoute","queue_1","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","defineProperty","enumerable","configurable","_handleInvalidTargetState","invokeNextCallback","nextCallback","callbackQueue","callbackResult","checkForRedirect","latestThing","latest","onInvalid","defautGoOpts","transOpts","getCurrentPath","latestSuccess","successfulTransitions","rootPath","transHistory","currentPath","rejectedTransitionHandler","transitionToPromise","include","defaultHrefOpts","lossy","$inherit","nav","stateParams_1","StateParams","beforeNewTransition","$transition$","updateGlobalState","clearCurrentTransition","newParams","parentParams","parents","inheritList","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","lateBind","locationServices","umf","urlParts","UIRouterPluginBase","hasAnyKey","viewConfigId","viewsObject","$default","each","resolveAs","$name","index_1","Promise","deferred","wait4","STRIP_COMMENTS","ARGUMENT_NAMES","has","locals","ensureExist","$inject","utils_1","BaseLocationServices","fireAfterUpdate","_listener","_listeners","_get","getParams","_location","_history","history","evt_1","Event","buildUrl","orEmptyString","splitHash","beforehash","_b","splitQuery","locationPluginFactory","serviceClass","configurationClass","service","configuration","splitEqual","trimHashVal","keyValsToObjectR","accum","loc","searchObject","vals","__extends","__","baseLocationService_1","HashLocationService","_super","addEventListener","title","removeEventListener","MemoryLocationService","_url","PushStateLocationService","_config","fullUrl","replaceState","pushState","MemoryLocationConfig","_baseHref","_port","_protocol","_host","_hashPrefix","newval","BrowserLocationConfig","_isHtml5","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","_injector_1","_q_1","browserLocationConfig_1","hashLocationService_1","pushStateLocationService_1","memoryLocationService_1","memoryLocationConfig_1","pushStateLocationPlugin","memoryLocationPlugin","Mn","initialize","mnLayout","mnRegion","mnRegionName","parentContext","parentFqn","ref3","ref4","ref5","ref6","listenTo","destroy","activeUIView","onConfigUpdated","newConfig","clearPreviousConfig","updateView","controller","getResolved","getView","getController","show","listenToOnce","len","viewOptions","controllerOptions","empty","triggerMethod","onBeforeDestroy","ui","sref","events","click @ui.ref","onClickLink","onAttach","$","attr","Behavior","activeClasses","onStateChange","onRender","el","$el","classFn","compareState","removeListeners","off","on","onAttachUI","onBeforeDestroyUI","regions","me","parentRegion","region","regionName","LayoutView"],"mappings":"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","file":"ui-router-marionette.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, Router, UILayoutMn2, UISref, UISrefActive, UIViewMarionette, _, ref, ref1;\n\t\n\t_ = __webpack_require__(2);\n\t\n\tref = __webpack_require__(3), $q = ref.$q, UIViewMarionette = ref.UIViewMarionette, Router = ref.Router;\n\t\n\tref1 = __webpack_require__(75), UISref = ref1.UISref, UISrefActive = ref1.UISrefActive;\n\t\n\tUILayoutMn2 = __webpack_require__(76);\n\t\n\t_.extend(exports, {\n\t  Router: Router,\n\t  UISref: UISref,\n\t  UISrefActive: UISrefActive,\n\t  UILayoutMn2: UILayoutMn2,\n\t  UIViewMarionette: UIViewMarionette,\n\t  $q: $q\n\t});\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, MnViewConfig, UIRouter, UIRouterMarionette, UIViewMarionette, hashLocationPlugin, mnViewsBuilder, ref, ref1, ref2, routerInstance, servicesPlugin, viewConfigFactory,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tref = __webpack_require__(4), UIRouter = ref.UIRouter, $q = ref.$q;\n\t\n\tref1 = __webpack_require__(60), mnViewsBuilder = ref1.mnViewsBuilder, MnViewConfig = ref1.MnViewConfig;\n\t\n\tref2 = __webpack_require__(61), hashLocationPlugin = ref2.hashLocationPlugin, servicesPlugin = ref2.servicesPlugin;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\trouterInstance = null;\n\t\n\tviewConfigFactory = function(node, config) {\n\t  return new MnViewConfig(node, config);\n\t};\n\t\n\tUIRouterMarionette = (function(superClass) {\n\t  extend(UIRouterMarionette, superClass);\n\t\n\t  UIRouterMarionette.getInstance = function() {\n\t    return routerInstance || (routerInstance = new this);\n\t  };\n\t\n\t  function UIRouterMarionette() {\n\t    UIRouterMarionette.__super__.constructor.apply(this, arguments);\n\t    this._started = false;\n\t    this.viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory);\n\t    this.plugin(servicesPlugin);\n\t    this.plugin(hashLocationPlugin);\n\t    this.stateRegistry.decorator(\"views\", mnViewsBuilder);\n\t    routerInstance = this;\n\t  }\n\t\n\t  UIRouterMarionette.prototype.start = function(rootRegion, options) {\n\t    this.rootRegion = rootRegion;\n\t    if (this._started) {\n\t      throw new Error(\"Router was already started\");\n\t    }\n\t    if (options != null) {\n\t      this.handleOptions(options);\n\t    }\n\t    this.rootRegion.uiView = new UIViewMarionette(this, null, this.rootRegion, \"\");\n\t    this.rootRegion.uiView.register();\n\t    this.urlMatcherFactory.$get();\n\t    this.urlService.listen();\n\t    this.urlService.sync();\n\t    this._started = true;\n\t    return this;\n\t  };\n\t\n\t  UIRouterMarionette.prototype.handleOptions = function(options) {\n\t    if (typeof options.onMnRoute === 'function') {\n\t      return this.onMnRoute(options.onMnRoute);\n\t    }\n\t  };\n\t\n\t  UIRouterMarionette.prototype.onMnRoute = function(onRoute) {\n\t    var oldProcessOnRoute, uiRouter;\n\t    oldProcessOnRoute = Marionette.AppRouter.prototype._processOnRoute;\n\t    uiRouter = this;\n\t    return Marionette.AppRouter.prototype._processOnRoute = function(mnRouteName, mnRouteArgs) {\n\t      var mnRoutePath;\n\t      mnRoutePath = _.invert(this.getOption('appRoutes'))[mnRouteName];\n\t      onRoute.call(this, mnRouteName, mnRouteArgs, mnRoutePath, uiRouter.stateService);\n\t      return oldProcessOnRoute.call(this, mnRouteName, mnRouteArgs);\n\t    };\n\t  };\n\t\n\t  return UIRouterMarionette;\n\t\n\t})(UIRouter);\n\t\n\texports.UIViewMarionette = UIViewMarionette;\n\t\n\texports.Router = UIRouterMarionette;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module common\n\t */ /** */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(52));\n\t__export(__webpack_require__(53));\n\t__export(__webpack_require__(54));\n\t__export(__webpack_require__(55));\n\t__export(__webpack_require__(56));\n\t__export(__webpack_require__(57));\n\t__export(__webpack_require__(58));\n\t__export(__webpack_require__(49));\n\t__export(__webpack_require__(28));\n\t__export(__webpack_require__(59));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module common */ /** for typedoc */\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(12));\n\t__export(__webpack_require__(15));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * These functions are exported, but are subject to change without notice.\n\t *\n\t * @preferred\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\texports.copy = angular.copy || _copy;\n\texports.forEach = angular.forEach || _forEach;\n\texports.extend = angular.extend || _extend;\n\texports.equals = angular.equals || _equals;\n\texports.identity = function (x) { return x; };\n\texports.noop = function () { return undefined; };\n\t/**\n\t * Builds proxy functions on the `to` object which pass through to the `from` object.\n\t *\n\t * For each key in `fnNames`, creates a proxy function on the `to` object.\n\t * The proxy function calls the real function on the `from` object.\n\t *\n\t *\n\t * #### Example:\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * ```js\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * #### Example:\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param source A function that returns the source object which contains the original functions to be bound\n\t * @param target A function that returns the target object which will receive the bound functions\n\t * @param bind A function that returns the object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n\t */\n\tfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n\t    if (latebind === void 0) { latebind = false; }\n\t    var bindFunction = function (fnName) {\n\t        return source()[fnName].bind(bind());\n\t    };\n\t    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n\t        target[fnName] = bindFunction(fnName);\n\t        return target[fnName].apply(null, arguments);\n\t    }; };\n\t    fnNames = fnNames || Object.keys(source());\n\t    return fnNames.reduce(function (acc, name) {\n\t        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n\t        return acc;\n\t    }, target);\n\t}\n\texports.createProxyFunctions = createProxyFunctions;\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\texports.inherit = function (parent, extra) {\n\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t};\n\t/**\n\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t * This is similar to es6 rest parameters.\n\t *\n\t * Optionally, the argument at index idx may itself already be an array.\n\t *\n\t * For example,\n\t * given either:\n\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t * or:\n\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t * then:\n\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t *\n\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t *\n\t * given:\n\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t * then:\n\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t */\n\tvar restArgs = function (args, idx) {\n\t    if (idx === void 0) { idx = 0; }\n\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\texports.inArray = hof_1.curry(_inArray);\n\tfunction _inArray(array, obj) {\n\t    return array.indexOf(obj) !== -1;\n\t}\n\texports._inArray = _inArray;\n\t/**\n\t * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n\t * The same array is returned\n\t */\n\texports.removeFrom = hof_1.curry(_removeFrom);\n\tfunction _removeFrom(array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t}\n\texports._removeFrom = _removeFrom;\n\t/** pushes a values to an array and returns the value */\n\texports.pushTo = hof_1.curry(_pushTo);\n\tfunction _pushTo(arr, val) {\n\t    return (arr.push(val), val);\n\t}\n\texports._pushTo = _pushTo;\n\t/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\n\texports.deregAll = function (functions) {\n\t    return functions.slice().forEach(function (fn) {\n\t        typeof fn === 'function' && fn();\n\t        exports.removeFrom(functions, fn);\n\t    });\n\t};\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    if (opts === void 0) { opts = {}; }\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t}\n\texports.defaults = defaults;\n\t/**\n\t * Merges properties from the list of objects to the destination object.\n\t * If a property already exists in the destination object, then it is not overwritten.\n\t */\n\tfunction merge(dst) {\n\t    var objs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        objs[_i - 1] = arguments[_i];\n\t    }\n\t    exports.forEach(objs, function (obj) {\n\t        exports.forEach(obj, function (value, key) {\n\t            if (!dst.hasOwnProperty(key))\n\t                dst[key] = value;\n\t        });\n\t    });\n\t    return dst;\n\t}\n\texports.merge = merge;\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\texports.ancestors = ancestors;\n\tfunction pickOmitImpl(predicate, obj) {\n\t    var keys = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        keys[_i - 2] = arguments[_i];\n\t    }\n\t    var objCopy = {};\n\t    for (var key in obj) {\n\t        if (predicate(keys, key))\n\t            objCopy[key] = obj[key];\n\t    }\n\t    return objCopy;\n\t}\n\t/** Return a copy of the object only containing the whitelisted properties. */\n\tfunction pick(obj) {\n\t    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n\t}\n\texports.pick = pick;\n\t/** Return a copy of the object omitting the blacklisted properties. */\n\tfunction omit(obj) {\n\t    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n\t    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n\t}\n\texports.omit = omit;\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, hof_1.prop(propName));\n\t}\n\texports.pluck = pluck;\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    exports.forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\texports.filter = filter;\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    exports.forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\texports.find = find;\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\texports.mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\texports.map = map;\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\texports.values = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return obj[key]; });\n\t};\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flattenR = function (memo, elem) {\n\t    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n\t};\n\t/**\n\t * Reduce function that pushes an object to an array, then returns the array.\n\t * Mostly just for [[flattenR]] and [[uniqR]]\n\t */\n\tfunction pushR(arr, obj) {\n\t    arr.push(obj);\n\t    return arr;\n\t}\n\texports.pushR = pushR;\n\t/** Reduce function that filters out duplicates */\n\texports.uniqR = function (acc, token) {\n\t    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n\t};\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\texports.assertPredicate = assertFn;\n\t/**\n\t * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n\t * @example\n\t * ```\n\t *\n\t * var data = { foo: 1, bar: 2 };\n\t *\n\t * let keys = [ 'foo', 'bar' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // values is [1, 2]\n\t *\n\t * let keys = [ 'foo', 'bar', 'baz' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // throws Error(\"Key not found\")\n\t * ```\n\t */\n\texports.assertMap = assertFn;\n\tfunction assertFn(predicateOrMap, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        var result = predicateOrMap(obj);\n\t        if (!result) {\n\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.assertFn = assertFn;\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\texports.pairs = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n\t};\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var arrayArgs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        arrayArgs[_i] = arguments[_i];\n\t    }\n\t    if (arrayArgs.length === 0)\n\t        return [];\n\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t}\n\texports.arrayTuples = arrayTuples;\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (predicates_1.isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!predicates_1.isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\texports.applyPairs = applyPairs;\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\texports.tail = tail;\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return exports.extend(dest, src);\n\t}\n\t/** Naive forEach implementation works with Objects or Arrays */\n\tfunction _forEach(obj, cb, _this) {\n\t    if (predicates_1.isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _copyProps(to, from) {\n\t    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n\t    return to;\n\t}\n\tfunction _extend(toObj) {\n\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t/**\n\t * Create a sort function\n\t *\n\t * Creates a sort function which sorts by a numeric property.\n\t *\n\t * The `propFn` should return the property as a number which can be sorted.\n\t *\n\t * #### Example:\n\t * This example returns the `priority` prop.\n\t * ```js\n\t * var sortfn = sortBy(obj => obj.priority)\n\t * // equivalent to:\n\t * var longhandSortFn = (a, b) => a.priority - b.priority;\n\t * ```\n\t *\n\t * #### Example:\n\t * This example uses [[prop]]\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'))\n\t * ```\n\t *\n\t * The `checkFn` can be used to exclude objects from sorting.\n\t *\n\t * #### Example:\n\t * This example only sorts objects with type === 'FOO'\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n\t * ```\n\t *\n\t * @param propFn a function that returns the property (as a number)\n\t * @param checkFn a predicate\n\t *\n\t * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n\t */\n\texports.sortBy = function (propFn, checkFn) {\n\t    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n\t    return function (a, b) {\n\t        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n\t    };\n\t};\n\t/**\n\t * Composes a list of sort functions\n\t *\n\t * Creates a sort function composed of multiple sort functions.\n\t * Each sort function is invoked in series.\n\t * The first sort function to return non-zero \"wins\".\n\t *\n\t * @param sortFns list of sort functions\n\t */\n\texports.composeSort = function () {\n\t    var sortFns = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sortFns[_i] = arguments[_i];\n\t    }\n\t    return function (a, b) {\n\t        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n\t    };\n\t};\n\t// issue #2676\n\texports.silenceUncaughtInPromise = function (promise) {\n\t    return promise.catch(function (e) { return 0; }) && promise;\n\t};\n\texports.silentRejection = function (error) {\n\t    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n\t};\n\t//# sourceMappingURL=common.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** Predicates\n\t *\n\t * These predicates return true/false based on the input.\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_predicates\n\t */ /** */\n\tvar hof_1 = __webpack_require__(8);\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\texports.isUndefined = tis('undefined');\n\texports.isDefined = hof_1.not(exports.isUndefined);\n\texports.isNull = function (o) { return o === null; };\n\texports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\n\texports.isFunction = tis('function');\n\texports.isNumber = tis('number');\n\texports.isString = tis('string');\n\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\texports.isArray = Array.isArray;\n\texports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\n\texports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val) {\n\t    if (exports.isArray(val) && val.length) {\n\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t    }\n\t    return exports.isFunction(val);\n\t}\n\texports.isInjectable = isInjectable;\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\t//# sourceMappingURL=predicates.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Higher order functions\n\t *\n\t * These utility functions are exported, but are subject to change without notice.\n\t *\n\t * @module common_hof\n\t */ /** */\n\t\"use strict\";\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\texports.curry = curry;\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\texports.compose = compose;\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\texports.pipe = pipe;\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\texports.prop = function (name) {\n\t    return function (obj) { return obj && obj[name]; };\n\t};\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\texports.parse = function (name) {\n\t    return pipe.apply(null, name.split(\".\").map(exports.prop));\n\t};\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\texports.not = function (fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return !fn.apply(null, args);\n\t    };\n\t};\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\texports.and = and;\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\texports.or = or;\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\texports.all = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n\t};\n\texports.any = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n\t};\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\texports.is = function (ctor) {\n\t    return function (obj) {\n\t        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n\t    };\n\t};\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\texports.eq = function (val) { return function (other) {\n\t    return val === other;\n\t}; };\n\t/** Given a value, returns a function which returns the value */\n\texports.val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) {\n\t        return obj[fnName].apply(obj, args);\n\t    };\n\t}\n\texports.invoke = invoke;\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\texports.pattern = pattern;\n\t//# sourceMappingURL=hof.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t};\n\texports.services = services;\n\t//# sourceMappingURL=coreservices.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */\n\t/**\n\t * Matches state names using glob-like pattern strings.\n\t *\n\t * Globs can be used in specific APIs including:\n\t *\n\t * - [[StateService.is]]\n\t * - [[StateService.includes]]\n\t * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n\t *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n\t *\n\t * A `Glob` string is a pattern which matches state names.\n\t * Nested state names are split into segments (separated by a dot) when processing.\n\t * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n\t *\n\t * Globs work according to the following rules:\n\t *\n\t * ### Exact match:\n\t *\n\t * The glob `'A.B'` matches the state named exactly `'A.B'`.\n\t *\n\t * | Glob        |Matches states named|Does not match state named|\n\t * |:------------|:--------------------|:---------------------|\n\t * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n\t * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n\t * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n\t *\n\t * ### Single star (`*`)\n\t *\n\t * A single star (`*`) is a wildcard that matches exactly one segment.\n\t *\n\t * | Glob        |Matches states named  |Does not match state named |\n\t * |:------------|:---------------------|:--------------------------|\n\t * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n\t * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n\t * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n\t *\n\t * ### Double star (`**`)\n\t *\n\t * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n\t *\n\t * | Glob        |Matches states named                           |Does not match state named         |\n\t * |:------------|:----------------------------------------------|:----------------------------------|\n\t * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n\t * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n\t * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n\t * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n\t *\n\t */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t        var regexpString = this.text.split('.')\n\t            .map(function (seg) {\n\t            if (seg === '**')\n\t                return '(?:|(?:\\\\.[^.]*)*)';\n\t            if (seg === '*')\n\t                return '\\\\.[^.]*';\n\t            return '\\\\.' + seg;\n\t        }).join('');\n\t        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        return this.regexp.test('.' + name);\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.is = function (text) {\n\t        return text.indexOf('*') > -1;\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.fromString = function (text) {\n\t        if (!this.is(text))\n\t            return null;\n\t        return new Glob(text);\n\t    };\n\t    return Glob;\n\t}());\n\texports.Glob = Glob;\n\t//# sourceMappingURL=glob.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\texports.Queue = Queue;\n\t//# sourceMappingURL=queue.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Functions that manipulate strings\n\t *\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_strings\n\t */ /** */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar transition_1 = __webpack_require__(14);\n\tvar resolvable_1 = __webpack_require__(25);\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\texports.maxLength = maxLength;\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\texports.padString = padString;\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\texports.kebobString = kebobString;\n\tfunction _toJson(obj) {\n\t    return JSON.stringify(obj);\n\t}\n\tfunction _fromJson(json) {\n\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t}\n\tfunction promiseToString(p) {\n\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t    var fnName = fn['name'] || \"\";\n\t    if (fnName && toStr.match(/function \\(/)) {\n\t        return 'function ' + fnName + toStr.substr(9);\n\t    }\n\t    return toStr;\n\t}\n\texports.functionToString = functionToString;\n\tfunction fnToString(fn) {\n\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\texports.fnToString = fnToString;\n\tvar stringifyPatternFn = null;\n\tvar stringifyPattern = function (value) {\n\t    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\t    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n\t        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t        [predicates_1.isNull, hof_1.val(\"null\")],\n\t        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n\t        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t        [predicates_1.isInjectable, functionToString],\n\t        [hof_1.val(true), common_1.identity]\n\t    ]);\n\t    return stringifyPatternFn(value);\n\t};\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val) {\n\t        if (predicates_1.isObject(val)) {\n\t            if (seen.indexOf(val) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val);\n\t        }\n\t        return stringifyPattern(val);\n\t    }\n\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t}\n\texports.stringify = stringify;\n\t/** Returns a function that splits a string on a character or substring */\n\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\t/**\n\t * Splits on a delimiter, but returns the delimiters in the array\n\t *\n\t * #### Example:\n\t * ```js\n\t * var splitOnSlashes = splitOnDelim('/');\n\t * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n\t * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n\t * ```\n\t */\n\tfunction splitOnDelim(delim) {\n\t    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n\t    return function (str) {\n\t        return str.split(re).filter(common_1.identity);\n\t    };\n\t}\n\texports.splitOnDelim = splitOnDelim;\n\t;\n\t/**\n\t * Reduce fn that joins neighboring strings\n\t *\n\t * Given an array of strings, returns a new array\n\t * where all neighboring strings have been joined.\n\t *\n\t * #### Example:\n\t * ```js\n\t * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n\t * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n\t * ```\n\t */\n\tfunction joinNeighborsR(acc, x) {\n\t    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n\t        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n\t    return common_1.pushR(acc, x);\n\t}\n\texports.joinNeighborsR = joinNeighborsR;\n\t;\n\t//# sourceMappingURL=strings.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar RejectType;\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n\t})(RejectType = exports.RejectType || (exports.RejectType = {}));\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) {\n\t            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n\t        };\n\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition\";\n\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a TransitionRejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid\";\n\t        return new Rejection(RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored\";\n\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition has been aborted\";\n\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.errored = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition errored\";\n\t        return new Rejection(RejectType.ERROR, message, detail);\n\t    };\n\t    return Rejection;\n\t}());\n\texports.Rejection = Rejection;\n\t//# sourceMappingURL=rejectFactory.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar hookBuilder_1 = __webpack_require__(20);\n\tvar node_1 = __webpack_require__(21);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar router_1 = __webpack_require__(28);\n\t/** @hidden */\n\tvar stateSelf = hof_1.prop(\"self\");\n\t/**\n\t * Represents a transition between two states.\n\t *\n\t * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n\t *\n\t * This object contains all contextual information about the to/from states, parameters, resolves.\n\t * It has information about all states being entered and exited as a result of the transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param router The [[UIRouter]] instance\n\t     */\n\t    function Transition(fromPath, targetState, router) {\n\t        var _this = this;\n\t        /** @hidden */\n\t        this._deferred = coreservices_1.services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\t        this._registeredHooks = {};\n\t        /**\n\t         * Checks if this transition is currently active/running.\n\t         */\n\t        this.isActive = function () { return _this === _this._options.current(); };\n\t        this.router = router;\n\t        this._targetState = targetState;\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t        this.$id = router.transitionService._transitionCount++;\n\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        this.createTransitionHookRegFns();\n\t        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n\t        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n\t        this.applyViewConfigs(router);\n\t        this.applyRootResolvables(router);\n\t    }\n\t    /** @hidden */\n\t    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onError = function (criteria, callback, options) { return; };\n\t    /** @hidden\n\t     * Creates the transition-level hook registration functions\n\t     * (which can then be used to register hooks)\n\t     */\n\t    Transition.prototype.createTransitionHookRegFns = function () {\n\t        var _this = this;\n\t        this.router.transitionService._pluginapi._getEvents()\n\t            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n\t            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n\t    };\n\t    /** @internalapi */\n\t    Transition.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    Transition.prototype.applyViewConfigs = function (router) {\n\t        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n\t        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n\t    };\n\t    Transition.prototype.applyRootResolvables = function (router) {\n\t        var _this = this;\n\t        var rootResolvables = [\n\t            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n\t            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n\t        ];\n\t        var rootNode = this._treeChanges.to[0];\n\t        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n\t        context.addResolvables(rootResolvables, rootNode.state);\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal from [State] object\n\t     */\n\t    Transition.prototype.$from = function () {\n\t        return common_1.tail(this._treeChanges.from).state;\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal to [State] object\n\t     */\n\t    Transition.prototype.$to = function () {\n\t        return common_1.tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * Returns the state that the transition is coming *from*.\n\t     *\n\t     * @returns The state declaration object for the Transition's (\"from state\").\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * Returns the state that the transition is going *to*.\n\t     *\n\t     * @returns The state declaration object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Gets the Target State\n\t     *\n\t     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n\t     *\n\t     * @returns the [[TargetState]] of this Transition\n\t     */\n\t    Transition.prototype.targetState = function () {\n\t        return this._targetState;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n\t    };\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    /**\n\t     * Creates a [[UIInjector]] Dependency Injector\n\t     *\n\t     * Returns a Dependency Injector for the Transition's target state (to state).\n\t     * The injector provides resolve values which the target state has access to.\n\t     *\n\t     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ entering: 'myState' }, trans => {\n\t     *   var myResolveValue = trans.injector().get('myResolve');\n\t     *   // Inject a global service from the global/native injector (if it exists)\n\t     *   var MyService = trans.injector().get('MyService');\n\t     * })\n\t     * ```\n\t     *\n\t     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n\t     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n\t     * #### Example:\n\t     * ```js\n\t     * .onBefore({}, trans => {\n\t     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n\t     *     return myResolveValue !== 'ABORT';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n\t     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ to: 'foo.bar' }, trans => {\n\t     *   // returns result of `foo` state's `data` resolve\n\t     *   // even though `foo.bar` also has a `data` resolve\n\t     *   var fooData = trans.injector('foo').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n\t     * The resolve data from the `from` path will be returned.\n\t     * #### Example:\n\t     * ```js\n\t     * .onExit({ exiting: 'foo.bar' }, trans => {\n\t     *   // Gets the resolve value of `data` from the exiting state.\n\t     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n\t     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n\t     *\n\t     * @returns a [[UIInjector]]\n\t     */\n\t    Transition.prototype.injector = function (state, pathName) {\n\t        if (pathName === void 0) { pathName = \"to\"; }\n\t        var path = this._treeChanges[pathName];\n\t        if (state)\n\t            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n\t        return new resolveContext_1.ResolveContext(path).injector();\n\t    };\n\t    /**\n\t     * Gets all available resolve tokens (keys)\n\t     *\n\t     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n\t     * available to the Transition.\n\t     *\n\t     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n\t     * in the Transition's [[TreeChanges.to]] path.\n\t     *\n\t     * #### Example:\n\t     * This example logs all resolve values\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n\t     * ```\n\t     *\n\t     * #### Example:\n\t     * This example creates promises for each resolve value.\n\t     * This triggers fetches of resolves (if any have not yet been fetched).\n\t     * When all promises have all settled, it logs the resolve values.\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * let promise = tokens.map(token => trans.injector().getAsync(token));\n\t     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n\t     * ```\n\t     *\n\t     * Note: Angular 1 users whould use `$q.all()`\n\t     *\n\t     * @param pathname resolve context's path name (e.g., `to` or `from`)\n\t     *\n\t     * @returns an array of resolve tokens (keys)\n\t     */\n\t    Transition.prototype.getResolveTokens = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n\t    };\n\t    /**\n\t     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * transitionService.onBefore({}, transition => {\n\t     *   transition.addResolvable({\n\t     *     token: 'myResolve',\n\t     *     deps: ['MyService'],\n\t     *     resolveFn: myService => myService.getData()\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n\t     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolvable = function (resolvable, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t        var resolveContext = new resolveContext_1.ResolveContext(topath);\n\t        resolveContext.addResolvables([resolvable], targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the transition from which this transition was redirected.\n\t     *\n\t     * If the current transition is a redirect, this method returns the transition that was redirected.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let transitionA = $state.go('A').transition\n\t     * transitionA.onStart({}, () => $state.target('B'));\n\t     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n\t     *   trans.to().name === 'B'; // true\n\t     *   trans.redirectedFrom() === transitionA; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.redirectedFrom = function () {\n\t        return this._options.redirectedFrom || null;\n\t    };\n\t    /**\n\t     * Gets the original transition in a redirect chain\n\t     *\n\t     * A transition might belong to a long chain of multiple redirects.\n\t     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * // states\n\t     * registry.register({ name: 'A', redirectTo: 'B' });\n\t     * registry.register({ name: 'B', redirectTo: 'C' });\n\t     * registry.register({ name: 'C', redirectTo: 'D' });\n\t     * registry.register({ name: 'D' });\n\t     *\n\t     * let transitionA = $state.go('A').transition\n\t     *\n\t     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n\t     *   trans.to().name === 'D'; // true\n\t     *   trans.redirectedFrom().to().name === 'C'; // true\n\t     *   trans.originalTransition() === transitionA; // true\n\t     *   trans.originalTransition().to().name === 'A'; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The original Transition that started a redirect chain\n\t     */\n\t    Transition.prototype.originalTransition = function () {\n\t        var rf = this.redirectedFrom();\n\t        return (rf && rf.originalTransition()) || this;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t    };\n\t    Transition.prototype.treeChanges = function (pathname) {\n\t        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n\t    };\n\t    /**\n\t     * Creates a new transition that is a redirection of the current one.\n\t     *\n\t     * This transition can be returned from a [[TransitionService]] hook to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns Returns a new [[Transition]] instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var redirects = 1, trans = this;\n\t        while ((trans = trans.redirectedFrom()) != null) {\n\t            if (++redirects > 20)\n\t                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n\t        }\n\t        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n\t        // If the original transition was caused by URL sync, then use { location: 'replace' }\n\t        // on the new transition (unless  the target state explicitly specifies location)\n\t        if (this.options().source === 'url') {\n\t            redirectOpts.location = 'replace';\n\t        }\n\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n\t        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n\t        var originalEnteringNodes = this._treeChanges.entering;\n\t        var redirectEnteringNodes = newTransition._treeChanges.entering;\n\t        // --- Re-use resolve data from original transition ---\n\t        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n\t        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n\t        // redirected transition.\n\t        //\n\t        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n\t        // You can wait for the resolve, then redirect to a child state based on the result.\n\t        // The redirected transition does not have to re-fetch the resolve.\n\t        // ---------------------------------------------------------\n\t        var nodeIsReloading = function (reloadState) { return function (node) {\n\t            return reloadState && node.state.includes[reloadState.name];\n\t        }; };\n\t        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\t        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n\t            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n\t        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\t        matchingEnteringNodes.forEach(function (node, idx) {\n\t            node.resolvables = originalEnteringNodes[idx].resolvables;\n\t        });\n\t        return newTransition;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var tc = this._treeChanges;\n\t        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n\t        // If user explicitly wants a reload\n\t        if (this._options.reload)\n\t            return undefined;\n\t        // If any states are exiting or entering\n\t        if (tc.exiting.length || tc.entering.length)\n\t            return undefined;\n\t        // If to/from path lengths differ\n\t        if (tc.to.length !== tc.from.length)\n\t            return undefined;\n\t        // If the to/from paths are different\n\t        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n\t            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n\t            .reduce(common_1.anyTrueR, false);\n\t        if (pathsDiffer)\n\t            return undefined;\n\t        // Find any parameter values that differ\n\t        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n\t        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return param_1.Param.changed(schema, toVals, fromVals);\n\t        }).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.length === 0;\n\t    };\n\t    /**\n\t     * @hidden\n\t     */\n\t    Transition.prototype.hookBuilder = function () {\n\t        return new hookBuilder_1.HookBuilder(this);\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n\t        var hookBuilder = this.hookBuilder();\n\t        var globals = this.router.globals;\n\t        globals.transitionHistory.enqueue(this);\n\t        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n\t        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t            var rejectReason = syncResult._transitionRejection;\n\t            this._deferred.reject(rejectReason);\n\t            return this.promise;\n\t        }\n\t        if (!this.valid()) {\n\t            var error = new Error(this.error());\n\t            this._deferred.reject(error);\n\t            return this.promise;\n\t        }\n\t        if (this.ignored()) {\n\t            trace_1.trace.traceTransitionIgnored(this);\n\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t            return this.promise;\n\t        }\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var transitionSuccess = function () {\n\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this.to());\n\t            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n\t            runAllHooks(onSuccessHooks);\n\t        };\n\t        var transitionError = function (reason) {\n\t            trace_1.trace.traceError(reason, _this);\n\t            _this.success = false;\n\t            _this._deferred.reject(reason);\n\t            _this._error = reason;\n\t            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n\t            runAllHooks(onErrorHooks);\n\t        };\n\t        trace_1.trace.traceTransitionStart(this);\n\t        // Chain the next hook off the previous\n\t        var appendHookToChain = function (prev, nextHook) {\n\t            return prev.then(function () { return nextHook.invokeHook(); });\n\t        };\n\t        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n\t        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n\t        asyncHooks.reduce(appendHookToChain, syncResult)\n\t            .then(transitionSuccess, transitionError);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error() || this.success !== undefined;\n\t    };\n\t    /**\n\t     * The Transition error reason.\n\t     *\n\t     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n\t     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n\t     *\n\t     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self.abstract)\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        if (!param_1.Param.validates(state.parameters(), this.params()))\n\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t        if (this.success === false)\n\t            return this._error;\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    return Transition;\n\t}());\n\t/** @hidden */\n\tTransition.diToken = Transition;\n\texports.Transition = Transition;\n\t//# sourceMappingURL=transition.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * # Transition tracing (debug)\n\t *\n\t * Enable transition tracing to print transition information to the console,\n\t * in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n\t *\n\t * ### ES6\n\t * ```js\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * ### CJS\n\t * ```js\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * ### Globals\n\t * ```js\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * ### Angular 1:\n\t * ```js\n\t * app.run($trace => $trace.enable());\n\t * ```\n\t *\n\t * @coreapi\n\t * @module trace\n\t */ /** for typedoc */\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction uiViewString(viewData) {\n\t    if (!viewData)\n\t        return 'ui-view (defunct)';\n\t    return \"[ui-view#\" + viewData.id + \" tag \" +\n\t        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n\t        (\"fqn: '\" + viewData.fqn + \"', \") +\n\t        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t}\n\t/**\n\t * Trace categories Enum\n\t *\n\t * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\tvar Category;\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n\t})(Category = exports.Category || (exports.Category = {}));\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    /** @hidden */\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(Category)\n\t                .map(function (k) { return parseInt(k, 10); })\n\t                .filter(function (k) { return !isNaN(k); })\n\t                .map(function (key) { return Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    /**\n\t     * Enables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enable(\"TRANSITION\");\n\t     * ```\n\t     *\n\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    /**\n\t     * Disables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.disable(\"VIEWCONFIG\");\n\t     * ```\n\t     *\n\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, when, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceError = function (reason, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewFill = function (viewData, html) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\texports.Trace = Trace;\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * #### Example:\n\t * ```js\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\texports.trace = trace;\n\t//# sourceMappingURL=trace.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar TransitionHookPhase;\n\t(function (TransitionHookPhase) {\n\t    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n\t    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n\t})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\tvar TransitionHookScope;\n\t(function (TransitionHookScope) {\n\t    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n\t    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n\t})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar defaultOptions = {\n\t    current: common_1.noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null\n\t};\n\t/** @hidden */\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(transition, stateContext, registeredHook, options) {\n\t        var _this = this;\n\t        this.transition = transition;\n\t        this.stateContext = stateContext;\n\t        this.registeredHook = registeredHook;\n\t        this.options = options;\n\t        this.stateService = function () { return _this.transition.router.stateService; };\n\t        this.rejectIfSuperseded = function () {\n\t            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n\t        };\n\t        this.options = common_1.defaults(options, defaultOptions);\n\t    }\n\t    TransitionHook.prototype.invokeHook = function () {\n\t        var hook = this.registeredHook;\n\t        if (hook._deregistered)\n\t            return;\n\t        var options = this.options;\n\t        trace_1.trace.traceHookInvocation(this, this.transition, options);\n\t        if (this.rejectIfSuperseded()) {\n\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t        }\n\t        var cb = hook.callback;\n\t        var bind = this.options.bind;\n\t        var trans = this.transition;\n\t        var state = this.stateContext;\n\t        var errorHandler = hook.eventType.getErrorHandler(this);\n\t        var resultHandler = hook.eventType.getResultHandler(this);\n\t        resultHandler = resultHandler || common_1.identity;\n\t        if (!errorHandler) {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        try {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        catch (error) {\n\t            return errorHandler(error);\n\t        }\n\t    };\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false (cancel), a TargetState (redirect),\n\t     * or a promise (which may later resolve to false or a redirect)\n\t     *\n\t     * This also handles \"transition superseded\" -- when a new transition\n\t     * was started while the hook was still running\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (result) {\n\t        // This transition is no longer current.\n\t        // Another transition started while this hook was still running.\n\t        if (this.rejectIfSuperseded()) {\n\t            // Abort this transition\n\t            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n\t        }\n\t        // Hook returned a promise\n\t        if (predicates_1.isPromise(result)) {\n\t            // Wait for the promise, then reprocess the resolved value\n\t            return result.then(this.handleHookResult.bind(this));\n\t        }\n\t        trace_1.trace.traceHookResult(result, this.transition, this.options);\n\t        // Hook returned false\n\t        if (result === false) {\n\t            // Abort this Transition\n\t            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n\t        }\n\t        var isTargetState = hof_1.is(targetState_1.TargetState);\n\t        // hook returned a TargetState\n\t        if (isTargetState(result)) {\n\t            // Halt the current Transition and start a redirected Transition (to the TargetState).\n\t            return rejectFactory_1.Rejection.redirected(result).toPromise();\n\t        }\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t    };\n\t    /**\n\t     * Run all TransitionHooks, ignoring their return value.\n\t     */\n\t    TransitionHook.runAllHooks = function (hooks) {\n\t        hooks.forEach(function (hook) { return hook.invokeHook(); });\n\t    };\n\t    /**\n\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n\t     *\n\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t     */\n\t    TransitionHook.runOnBeforeHooks = function (hooks) {\n\t        var results = [];\n\t        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n\t            var hook = hooks_1[_i];\n\t            var hookResult = hook.invokeHook();\n\t            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n\t                // Break on first thrown error or false/TargetState\n\t                return hookResult;\n\t            }\n\t            results.push(hookResult);\n\t        }\n\t        return results\n\t            .filter(predicates_1.isPromise)\n\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t    };\n\t    return TransitionHook;\n\t}());\n\tTransitionHook.HANDLE_RESULT = function (hook) {\n\t    return function (result) {\n\t        return hook.handleHookResult(result);\n\t    };\n\t};\n\tTransitionHook.IGNORE_RESULT = function (hook) {\n\t    return function (result) { return undefined; };\n\t};\n\tTransitionHook.LOG_ERROR = function (hook) {\n\t    return function (error) {\n\t        return (hook.stateService().defaultErrorHandler()(error), undefined);\n\t    };\n\t};\n\tTransitionHook.REJECT_ERROR = function (hook) {\n\t    return function (error) {\n\t        return rejectFactory_1.Rejection.errored(error).toPromise();\n\t    };\n\t};\n\tTransitionHook.THROW_ERROR = function (hook) {\n\t    return undefined;\n\t};\n\texports.TransitionHook = TransitionHook;\n\t//# sourceMappingURL=transitionHook.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * Encapsulate the target (destination) state/params/options of a [[Transition]].\n\t *\n\t * This class is frequently used to redirect a transition to a new destination.\n\t *\n\t * See:\n\t *\n\t * - [[HookResult]]\n\t * - [[TransitionHookFn]]\n\t * - [[TransitionService.onStart]]\n\t *\n\t * To create a `TargetState`, use [[StateService.target]].\n\t *\n\t * ---\n\t *\n\t * This class wraps:\n\t *\n\t * 1) an identifier for a state\n\t * 2) a set of parameters\n\t * 3) and transition options\n\t * 4) the registered state object (the [[StateDeclaration]])\n\t *\n\t * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n\t * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n\t * The `TargetState` class normalizes those options.\n\t *\n\t * A `TargetState` may be valid (the state being targeted exists in the registry)\n\t * or invalid (the state being targeted is not registered).\n\t */\n\tvar TargetState = (function () {\n\t    /**\n\t     * The TargetState constructor\n\t     *\n\t     * Note: Do not construct a `TargetState` manually.\n\t     * To create a `TargetState`, use the [[StateService.target]] factory method.\n\t     *\n\t     * @param _identifier An identifier for a state.\n\t     *    Either a fully-qualified state name, or the object used to define the state.\n\t     * @param _definition The internal state representation, if exists.\n\t     * @param _params Parameters for the target state\n\t     * @param _options Transition options.\n\t     *\n\t     * @internalapi\n\t     */\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    /** The name of the state this object targets */\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    /** The identifier used when creating this TargetState */\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    /** The target parameter values */\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    /** The internal state object (if it was found) */\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    /** The internal state declaration (if it was found) */\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    /** The target options */\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /** True if the target state was found */\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    /** True if the object is valid */\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /** If the object is invalid, returns the reason why */\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    TargetState.prototype.toString = function () {\n\t        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n\t    };\n\t    return TargetState;\n\t}());\n\t/** Returns true if the object has a state property that might be a state or state name */\n\tTargetState.isDef = function (obj) {\n\t    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n\t};\n\texports.TargetState = TargetState;\n\t//# sourceMappingURL=targetState.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16); // has or is using\n\tvar glob_1 = __webpack_require__(10);\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t *\n\t * @hidden\n\t *\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = new glob_1.Glob(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\texports.matchState = matchState;\n\t/**\n\t * @internalapi\n\t * The registration data for a registered transition hook\n\t */\n\tvar RegisteredHook = (function () {\n\t    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.tranSvc = tranSvc;\n\t        this.eventType = eventType;\n\t        this.callback = callback;\n\t        this.matchCriteria = matchCriteria;\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t        this._deregistered = false;\n\t    }\n\t    /**\n\t     * Gets the matching [[PathNode]]s\n\t     *\n\t     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n\t     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n\t     *\n\t     * Returning `null` is significant to distinguish between the default\n\t     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n\t     * when the nodes is an empty array.\n\t     *\n\t     * This is useful to allow a transition match criteria of `entering: true`\n\t     * to still match a transition, even when `entering === []`.  Contrast that\n\t     * with `entering: (state) => true` which only matches when a state is actually\n\t     * being entered.\n\t     */\n\t    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Gets the default match criteria (all `true`)\n\t     *\n\t     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n\t     *\n\t     * ```js\n\t     * {\n\t     *   to: true,\n\t     *   from: true,\n\t     *   entering: true,\n\t     *   exiting: true,\n\t     *   retained: true,\n\t     * }\n\t     */\n\t    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n\t        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n\t    };\n\t    /**\n\t     * Gets matching nodes as [[IMatchingNodes]]\n\t     *\n\t     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n\t     *\n\t     * ```js\n\t     * let matches: IMatchingNodes = {\n\t     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n\t     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n\t     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n\t     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n\t     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n\t     * };\n\t     * ```\n\t     */\n\t    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n\t        var _this = this;\n\t        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n\t        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n\t        return paths.reduce(function (mn, pathtype) {\n\t            // STATE scope criteria matches against every node in the path.\n\t            // TRANSITION scope criteria matches against only the last node in the path\n\t            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n\t            var path = treeChanges[pathtype.name] || [];\n\t            var nodes = isStateHook ? path : [common_1.tail(path)];\n\t            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n\t            return mn;\n\t        }, {});\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    RegisteredHook.prototype.matches = function (treeChanges) {\n\t        var matches = this._getMatchingNodes(treeChanges);\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = common_1.values(matches).every(common_1.identity);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return RegisteredHook;\n\t}());\n\texports.RegisteredHook = RegisteredHook;\n\t/** @hidden Return a registration function of the requested type. */\n\tfunction makeEvent(registry, transitionService, eventType) {\n\t    // Create the object which holds the registered transition hooks.\n\t    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n\t    var hooks = _registeredHooks[eventType.name] = [];\n\t    // Create hook registration function on the IHookRegistry for the event\n\t    registry[eventType.name] = hookRegistrationFn;\n\t    function hookRegistrationFn(matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n\t        hooks.push(registeredHook);\n\t        return function deregisterEventHook() {\n\t            registeredHook._deregistered = true;\n\t            common_1.removeFrom(hooks)(registeredHook);\n\t        };\n\t    }\n\t    return hookRegistrationFn;\n\t}\n\texports.makeEvent = makeEvent;\n\t//# sourceMappingURL=hookRegistry.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder(transition) {\n\t        this.transition = transition;\n\t        this.treeChanges = transition.treeChanges();\n\t        this.transitionOptions = transition.options();\n\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t        this.$transitions = transition.router.transitionService;\n\t        this.baseHookOptions = {\n\t            transition: transition,\n\t            current: transition.options().current\n\t        };\n\t    }\n\t    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n\t        var _this = this;\n\t        return this.$transitions._pluginapi._getEvents(phase)\n\t            .map(function (type) { return _this.buildHooks(type); })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(common_1.identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[PathNode]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     */\n\t    HookBuilder.prototype.buildHooks = function (hookType) {\n\t        var _this = this;\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(_this.treeChanges);\n\t            // Select the PathNode[] that will be used as TransitionHook context objects\n\t            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n\t            // Return an array of HookTuples\n\t            return matchingNodes.map(function (node) {\n\t                var _options = common_1.extend({\n\t                    bind: hook.bind,\n\t                    traceData: { hookType: hookType.name, context: node }\n\t                }, _this.baseHookOptions);\n\t                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n\t                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(common_1.unnestR, [])\n\t            .sort(tupleSort(hookType.reverseSort))\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all RegisteredHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[RegisteredHook]]s\n\t     */\n\t    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n\t        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n\t        // Instance and Global hook registries\n\t        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n\t        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n\t            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\texports.HookBuilder = HookBuilder;\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\t//# sourceMappingURL=hookBuilder.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module path */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar param_1 = __webpack_require__(22);\n\t/**\n\t * A node in a [[TreeChanges]] path\n\t *\n\t * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n\t * Each PathNode corresponds to a state being entered, exited, or retained.\n\t * The stateful information includes parameter values and resolve data.\n\t */\n\tvar PathNode = (function () {\n\t    function PathNode(stateOrPath) {\n\t        if (stateOrPath instanceof PathNode) {\n\t            var node = stateOrPath;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t            this.resolvables = node.resolvables.slice();\n\t            this.views = node.views && node.views.slice();\n\t        }\n\t        else {\n\t            var state = stateOrPath;\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n\t        }\n\t    }\n\t    /** Sets [[paramValues]] for the node, from the values of an object hash */\n\t    PathNode.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    /** Gets a specific [[Param]] metadata that belongs to the node */\n\t    PathNode.prototype.parameter = function (name) {\n\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t    };\n\t    /**\n\t     * @returns true if the state and parameter values for another PathNode are\n\t     * equal to the state and param values for this PathNode\n\t     */\n\t    PathNode.prototype.equals = function (node, keys) {\n\t        var _this = this;\n\t        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n\t        var paramValsEq = function (key) {\n\t            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n\t        };\n\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t    };\n\t    /** Returns a clone of the PathNode */\n\t    PathNode.clone = function (node) {\n\t        return new PathNode(node);\n\t    };\n\t    /**\n\t     * Returns a new path which is a subpath of the first path which matched the second path.\n\t     *\n\t     * The new path starts from root and contains any nodes that match the nodes in the second path.\n\t     * Nodes are compared using their state property and parameter values.\n\t     *\n\t     * @param pathA the first path\n\t     * @param pathB the second path\n\t     * @param ignoreDynamicParams don't compare dynamic parameter values\n\t     */\n\t    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n\t        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n\t        var matching = [];\n\t        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n\t            var a = pathA[i], b = pathB[i];\n\t            if (a.state !== b.state)\n\t                break;\n\t            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n\t                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n\t            if (changedParams.length)\n\t                break;\n\t            matching.push(a);\n\t        }\n\t        return matching;\n\t    };\n\t    return PathNode;\n\t}());\n\texports.PathNode = PathNode;\n\t//# sourceMappingURL=node.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar isShorthand = function (cfg) {\n\t    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\t};\n\tvar DefType;\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(DefType = exports.DefType || (exports.DefType = {}));\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    return common_1.extend(cfg, {\n\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t    });\n\t}\n\tfunction getType(cfg, urlType, location, id, paramTypes) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n\t        return paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type) {\n\t        var type = location === DefType.CONFIG ? \"any\" :\n\t            location === DefType.PATH ? \"path\" :\n\t                location === DefType.SEARCH ? \"query\" : \"string\";\n\t        return paramTypes.type(type);\n\t    }\n\t    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t        return defaultPolicy;\n\t    if (squash === true || predicates_1.isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t    ];\n\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t    if (predicates_1.isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\tvar Param = (function () {\n\t    function Param(id, type, config, location, urlMatcherFactory) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n\t        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n\t        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n\t        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var $$getDefaultValue = function () {\n\t            if (!coreservices_1.services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\t            return defaultValue;\n\t        };\n\t        var $replace = function (val) {\n\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t            return replacement.length ? replacement[0] : val;\n\t        };\n\t        value = $replace(value);\n\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    Param.values = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\texports.Param = Param;\n\t//# sourceMappingURL=param.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * An internal class which implements [[ParamTypeDefinition]].\n\t *\n\t * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n\t * When a param type definition is registered, an instance of this class is created internally.\n\t *\n\t * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n\t *\n\t * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n\t *\n\t * #### Example:\n\t * ```js\n\t * var paramTypeDef = {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t *\n\t * var paramType = new ParamType(paramTypeDef);\n\t * ```\n\t * @internalapi\n\t */\n\tvar ParamType = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n\t     * @returns a new ParamType object\n\t     */\n\t    function ParamType(def) {\n\t        /** @inheritdoc */\n\t        this.pattern = /.*/;\n\t        /** @inheritdoc */\n\t        this.inherit = true;\n\t        common_1.extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    ParamType.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.equals = function (a, b) { return a == b; };\n\t    ParamType.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    ParamType.prototype.toString = function () {\n\t        return \"{ParamType:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    ParamType.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    ParamType.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t/**\n\t * Wraps up a `ParamType` object to handle array values.\n\t * @internalapi\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) {\n\t        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n\t    }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (predicates_1.isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = common_1.map(arr, callback);\n\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n\t        var paramTypeFn = type[name].bind(type);\n\t        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n\t        _this[name] = wrapperFn(paramTypeFn);\n\t    });\n\t    common_1.extend(this, {\n\t        dynamic: type.dynamic,\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        inherit: type.inherit,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t//# sourceMappingURL=paramType.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module path */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar node_1 = __webpack_require__(21);\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathFactory = (function () {\n\t    function PathFactory() {\n\t    }\n\t    /** Given a PathNode[], create an TargetState */\n\t    PathFactory.makeTargetState = function (path) {\n\t        var state = common_1.tail(path).state;\n\t        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    PathFactory.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathFactory.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    /**\n\t     * Creates ViewConfig objects and adds to nodes.\n\t     *\n\t     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n\t     */\n\t    PathFactory.applyViewConfigs = function ($view, path, states) {\n\t        // Only apply the viewConfigs to the nodes for the given states\n\t        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n\t            var viewDecls = common_1.values(node.state.views || {});\n\t            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n\t            node.views = viewConfigs.reduce(common_1.unnestR, []);\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t            return common_1.extend({}, node && node.paramValues);\n\t        }\n\t        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (param) { return !param.inherit; })\n\t            .map(hof_1.prop('id'));\n\t        /**\n\t         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        function makeInheritedParamsNode(toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n\t            toParamVals = common_1.omit(toParamVals, toKeys);\n\t            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n\t        }\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode);\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var staticParams = function (state) {\n\t            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n\t        };\n\t        var nodesMatch = function (node1, node2) {\n\t            return node1.equals(node2, staticParams(node1.state));\n\t        };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = node_1.PathNode.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        var retainedWithToParams = retained.map(applyToParams);\n\t        entering = toPath.slice(keep);\n\t        to = (retainedWithToParams).concat(entering);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    /**\n\t     * Return a subpath of a path, which stops at the first matching node\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node,\n\t     * stopping when the first node matches the predicate.\n\t     *\n\t     * @param path a path of [[PathNode]]s\n\t     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n\t     * @returns a subpath up to the matching node, or undefined if no match is found\n\t     */\n\t    PathFactory.subPath = function (path, predicate) {\n\t        var node = common_1.find(path, predicate);\n\t        var elementIdx = path.indexOf(node);\n\t        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n\t    };\n\t    return PathFactory;\n\t}());\n\t/** Gets the raw parameter values from a path */\n\tPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\texports.PathFactory = PathFactory;\n\t//# sourceMappingURL=pathFactory.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module resolve\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar trace_1 = __webpack_require__(15);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\t// TODO: explicitly make this user configurable\n\texports.defaultResolvePolicy = {\n\t    when: \"LAZY\",\n\t    async: \"WAIT\"\n\t};\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(arg1, resolveFn, deps, policy, data) {\n\t        this.resolved = false;\n\t        this.promise = undefined;\n\t        if (arg1 instanceof Resolvable) {\n\t            common_1.extend(this, arg1);\n\t        }\n\t        else if (predicates_1.isFunction(resolveFn)) {\n\t            if (arg1 == null || arg1 == undefined)\n\t                throw new Error(\"new Resolvable(): token argument is required\");\n\t            if (!predicates_1.isFunction(resolveFn))\n\t                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\t            this.token = arg1;\n\t            this.policy = policy;\n\t            this.resolveFn = resolveFn;\n\t            this.deps = deps || [];\n\t            this.data = data;\n\t            this.resolved = data !== undefined;\n\t            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n\t        }\n\t        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n\t            var literal = arg1;\n\t            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n\t        }\n\t    }\n\t    Resolvable.prototype.getPolicy = function (state) {\n\t        var thisPolicy = this.policy || {};\n\t        var statePolicy = state && state.resolvePolicy || {};\n\t        return {\n\t            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n\t            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n\t        };\n\t    };\n\t    /**\n\t     * Asynchronously resolve this Resolvable's data\n\t     *\n\t     * Given a ResolveContext that this Resolvable is found in:\n\t     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n\t     * and update the Resolvable's state\n\t     */\n\t    Resolvable.prototype.resolve = function (resolveContext, trans) {\n\t        var _this = this;\n\t        var $q = coreservices_1.services.$q;\n\t        // Gets all dependencies from ResolveContext and wait for them to be resolved\n\t        var getResolvableDependencies = function () {\n\t            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n\t                return r.get(resolveContext, trans);\n\t            }));\n\t        };\n\t        // Invokes the resolve function passing the resolved dependencies as arguments\n\t        var invokeResolveFn = function (resolvedDeps) {\n\t            return _this.resolveFn.apply(null, resolvedDeps);\n\t        };\n\t        /**\n\t         * For RXWAIT policy:\n\t         *\n\t         * Given an observable returned from a resolve function:\n\t         * - enables .cache() mode (this allows multicast subscribers)\n\t         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n\t         * - Waits for the promise, then return the cached observable (not the first emitted value).\n\t         */\n\t        var waitForRx = function (observable$) {\n\t            var cached = observable$.cache(1);\n\t            return cached.take(1).toPromise().then(function () { return cached; });\n\t        };\n\t        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n\t        var node = resolveContext.findNode(this);\n\t        var state = node && node.state;\n\t        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n\t        // After the final value has been resolved, update the state of the Resolvable\n\t        var applyResolvedValue = function (resolvedValue) {\n\t            _this.data = resolvedValue;\n\t            _this.resolved = true;\n\t            trace_1.trace.traceResolvableResolved(_this, trans);\n\t            return _this.data;\n\t        };\n\t        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\t        return this.promise = $q.when()\n\t            .then(getResolvableDependencies)\n\t            .then(invokeResolveFn)\n\t            .then(maybeWaitForRx)\n\t            .then(applyResolvedValue);\n\t    };\n\t    /**\n\t     * Gets a promise for this Resolvable's data.\n\t     *\n\t     * Fetches the data and returns a promise.\n\t     * Returns the existing promise if it has already been fetched once.\n\t     */\n\t    Resolvable.prototype.get = function (resolveContext, trans) {\n\t        return this.promise || this.resolve(resolveContext, trans);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n\t    };\n\t    Resolvable.prototype.clone = function () {\n\t        return new Resolvable(this);\n\t    };\n\t    return Resolvable;\n\t}());\n\tResolvable.fromData = function (token, data) {\n\t    return new Resolvable(token, function () { return data; }, null, null, data);\n\t};\n\texports.Resolvable = Resolvable;\n\t//# sourceMappingURL=resolvable.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar interface_1 = __webpack_require__(27);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar strings_1 = __webpack_require__(12);\n\tvar when = interface_1.resolvePolicies.when;\n\tvar ALL_WHENS = [when.EAGER, when.LAZY];\n\tvar EAGER_WHENS = [when.EAGER];\n\texports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n\t/**\n\t * Encapsulates Depenency Injection for a path of nodes\n\t *\n\t * UI-Router states are organized as a tree.\n\t * A nested state has a path of ancestors to the root of the tree.\n\t * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n\t * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n\t *\n\t * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n\t */\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t    }\n\t    /** Gets all the tokens found in the resolve context, de-duplicated */\n\t    ResolveContext.prototype.getTokens = function () {\n\t        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n\t    };\n\t    /**\n\t     * Gets the Resolvable that matches the token\n\t     *\n\t     * Gets the last Resolvable that matches the token in this context, or undefined.\n\t     * Throws an error if it doesn't exist in the ResolveContext\n\t     */\n\t    ResolveContext.prototype.getResolvable = function (token) {\n\t        var matching = this._path.map(function (node) { return node.resolvables; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (r) { return r.token === token; });\n\t        return common_1.tail(matching);\n\t    };\n\t    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\t    ResolveContext.prototype.getPolicy = function (resolvable) {\n\t        var node = this.findNode(resolvable);\n\t        return resolvable.getPolicy(node.state);\n\t    };\n\t    /**\n\t     * Returns a ResolveContext that includes a portion of this one\n\t     *\n\t     * Given a state, this method creates a new ResolveContext from this one.\n\t     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n\t     *\n\t     * #### Why\n\t     *\n\t     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n\t     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n\t     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n\t     * This method is used to create a narrower context when injecting ancestor nodes.\n\t     *\n\t     * @example\n\t     * `let ABCD = new ResolveContext([A, B, C, D]);`\n\t     *\n\t     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n\t     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n\t     * However, `B` should only be able to access resolvables from `A`, `B`.\n\t     *\n\t     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n\t     * `let AB = ABCD.subcontext(a)`\n\t     */\n\t    ResolveContext.prototype.subContext = function (state) {\n\t        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n\t    };\n\t    /**\n\t     * Adds Resolvables to the node that matches the state\n\t     *\n\t     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n\t     * The resolvable is added to the node matching the `state` parameter.\n\t     *\n\t     * These new resolvables are not automatically fetched.\n\t     * The calling code should either fetch them, fetch something that depends on them,\n\t     * or rely on [[resolvePath]] being called when some state is being entered.\n\t     *\n\t     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n\t     *\n\t     * @param newResolvables the new Resolvables\n\t     * @param state Used to find the node to put the resolvable on\n\t     */\n\t    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n\t        var node = common_1.find(this._path, hof_1.propEq('state', state));\n\t        var keys = newResolvables.map(function (r) { return r.token; });\n\t        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n\t    };\n\t    /**\n\t     * Returns a promise for an array of resolved path Element promises\n\t     *\n\t     * @param when\n\t     * @param trans\n\t     * @returns {Promise<any>|any}\n\t     */\n\t    ResolveContext.prototype.resolvePath = function (when, trans) {\n\t        var _this = this;\n\t        if (when === void 0) { when = \"LAZY\"; }\n\t        // This option determines which 'when' policy Resolvables we are about to fetch.\n\t        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n\t        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n\t        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\t        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\t        // get the subpath to the state argument, if provided\n\t        trace_1.trace.traceResolvePath(this._path, when, trans);\n\t        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n\t            return function (resolvable) {\n\t                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n\t            };\n\t        };\n\t        // Trigger all the (matching) Resolvables in the path\n\t        // Reduce all the \"WAIT\" Resolvables into an array\n\t        var promises = this._path.reduce(function (acc, node) {\n\t            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n\t            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n\t            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n\t            // For the matching Resolvables, start their async fetch process.\n\t            var subContext = _this.subContext(node.state);\n\t            var getResult = function (r) { return r.get(subContext, trans)\n\t                .then(function (value) { return ({ token: r.token, value: value }); }); };\n\t            nowait.forEach(getResult);\n\t            return acc.concat(wait.map(getResult));\n\t        }, []);\n\t        // Wait for all the \"WAIT\" resolvables\n\t        return coreservices_1.services.$q.all(promises);\n\t    };\n\t    ResolveContext.prototype.injector = function () {\n\t        return this._injector || (this._injector = new UIInjectorImpl(this));\n\t    };\n\t    ResolveContext.prototype.findNode = function (resolvable) {\n\t        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n\t    };\n\t    /**\n\t     * Gets the async dependencies of a Resolvable\n\t     *\n\t     * Given a Resolvable, returns its dependencies as a Resolvable[]\n\t     */\n\t    ResolveContext.prototype.getDependencies = function (resolvable) {\n\t        var _this = this;\n\t        var node = this.findNode(resolvable);\n\t        // Find which other resolvables are \"visible\" to the `resolvable` argument\n\t        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\t        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n\t        var availableResolvables = subPath\n\t            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n\t            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n\t        var getDependency = function (token) {\n\t            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n\t            if (matching.length)\n\t                return common_1.tail(matching);\n\t            var fromInjector = _this.injector().getNative(token);\n\t            if (!fromInjector) {\n\t                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n\t            }\n\t            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n\t        };\n\t        return resolvable.deps.map(getDependency);\n\t    };\n\t    return ResolveContext;\n\t}());\n\texports.ResolveContext = ResolveContext;\n\tvar UIInjectorImpl = (function () {\n\t    function UIInjectorImpl(context) {\n\t        this.context = context;\n\t        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n\t    }\n\t    UIInjectorImpl.prototype.get = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable) {\n\t            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n\t                return resolvable.get(this.context);\n\t            }\n\t            if (!resolvable.resolved) {\n\t                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n\t            }\n\t            return resolvable.data;\n\t        }\n\t        return this.native && this.native.get(token);\n\t    };\n\t    UIInjectorImpl.prototype.getAsync = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable)\n\t            return resolvable.get(this.context);\n\t        return coreservices_1.services.$q.when(this.native.get(token));\n\t    };\n\t    UIInjectorImpl.prototype.getNative = function (token) {\n\t        return this.native && this.native.get(token);\n\t    };\n\t    return UIInjectorImpl;\n\t}());\n\t//# sourceMappingURL=resolveContext.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/** @internalapi */\n\texports.resolvePolicies = {\n\t    when: {\n\t        LAZY: \"LAZY\",\n\t        EAGER: \"EAGER\"\n\t    },\n\t    async: {\n\t        WAIT: \"WAIT\",\n\t        NOWAIT: \"NOWAIT\",\n\t        RXWAIT: \"RXWAIT\"\n\t    }\n\t};\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar urlMatcherFactory_1 = __webpack_require__(29);\n\tvar urlRouter_1 = __webpack_require__(32);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar view_1 = __webpack_require__(43);\n\tvar stateRegistry_1 = __webpack_require__(44);\n\tvar stateService_1 = __webpack_require__(48);\n\tvar globals_1 = __webpack_require__(49);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlService_1 = __webpack_require__(51);\n\tvar trace_1 = __webpack_require__(15);\n\t/** @hidden */\n\tvar _routerInstance = 0;\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n\t * This class instantiates and wires the UI-Router services together.\n\t *\n\t * After a new instance of the UIRouter class is created, it should be configured for your app.\n\t * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n\t *\n\t * ---\n\t *\n\t * Normally the framework code will bootstrap UI-Router.\n\t * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n\t * [[UrlService.listen]] then [[UrlService.sync]].\n\t */\n\tvar UIRouter = (function () {\n\t    /**\n\t     * Creates a new `UIRouter` object\n\t     *\n\t     * @param locationService a [[LocationServices]] implementation\n\t     * @param locationConfig a [[LocationConfig]] implementation\n\t     * @internalapi\n\t     */\n\t    function UIRouter(locationService, locationConfig) {\n\t        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n\t        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n\t        this.locationService = locationService;\n\t        this.locationConfig = locationConfig;\n\t        /** @hidden */\n\t        this.$id = _routerInstance++;\n\t        /** Provides trace information to the console */\n\t        this.trace = trace_1.trace;\n\t        /** Provides services related to ui-view synchronization */\n\t        this.viewService = new view_1.ViewService();\n\t        /** Provides services related to Transitions */\n\t        this.transitionService = new transitionService_1.TransitionService(this);\n\t        /** Global router state */\n\t        this.globals = new globals_1.Globals(this.transitionService);\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlRouter = new urlRouter_1.UrlRouter(this);\n\t        /** Provides a registry for states, and related registration services */\n\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n\t        /** Provides services related to states */\n\t        this.stateService = new stateService_1.StateService(this);\n\t        /** Provides services related to the URL */\n\t        this.urlService = new urlService_1.UrlService(this);\n\t        /** @hidden */\n\t        this._disposables = [];\n\t        /** @hidden */\n\t        this._plugins = {};\n\t        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t        this.disposable(this.transitionService);\n\t        this.disposable(this.urlRouter);\n\t        this.disposable(this.stateRegistry);\n\t        this.disposable(locationService);\n\t        this.disposable(locationConfig);\n\t    }\n\t    /** Registers an object to be notified when the router is disposed */\n\t    UIRouter.prototype.disposable = function (disposable) {\n\t        this._disposables.push(disposable);\n\t    };\n\t    /**\n\t     * Disposes this router instance\n\t     *\n\t     * When called, clears resources retained by the router by calling `dispose(this)` on all\n\t     * registered [[disposable]] objects.\n\t     *\n\t     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n\t     *\n\t     * @param disposable (optional) the disposable to dispose\n\t     */\n\t    UIRouter.prototype.dispose = function (disposable) {\n\t        var _this = this;\n\t        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n\t            disposable.dispose(this);\n\t            return undefined;\n\t        }\n\t        this._disposables.slice().forEach(function (d) {\n\t            try {\n\t                typeof d.dispose === 'function' && d.dispose(_this);\n\t                common_1.removeFrom(_this._disposables, d);\n\t            }\n\t            catch (ignored) { }\n\t        });\n\t    };\n\t    /**\n\t     * Adds a plugin to UI-Router\n\t     *\n\t     * This method adds a UI-Router Plugin.\n\t     * A plugin can enhance or change UI-Router behavior using any public API.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n\t     *\n\t     * var plugin = router.addPlugin(MyCoolPlugin);\n\t     * ```\n\t     *\n\t     * ### Plugin authoring\n\t     *\n\t     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n\t     *\n\t     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n\t     * For example, it may configure router options or add a Transition Hook.\n\t     *\n\t     * The plugin can then be published as a separate module.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * export class MyAuthPlugin implements UIRouterPlugin {\n\t     *   constructor(router: UIRouter, options: any) {\n\t     *     this.name = \"MyAuthPlugin\";\n\t     *     let $transitions = router.transitionService;\n\t     *     let $state = router.stateService;\n\t     *\n\t     *     let authCriteria = {\n\t     *       to: (state) => state.data && state.data.requiresAuth\n\t     *     };\n\t     *\n\t     *     function authHook(transition: Transition) {\n\t     *       let authService = transition.injector().get('AuthService');\n\t     *       if (!authService.isAuthenticated()) {\n\t     *         return $state.target('login');\n\t     *       }\n\t     *     }\n\t     *\n\t     *     $transitions.onStart(authCriteria, authHook);\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @param plugin one of:\n\t     *        - a plugin class which implements [[UIRouterPlugin]]\n\t     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n\t     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n\t     * @param options options to pass to the plugin class/factory\n\t     * @returns the registered plugin instance\n\t     */\n\t    UIRouter.prototype.plugin = function (plugin, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var pluginInstance = new plugin(this, options);\n\t        if (!pluginInstance.name)\n\t            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n\t        this._disposables.push(pluginInstance);\n\t        return this._plugins[pluginInstance.name] = pluginInstance;\n\t    };\n\t    UIRouter.prototype.getPlugin = function (pluginName) {\n\t        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n\t    };\n\t    return UIRouter;\n\t}());\n\texports.UIRouter = UIRouter;\n\t//# sourceMappingURL=router.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar param_1 = __webpack_require__(22);\n\tvar paramTypes_1 = __webpack_require__(31);\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n\t        /** @hidden */ this._isCaseInsensitive = false;\n\t        /** @hidden */ this._isStrictMode = true;\n\t        /** @hidden */ this._defaultSquashPolicy = false;\n\t        /** @hidden */\n\t        this._getConfig = function (config) {\n\t            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n\t        };\n\t        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\t        this.paramFactory = {\n\t            /** Creates a new [[Param]] from a CONFIG block */\n\t            fromConfig: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url PATH */\n\t            fromPath: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url SEARCH */\n\t            fromSearch: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n\t            },\n\t        };\n\t        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n\t    }\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!predicates_1.isObject(object))\n\t            return false;\n\t        var result = true;\n\t        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n\t            if (predicates_1.isFunction(val))\n\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    ;\n\t    /**\n\t     * Creates and registers a custom [[ParamType]] object\n\t     *\n\t     * A [[ParamType]] can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app runtime starts.\n\t     *        The result of this function should be a [[ParamTypeDefinition]].\n\t     *        The result is merged into the existing `definition`.\n\t     *        See [[ParamType]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n\t     *\n\t     * Note: Register custom types *before using them* in a state definition.\n\t     *\n\t     * See [[ParamTypeDefinition]] for examples\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = this.paramTypes.type(name, definition, definitionFn);\n\t        return !predicates_1.isDefined(definition) ? type : this;\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        this.paramTypes.enqueue = false;\n\t        this.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    ;\n\t    /** @internalapi */\n\t    UrlMatcherFactory.prototype.dispose = function () {\n\t        this.paramTypes.dispose();\n\t    };\n\t    return UrlMatcherFactory;\n\t}());\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\t//# sourceMappingURL=urlMatcherFactory.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar param_1 = __webpack_require__(22);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\t/** @hidden */\n\tvar memoizeTo = function (obj, prop, fn) {\n\t    return obj[prop] = obj[prop] || fn();\n\t};\n\t/**\n\t * Matches URLs against patterns.\n\t *\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL.\n\t *\n\t * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n\t * parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by [[UrlMatcher.exec]].\n\t *\n\t * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n\t * or colon placeholders (`/somePath/:param`).\n\t *\n\t * - *A parameter RegExp* may be defined for a param after a colon\n\t * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n\t * The regexp must match for the url to be matched.\n\t * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n\t *\n\t * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n\t *   See [[UrlMatcherFactory.type]] for more information.\n\t *\n\t * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n\t *   A catch-all * parameter value will contain the remainder of the URL.\n\t *\n\t * ---\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters).\n\t * A path parameter matches any number of characters other than '/'. For catch-all\n\t * placeholders the path parameter matches any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t */\n\tvar UrlMatcher = (function () {\n\t    /**\n\t     * @param pattern The pattern to compile into a matcher.\n\t     * @param paramTypes The [[ParamTypes]] registry\n\t     * @param config  A configuration object\n\t     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t     */\n\t    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n\t        var _this = this;\n\t        this.config = config;\n\t        /** @hidden */\n\t        this._cache = { path: [this], parent: null, pattern: null };\n\t        /** @hidden */\n\t        this._children = [];\n\t        /** @hidden */\n\t        this._params = [];\n\t        /** @hidden */\n\t        this._segments = [];\n\t        /** @hidden */\n\t        this._compiled = [];\n\t        this.pattern = pattern;\n\t        this.config = common_1.defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: common_1.identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3];\n\t            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n\t                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t            }); };\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern.substring(last, m.index),\n\t                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n\t    }\n\t    /**\n\t     * Creates a new concatenated UrlMatcher\n\t     *\n\t     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n\t     *\n\t     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        url._cache = {\n\t            path: this._cache.path.concat(url),\n\t            parent: this,\n\t            pattern: null,\n\t        };\n\t        return url;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path[0] === this;\n\t    };\n\t    /** Returns the input pattern string */\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * Tests the specified url/path against this matcher.\n\t     *\n\t     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n\t     * parameter values.  Returns null if the path does not match.\n\t     *\n\t     * The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * ```\n\t     *\n\t     * @param path    The URL path to match, e.g. `$location.path()`.\n\t     * @param search  URL search parameters, e.g. `$location.search()`.\n\t     * @param hash    URL hash e.g. `$location.hash()`.\n\t     * @param options\n\t     *\n\t     * @returns The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = common_1.map(split, reverseString);\n\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        }\n\t        searchParams.forEach(function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values[\"#\"] = hash;\n\t        return values;\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns a single parameter from this UrlMatcher by id\n\t     *\n\t     * @param id\n\t     * @param opts\n\t     * @returns {T|Param|any|boolean|UrlMatcher|null}\n\t     */\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var parent = this._cache.parent;\n\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n\t            null);\n\t    };\n\t    /**\n\t     * Validates the input parameter values against this UrlMatcher\n\t     *\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param params The object hash of parameters to validate.\n\t     * @returns Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var _this = this;\n\t        var validParamVal = function (param, val) {\n\t            return !param || param.validates(val);\n\t        };\n\t        return common_1.pairs(params || {}).map(function (_a) {\n\t            var key = _a[0], val = _a[1];\n\t            return validParamVal(_this.parameter(key), val);\n\t        }).reduce(common_1.allTrueR, true);\n\t    };\n\t    /**\n\t     * Given a set of parameter values, creates a URL from this UrlMatcher.\n\t     *\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * ```\n\t     *\n\t     * @param values  the values to substitute for the parameters in this pattern.\n\t     * @returns the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values) {\n\t        if (values === void 0) { values = {}; }\n\t        if (!this.validates(values))\n\t            return null;\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path;\n\t        // Extract all the static segments and Params into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n\t        /**\n\t         * Given a Param,\n\t         * Applies the parameter value, then returns details about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values[param.id]);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (predicates_1.isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (predicates_1.isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (predicates_1.isArray(encoded))\n\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (param) {\n\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!predicates_1.isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.raw)\n\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val) { return param.id + \"=\" + val; });\n\t        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t    };\n\t    /**\n\t     * Compare two UrlMatchers\n\t     *\n\t     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n\t     * Each static path segment is a static string between a path separator (slash character).\n\t     * Each dynamic segment is a path parameter.\n\t     *\n\t     * The comparison function sorts static segments before dynamic ones.\n\t     */\n\t    UrlMatcher.compare = function (a, b) {\n\t        var splitOnSlash = strings_1.splitOnDelim('/');\n\t        /**\n\t         * Turn a UrlMatcher and all its parent matchers into an array\n\t         * of slash literals '/', string literals, and Param objects\n\t         *\n\t         * This example matcher matches strings like \"/foo/:param/tail\":\n\t         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n\t         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n\t         *\n\t         */\n\t        var segments = function (matcher) {\n\t            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n\t                .reduce(common_1.unnestR, [])\n\t                .reduce(strings_1.joinNeighborsR, [])\n\t                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n\t                .reduce(common_1.unnestR, []);\n\t        };\n\t        var aSegments = segments(a), bSegments = segments(b);\n\t        // console.table( { aSegments, bSegments });\n\t        // Sort slashes first, then static strings, the Params\n\t        var weight = hof_1.pattern([\n\t            [hof_1.eq(\"/\"), hof_1.val(1)],\n\t            [predicates_1.isString, hof_1.val(2)],\n\t            [hof_1.is(param_1.Param), hof_1.val(3)]\n\t        ]);\n\t        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n\t        // console.table(pairs);\n\t        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n\t    };\n\t    return UrlMatcher;\n\t}());\n\t/** @hidden */\n\tUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\texports.UrlMatcher = UrlMatcher;\n\t//# sourceMappingURL=urlMatcher.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\t/**\n\t * A registry for parameter types.\n\t *\n\t * This registry manages the built-in (and custom) parameter types.\n\t *\n\t * The built-in parameter types are:\n\t *\n\t * - [[string]]\n\t * - [[path]]\n\t * - [[query]]\n\t * - [[hash]]\n\t * - [[int]]\n\t * - [[bool]]\n\t * - [[date]]\n\t * - [[json]]\n\t * - [[any]]\n\t */\n\tvar ParamTypes = (function () {\n\t    /** @internalapi */\n\t    function ParamTypes() {\n\t        /** @hidden */\n\t        this.enqueue = true;\n\t        /** @hidden */\n\t        this.typeQueue = [];\n\t        /** @internalapi */\n\t        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) {\n\t            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        };\n\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t    }\n\t    /** @internalapi */\n\t    ParamTypes.prototype.dispose = function () {\n\t        this.types = {};\n\t    };\n\t    /**\n\t     * Registers a parameter type\n\t     *\n\t     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n\t     */\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!predicates_1.isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    /** @internalapi */\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\texports.ParamTypes = ParamTypes;\n\t/** @hidden */\n\tfunction initDefaultTypes() {\n\t    var makeDefaultType = function (def) {\n\t        var valToString = function (val) {\n\t            return val != null ? val.toString() : val;\n\t        };\n\t        var defaultTypeBase = {\n\t            encode: valToString,\n\t            decode: valToString,\n\t            is: hof_1.is(String),\n\t            pattern: /.*/,\n\t            equals: function (a, b) { return a == b; },\n\t        };\n\t        return common_1.extend({}, defaultTypeBase, def);\n\t    };\n\t    // Default Parameter Type Definitions\n\t    common_1.extend(ParamTypes.prototype, {\n\t        string: makeDefaultType({}),\n\t        path: makeDefaultType({\n\t            pattern: /[^/]*/,\n\t        }),\n\t        query: makeDefaultType({}),\n\t        hash: makeDefaultType({\n\t            inherit: false,\n\t        }),\n\t        int: makeDefaultType({\n\t            decode: function (val) { return parseInt(val, 10); },\n\t            is: function (val) {\n\t                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n\t            },\n\t            pattern: /-?\\d+/,\n\t        }),\n\t        bool: makeDefaultType({\n\t            encode: function (val) { return val && 1 || 0; },\n\t            decode: function (val) { return parseInt(val, 10) !== 0; },\n\t            is: hof_1.is(Boolean),\n\t            pattern: /0|1/\n\t        }),\n\t        date: makeDefaultType({\n\t            encode: function (val) {\n\t                return !this.is(val) ? undefined : [\n\t                    val.getFullYear(),\n\t                    ('0' + (val.getMonth() + 1)).slice(-2),\n\t                    ('0' + val.getDate()).slice(-2)\n\t                ].join(\"-\");\n\t            },\n\t            decode: function (val) {\n\t                if (this.is(val))\n\t                    return val;\n\t                var match = this.capture.exec(val);\n\t                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t            },\n\t            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t            equals: function (l, r) {\n\t                return ['getFullYear', 'getMonth', 'getDate']\n\t                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t            },\n\t            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t        }),\n\t        json: makeDefaultType({\n\t            encode: common_1.toJson,\n\t            decode: common_1.fromJson,\n\t            is: hof_1.is(Object),\n\t            equals: common_1.equals,\n\t            pattern: /[^/]*/\n\t        }),\n\t        // does not encode/decode\n\t        any: makeDefaultType({\n\t            encode: common_1.identity,\n\t            decode: common_1.identity,\n\t            is: function () { return true; },\n\t            equals: common_1.equals,\n\t        }),\n\t    });\n\t}\n\tinitDefaultTypes();\n\t//# sourceMappingURL=paramTypes.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar hof_1 = __webpack_require__(8);\n\tvar urlRule_1 = __webpack_require__(33);\n\tvar targetState_1 = __webpack_require__(18);\n\t/** @hidden */\n\tfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t/** @hidden */\n\tvar getMatcher = hof_1.prop(\"urlMatcher\");\n\t/**\n\t * Default rule priority sorting function.\n\t *\n\t * Sorts rules by:\n\t *\n\t * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n\t * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n\t * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n\t * - Registration order (for rule types other than STATE and URLMATCHER)\n\t *\n\t * @coreapi\n\t */\n\tvar defaultRuleSortFn;\n\tdefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n\t/**\n\t * Updates URL and responds to URL changes\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class updates the URL when the state changes.\n\t * It also responds to changes in the URL.\n\t */\n\tvar UrlRouter = (function () {\n\t    /** @hidden */\n\t    function UrlRouter(router) {\n\t        /** @hidden */ this._sortFn = defaultRuleSortFn;\n\t        /** @hidden */ this._rules = [];\n\t        /** @hidden */ this.interceptDeferred = false;\n\t        /** @hidden */ this._id = 0;\n\t        this._router = router;\n\t        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n\t        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n\t    }\n\t    /** @internalapi */\n\t    UrlRouter.prototype.dispose = function () {\n\t        this.listen(false);\n\t        this._rules = [];\n\t        delete this._otherwiseFn;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sort = function (compareFn) {\n\t        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n\t    };\n\t    /**\n\t     * Given a URL, check all rules and return the best [[MatchResult]]\n\t     * @param url\n\t     * @returns {MatchResult}\n\t     */\n\t    UrlRouter.prototype.match = function (url) {\n\t        var _this = this;\n\t        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n\t        var rules = this.rules();\n\t        if (this._otherwiseFn)\n\t            rules.push(this._otherwiseFn);\n\t        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n\t        var checkRule = function (rule) {\n\t            var match = rule.match(url, _this._router);\n\t            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n\t        };\n\t        // The rules are pre-sorted.\n\t        // - Find the first matching rule.\n\t        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n\t        // - Choose the rule with the highest match weight.\n\t        var best;\n\t        for (var i = 0; i < rules.length; i++) {\n\t            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n\t            if (best && this._sortFn(rules[i], best.rule) !== 0)\n\t                break;\n\t            var current = checkRule(rules[i]);\n\t            // Pick the best MatchResult\n\t            best = (!best || current && current.weight > best.weight) ? current : best;\n\t        }\n\t        return best;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sync = function (evt) {\n\t        if (evt && evt.defaultPrevented)\n\t            return;\n\t        var router = this._router, $url = router.urlService, $state = router.stateService;\n\t        var url = {\n\t            path: $url.path(), search: $url.search(), hash: $url.hash()\n\t        };\n\t        var best = this.match(url);\n\t        var applyResult = hof_1.pattern([\n\t            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n\t            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n\t            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n\t        ]);\n\t        applyResult(best && best.rule.handler(best.match, url, router));\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.listen = function (enabled) {\n\t        var _this = this;\n\t        if (enabled === false) {\n\t            this._stopFn && this._stopFn();\n\t            delete this._stopFn;\n\t        }\n\t        else {\n\t            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n\t        }\n\t    };\n\t    /**\n\t     * Internal API.\n\t     * @internalapi\n\t     */\n\t    UrlRouter.prototype.update = function (read) {\n\t        var $url = this._router.locationService;\n\t        if (read) {\n\t            this.location = $url.path();\n\t            return;\n\t        }\n\t        if ($url.path() === this.location)\n\t            return;\n\t        $url.url(this.location, true);\n\t    };\n\t    /**\n\t     * Internal API.\n\t     *\n\t     * Pushes a new location to the browser history.\n\t     *\n\t     * @internalapi\n\t     * @param urlMatcher\n\t     * @param params\n\t     * @param options\n\t     */\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        var replace = options && !!options.replace;\n\t        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n\t    };\n\t    /**\n\t     * Builds and returns a URL with interpolated parameters\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * matcher = $umf.compile(\"/about/:person\");\n\t     * params = { person: \"bob\" };\n\t     * $bob = $urlRouter.href(matcher, params);\n\t     * // $bob == \"/about/bob\";\n\t     * ```\n\t     *\n\t     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n\t     * @param params An object of parameter values to fill the matcher's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params))\n\t            return null;\n\t        var url = urlMatcher.format(params);\n\t        options = options || { absolute: false };\n\t        var cfg = this._router.urlService.config;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    /**\n\t     * Manually adds a URL Rule.\n\t     *\n\t     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n\t     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n\t     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n\t     *\n\t     * A rule should have a `match` function which returns truthy if the rule matched.\n\t     * It should also have a `handler` function which is invoked if the rule is the best match.\n\t     *\n\t     * @return a function that deregisters the rule\n\t     */\n\t    UrlRouter.prototype.rule = function (rule) {\n\t        var _this = this;\n\t        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n\t            throw new Error(\"invalid rule\");\n\t        rule.$id = this._id++;\n\t        rule.priority = rule.priority || 0;\n\t        this._rules.push(rule);\n\t        this.sort();\n\t        return function () { return _this.removeRule(rule); };\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.removeRule = function (rule) {\n\t        common_1.removeFrom(this._rules, rule);\n\t        this.sort();\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.otherwise = function (handler) {\n\t        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n\t            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n\t        }\n\t        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n\t        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n\t        this.sort();\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.when = function (matcher, handler, options) {\n\t        var rule = this.urlRuleFactory.create(matcher, handler);\n\t        if (predicates_1.isDefined(options && options.priority))\n\t            rule.priority = options.priority;\n\t        this.rule(rule);\n\t        return rule;\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    ;\n\t    return UrlRouter;\n\t}());\n\texports.UrlRouter = UrlRouter;\n\t//# sourceMappingURL=urlRouter.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/**\n\t * Creates a [[UrlRule]]\n\t *\n\t * Creates a [[UrlRule]] from a:\n\t *\n\t * - `string`\n\t * - [[UrlMatcher]]\n\t * - `RegExp`\n\t * - [[State]]\n\t * @internalapi\n\t */\n\tvar UrlRuleFactory = (function () {\n\t    function UrlRuleFactory(router) {\n\t        this.router = router;\n\t    }\n\t    UrlRuleFactory.prototype.compile = function (str) {\n\t        return this.router.urlMatcherFactory.compile(str);\n\t    };\n\t    UrlRuleFactory.prototype.create = function (what, handler) {\n\t        var _this = this;\n\t        var makeRule = hof_1.pattern([\n\t            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n\t            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n\t            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n\t            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n\t            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n\t        ]);\n\t        var rule = makeRule(what);\n\t        if (!rule)\n\t            throw new Error(\"invalid 'what' in when()\");\n\t        return rule;\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a UrlMatcher\n\t     *\n\t     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     *\n\t     * ## Handler as UrlMatcher\n\t     *\n\t     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n\t     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n\t     * The url is replaced with the result.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n\t        var _handler = handler;\n\t        if (predicates_1.isString(handler))\n\t            handler = this.router.urlMatcherFactory.compile(handler);\n\t        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n\t            _handler = function (match) { return handler.format(match); };\n\t        function match(url) {\n\t            var match = urlMatcher.exec(url.path, url.search, url.hash);\n\t            return urlMatcher.validates(match) && match;\n\t        }\n\t        // Prioritize URLs, lowest to highest:\n\t        // - Some optional URL parameters, but none matched\n\t        // - No optional parameters in URL\n\t        // - Some optional parameters, some matched\n\t        // - Some optional parameters, all matched\n\t        function matchPriority(params) {\n\t            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n\t            if (!optional.length)\n\t                return 0.000001;\n\t            var matched = optional.filter(function (param) { return params[param.id]; });\n\t            return matched.length / optional.length;\n\t        }\n\t        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches a state by its url\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromState($state.get('foo'), router);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match);\n\t     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromState = function (state, router) {\n\t        /**\n\t         * Handles match by transitioning to matched state\n\t         *\n\t         * First checks if the router should start a new transition.\n\t         * A new transition is not required if the current state's URL\n\t         * and the new URL are already identical\n\t         */\n\t        var handler = function (match) {\n\t            var $state = router.stateService;\n\t            var globals = router.globals;\n\t            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n\t                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n\t            }\n\t        };\n\t        var details = { state: state, type: \"STATE\" };\n\t        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a regular expression\n\t     *\n\t     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - regexp match array (from `regexp`)\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     *\n\t     * ## Handler as string\n\t     *\n\t     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n\t     * The string is first interpolated using `string.replace()` style pattern.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n\t        if (regexp.global || regexp.sticky)\n\t            throw new Error(\"Rule RegExp must not be global or sticky\");\n\t        /**\n\t         * If handler is a string, the url will be replaced by the string.\n\t         * If the string has any String.replace() style variables in it (like `$2`),\n\t         * they will be replaced by the captures from [[match]]\n\t         */\n\t        var redirectUrlTo = function (match) {\n\t            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n\t            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t                return match[what === '$' ? 0 : Number(what)];\n\t            });\n\t        };\n\t        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n\t        var match = function (url) {\n\t            return regexp.exec(url.path);\n\t        };\n\t        var details = { regexp: regexp, type: \"REGEXP\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    return UrlRuleFactory;\n\t}());\n\tUrlRuleFactory.isUrlRule = function (obj) {\n\t    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n\t};\n\texports.UrlRuleFactory = UrlRuleFactory;\n\t/**\n\t * A base rule which calls `match`\n\t *\n\t * The value from the `match` function is passed through to the `handler`.\n\t * @internalapi\n\t */\n\tvar BaseUrlRule = (function () {\n\t    function BaseUrlRule(match, handler) {\n\t        var _this = this;\n\t        this.match = match;\n\t        this.type = \"RAW\";\n\t        this.matchPriority = function (match) { return 0 - _this.$id; };\n\t        this.handler = handler || common_1.identity;\n\t    }\n\t    return BaseUrlRule;\n\t}());\n\texports.BaseUrlRule = BaseUrlRule;\n\t//# sourceMappingURL=urlRule.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Internal representation of a UI-Router state.\n\t *\n\t * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n\t *\n\t * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n\t *\n\t * This class prototypally inherits from the corresponding [[StateDeclaration]].\n\t * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n\t */\n\tvar State = (function () {\n\t    function State(config) {\n\t        common_1.extend(this, config);\n\t        // Object.freeze(this);\n\t    }\n\t    /**\n\t     * Returns true if the provided parameter is the same state.\n\t     *\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    State.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @deprecated this does not properly handle dot notation\n\t     * @returns Returns a dot-separated name of the state.\n\t     */\n\t    State.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns The root of this state's tree.\n\t     */\n\t    State.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    /**\n\t     * Gets the state's `Param`eters\n\t     *\n\t     * Gets [[Param]] information that is owned by the state.\n\t     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n\t     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n\t     *\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameters = function (opts) {\n\t        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(common_1.values(this.params))\n\t            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n\t    };\n\t    /**\n\t     * Returns a single [[Param]] that is owned by the state\n\t     *\n\t     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n\t     * @param id the name of the [[Param]] to return\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    State.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    return State;\n\t}());\n\texports.State = State;\n\t//# sourceMappingURL=stateObject.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar interface_1 = __webpack_require__(16);\n\tvar transition_1 = __webpack_require__(14);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar resolve_1 = __webpack_require__(36);\n\tvar views_1 = __webpack_require__(37);\n\tvar url_1 = __webpack_require__(38);\n\tvar redirectTo_1 = __webpack_require__(39);\n\tvar onEnterExitRetain_1 = __webpack_require__(40);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar transitionEventType_1 = __webpack_require__(42);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * The default [[Transition]] options.\n\t *\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\texports.defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; },\n\t    source: \"unknown\"\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * - Most importantly, it allows global Transition Hooks to be registered.\n\t * - It allows the default transition error handler to be set.\n\t * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n\t *\n\t * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n\t */\n\tvar TransitionService = (function () {\n\t    /** @hidden */\n\t    function TransitionService(_router) {\n\t        /** @hidden */\n\t        this._transitionCount = 0;\n\t        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n\t        this._eventTypes = [];\n\t        /** @hidden The registered transition hooks */\n\t        this._registeredHooks = {};\n\t        /** @hidden The  paths on a criteria object */\n\t        this._criteriaPaths = {};\n\t        this._router = _router;\n\t        this.$view = _router.viewService;\n\t        this._deregisterHookFns = {};\n\t        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n\t            '_definePathType',\n\t            '_defineEvent',\n\t            '_getPathTypes',\n\t            '_getEvents',\n\t            'getHooks',\n\t        ]);\n\t        this._defineDefaultPaths();\n\t        this._defineDefaultEvents();\n\t        this._registerDefaultTransitionHooks();\n\t    }\n\t    /**\n\t     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n\t     *\n\t     * Registers a transition lifecycle hook, which is invoked during transition construction.\n\t     *\n\t     * This low level hook should only be used by plugins.\n\t     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n\t     * The Sticky States plugin uses this hook to modify the treechanges.\n\t     *\n\t     * ### Lifecycle\n\t     *\n\t     * `onCreate` hooks are invoked *while a transition is being constructed*.\n\t     *\n\t     * ### Return value\n\t     *\n\t     * The hook's return value is ignored\n\t     *\n\t     * @internalapi\n\t     * @param criteria defines which Transitions the Hook should be invoked for.\n\t     * @param callback the hook function which will be invoked.\n\t     * @param options the registration options\n\t     * @returns a function which deregisters the hook.\n\t     */\n\t    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n\t    /**\n\t     * dispose\n\t     * @internalapi\n\t     */\n\t    TransitionService.prototype.dispose = function (router) {\n\t        delete router.globals.transition;\n\t        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n\t            hook._deregistered = true;\n\t            common_1.removeFrom(hooksArray, hook);\n\t        }); });\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     * It is used internally by the [[StateService]] and should generally not be called by application code.\n\t     *\n\t     * @param fromPath the path to the current state (the from state)\n\t     * @param targetState the target state (destination)\n\t     * @returns a Transition\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new transition_1.Transition(fromPath, targetState, this._router);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultEvents = function () {\n\t        var Phase = interface_1.TransitionHookPhase;\n\t        var TH = transitionHook_1.TransitionHook;\n\t        var paths = this._criteriaPaths;\n\t        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n\t        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n\t        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n\t        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n\t        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n\t        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n\t        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n\t        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultPaths = function () {\n\t        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n\t        this._definePathType(\"to\", TRANSITION);\n\t        this._definePathType(\"from\", TRANSITION);\n\t        this._definePathType(\"exiting\", STATE);\n\t        this._definePathType(\"retained\", STATE);\n\t        this._definePathType(\"entering\", STATE);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n\t        this._eventTypes.push(eventType);\n\t        hookRegistry_1.makeEvent(this, this, eventType);\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    TransitionService.prototype._getEvents = function (phase) {\n\t        var transitionHookTypes = predicates_1.isDefined(phase) ?\n\t            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n\t            this._eventTypes.slice();\n\t        return transitionHookTypes.sort(function (l, r) {\n\t            var cmpByPhase = l.hookPhase - r.hookPhase;\n\t            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n\t        });\n\t    };\n\t    /**\n\t     * Adds a Path to be used as a criterion against a TreeChanges path\n\t     *\n\t     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n\t     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n\t     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * @hidden\n\t     */\n\t    TransitionService.prototype._definePathType = function (name, hookScope) {\n\t        this._criteriaPaths[name] = { name: name, scope: hookScope };\n\t    };\n\t    /** * @hidden */\n\t    TransitionService.prototype._getPathTypes = function () {\n\t        return this._criteriaPaths;\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n\t        var fns = this._deregisterHookFns;\n\t        // Wire up redirectTo hook\n\t        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n\t        // Wire up onExit/Retain/Enter state hooks\n\t        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n\t        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n\t        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n\t        // Wire up Resolve hooks\n\t        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n\t        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n\t        // Wire up the View management hooks\n\t        fns.loadViews = views_1.registerLoadEnteringViews(this);\n\t        fns.activateViews = views_1.registerActivateViews(this);\n\t        // After globals.current is updated at priority: 10000\n\t        fns.updateUrl = url_1.registerUpdateUrl(this);\n\t        // Lazy load state trees\n\t        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n\t    };\n\t    return TransitionService;\n\t}());\n\texports.TransitionService = TransitionService;\n\t//# sourceMappingURL=transitionService.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n\t *\n\t * Registered using `transitionService.onStart({}, eagerResolvePath);`\n\t *\n\t * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar eagerResolvePath = function (trans) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .resolvePath(\"EAGER\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerEagerResolvePath = function (transitionService) {\n\t    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n\t *\n\t * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n\t *\n\t * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar lazyResolveState = function (trans, state) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .subContext(state)\n\t        .resolvePath(\"LAZY\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerLazyResolveState = function (transitionService) {\n\t    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n\t};\n\t//# sourceMappingURL=resolve.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] which waits for the views to load\n\t *\n\t * Registered using `transitionService.onStart({}, loadEnteringViews);`\n\t *\n\t * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n\t * In angular 1, this includes loading the templates.\n\t */\n\tvar loadEnteringViews = function (transition) {\n\t    var $q = coreservices_1.services.$q;\n\t    var enteringViews = transition.views(\"entering\");\n\t    if (!enteringViews.length)\n\t        return;\n\t    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n\t};\n\texports.registerLoadEnteringViews = function (transitionService) {\n\t    return transitionService.onFinish({}, loadEnteringViews);\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n\t *\n\t * Registered using `transitionService.onSuccess({}, activateViews);`\n\t *\n\t * After a transition is complete, this hook deactivates the old views from the previous state,\n\t * and activates the new views from the destination state.\n\t *\n\t * See [[ViewService]]\n\t */\n\tvar activateViews = function (transition) {\n\t    var enteringViews = transition.views(\"entering\");\n\t    var exitingViews = transition.views(\"exiting\");\n\t    if (!enteringViews.length && !exitingViews.length)\n\t        return;\n\t    var $view = transition.router.viewService;\n\t    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n\t    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n\t    $view.sync();\n\t};\n\texports.registerActivateViews = function (transitionService) {\n\t    return transitionService.onSuccess({}, activateViews);\n\t};\n\t//# sourceMappingURL=views.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A [[TransitionHookFn]] which updates the URL after a successful transition\n\t *\n\t * Registered using `transitionService.onSuccess({}, updateUrl);`\n\t */\n\tvar updateUrl = function (transition) {\n\t    var options = transition.options();\n\t    var $state = transition.router.stateService;\n\t    var $urlRouter = transition.router.urlRouter;\n\t    // Dont update the url in these situations:\n\t    // The transition was triggered by a URL sync (options.source === 'url')\n\t    // The user doesn't want the url to update (options.location === false)\n\t    // The destination state, and all parents have no navigable url\n\t    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n\t        var urlOptions = { replace: options.location === 'replace' };\n\t        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n\t    }\n\t    $urlRouter.update(true);\n\t};\n\texports.registerUpdateUrl = function (transitionService) {\n\t    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n\t};\n\t//# sourceMappingURL=url.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar targetState_1 = __webpack_require__(18);\n\t/**\n\t * A [[TransitionHookFn]] that redirects to a different state or params\n\t *\n\t * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n\t *\n\t * See [[StateDeclaration.redirectTo]]\n\t */\n\tvar redirectToHook = function (trans) {\n\t    var redirect = trans.to().redirectTo;\n\t    if (!redirect)\n\t        return;\n\t    var $state = trans.router.stateService;\n\t    function handleResult(result) {\n\t        if (!result)\n\t            return;\n\t        if (result instanceof targetState_1.TargetState)\n\t            return result;\n\t        if (predicates_1.isString(result))\n\t            return $state.target(result, trans.params(), trans.options());\n\t        if (result['state'] || result['params'])\n\t            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n\t    }\n\t    if (predicates_1.isFunction(redirect)) {\n\t        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n\t    }\n\t    return handleResult(redirect);\n\t};\n\texports.registerRedirectToHook = function (transitionService) {\n\t    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n\t};\n\t//# sourceMappingURL=redirectTo.js.map\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A factory which creates an onEnter, onExit or onRetain transition hook function\n\t *\n\t * The returned function invokes the (for instance) state.onEnter hook when the\n\t * state is being entered.\n\t *\n\t * @hidden\n\t */\n\tfunction makeEnterExitRetainHook(hookName) {\n\t    return function (transition, state) {\n\t        var hookFn = state[hookName];\n\t        return hookFn(transition, state);\n\t    };\n\t}\n\t/**\n\t * The [[TransitionStateHookFn]] for onExit\n\t *\n\t * When the state is being exited, the state's .onExit function is invoked.\n\t *\n\t * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n\t *\n\t * See: [[IHookRegistry.onExit]]\n\t */\n\tvar onExitHook = makeEnterExitRetainHook('onExit');\n\texports.registerOnExitHook = function (transitionService) {\n\t    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onRetain\n\t *\n\t * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n\t *\n\t * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n\t *\n\t * See: [[IHookRegistry.onRetain]]\n\t */\n\tvar onRetainHook = makeEnterExitRetainHook('onRetain');\n\texports.registerOnRetainHook = function (transitionService) {\n\t    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onEnter\n\t *\n\t * When the state is being entered, the state's .onEnter function is invoked.\n\t *\n\t * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n\t *\n\t * See: [[IHookRegistry.onEnter]]\n\t */\n\tvar onEnterHook = makeEnterExitRetainHook('onEnter');\n\texports.registerOnEnterHook = function (transitionService) {\n\t    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n\t};\n\t//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] that performs lazy loading\n\t *\n\t * When entering a state \"abc\" which has a `lazyLoad` function defined:\n\t * - Invoke the `lazyLoad` function (unless it is already in process)\n\t *   - Flag the hook function as \"in process\"\n\t *   - The function should return a promise (that resolves when lazy loading is complete)\n\t * - Wait for the promise to settle\n\t *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n\t *   - Flag the hook function as \"not in process\"\n\t * - If the hook was successful\n\t *   - Remove the `lazyLoad` function from the state declaration\n\t * - If all the hooks were successful\n\t *   - Retry the transition (by returning a TargetState)\n\t *\n\t * ```\n\t * .state('abc', {\n\t *   component: 'fooComponent',\n\t *   lazyLoad: () => System.import('./fooComponent')\n\t *   });\n\t * ```\n\t *\n\t * See [[StateDeclaration.lazyLoad]]\n\t */\n\tvar lazyLoadHook = function (transition) {\n\t    var router = transition.router;\n\t    function retryTransition() {\n\t        if (transition.originalTransition().options().source !== 'url') {\n\t            // The original transition was not triggered via url sync\n\t            // The lazy state should be loaded now, so re-try the original transition\n\t            var orig = transition.targetState();\n\t            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n\t        }\n\t        // The original transition was triggered via url sync\n\t        // Run the URL rules and find the best match\n\t        var $url = router.urlService;\n\t        var result = $url.match($url.parts());\n\t        var rule = result && result.rule;\n\t        // If the best match is a state, redirect the transition (instead\n\t        // of calling sync() which supersedes the current transition)\n\t        if (rule && rule.type === \"STATE\") {\n\t            var state = rule.state;\n\t            var params = result.match;\n\t            return router.stateService.target(state, params, transition.options());\n\t        }\n\t        // No matching state found, so let .sync() choose the best non-state match/otherwise\n\t        router.urlService.sync();\n\t    }\n\t    var promises = transition.entering()\n\t        .filter(function (state) { return !!state.$$state().lazyLoad; })\n\t        .map(function (state) { return lazyLoadState(transition, state); });\n\t    return coreservices_1.services.$q.all(promises).then(retryTransition);\n\t};\n\texports.registerLazyLoadHook = function (transitionService) {\n\t    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n\t};\n\t/**\n\t * Invokes a state's lazy load function\n\t *\n\t * @param transition a Transition context\n\t * @param state the state to lazy load\n\t * @returns A promise for the lazy load result\n\t */\n\tfunction lazyLoadState(transition, state) {\n\t    var lazyLoadFn = state.$$state().lazyLoad;\n\t    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\t    var promise = lazyLoadFn['_promise'];\n\t    if (!promise) {\n\t        var success = function (result) {\n\t            delete state.lazyLoad;\n\t            delete state.$$state().lazyLoad;\n\t            delete lazyLoadFn['_promise'];\n\t            return result;\n\t        };\n\t        var error = function (err) {\n\t            delete lazyLoadFn['_promise'];\n\t            return coreservices_1.services.$q.reject(err);\n\t        };\n\t        promise = lazyLoadFn['_promise'] =\n\t            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n\t                .then(updateStateRegistry)\n\t                .then(success, error);\n\t    }\n\t    /** Register any lazy loaded state definitions */\n\t    function updateStateRegistry(result) {\n\t        if (result && Array.isArray(result.states)) {\n\t            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n\t        }\n\t        return result;\n\t    }\n\t    return promise;\n\t}\n\texports.lazyLoadState = lazyLoadState;\n\t//# sourceMappingURL=lazyLoad.js.map\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class defines a type of hook, such as `onBefore` or `onEnter`.\n\t * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n\t *\n\t * @interalapi\n\t */\n\tvar TransitionEventType = (function () {\n\t    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        this.name = name;\n\t        this.hookPhase = hookPhase;\n\t        this.hookOrder = hookOrder;\n\t        this.criteriaMatchPath = criteriaMatchPath;\n\t        this.reverseSort = reverseSort;\n\t        this.getResultHandler = getResultHandler;\n\t        this.getErrorHandler = getErrorHandler;\n\t        this.rejectIfSuperseded = rejectIfSuperseded;\n\t    }\n\t    return TransitionEventType;\n\t}());\n\texports.TransitionEventType = TransitionEventType;\n\t//# sourceMappingURL=transitionEventType.js.map\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module view\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar trace_1 = __webpack_require__(15);\n\t/**\n\t * The View service\n\t *\n\t * This service pairs existing `ui-view` components (which live in the DOM)\n\t * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n\t *\n\t * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n\t *   The views from exited states are deactivated via [[deactivateViewConfig]].\n\t *   (See: the [[registerActivateViews]] Transition Hook)\n\t *\n\t * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n\t *\n\t * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n\t * are configured with the matching [[ViewConfig]](s)\n\t *\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this._uiViews = [];\n\t        this._viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this._pluginapi = {\n\t            _rootViewContext: this._rootViewContext.bind(this),\n\t            _viewConfigFactory: this._viewConfigFactory.bind(this),\n\t            _registeredUIViews: function () { return _this._uiViews; },\n\t            _activeViewConfigs: function () { return _this._viewConfigs; },\n\t        };\n\t    }\n\t    ViewService.prototype._rootViewContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    ;\n\t    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (path, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(path, decl);\n\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * Deactivates a ViewConfig.\n\t     *\n\t     * This function deactivates a `ViewConfig`.\n\t     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        common_1.removeFrom(this._viewConfigs, viewConfig);\n\t    };\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this._viewConfigs.push(viewConfig);\n\t    };\n\t    ViewService.prototype.sync = function () {\n\t        var _this = this;\n\t        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t        // Return the number of dots in the fully qualified name\n\t        function uiViewDepth(uiView) {\n\t            return uiView.fqn.split(\".\").length;\n\t        }\n\t        // Return the ViewConfig's context's depth in the context tree.\n\t        function viewConfigDepth(config) {\n\t            var context = config.viewDecl.$context, count = 0;\n\t            while (++count && context.parent)\n\t                context = context.parent;\n\t            return count;\n\t        }\n\t        // Given a depth function, returns a compare function which can return either ascending or descending order\n\t        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t        var matchingConfigPair = function (uiView) {\n\t            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n\t            if (matchingConfigs.length > 1) {\n\t                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n\t                // Sort by depth and return the match from the deepest child\n\t                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n\t                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t            }\n\t            return [uiView, matchingConfigs[0]];\n\t        };\n\t        var configureUIView = function (_a) {\n\t            var uiView = _a[0], viewConfig = _a[1];\n\t            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t            if (_this._uiViews.indexOf(uiView) !== -1)\n\t                uiView.configUpdated(viewConfig);\n\t        };\n\t        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n\t    };\n\t    ;\n\t    /**\n\t     * Registers a `ui-view` component\n\t     *\n\t     * When a `ui-view` component is created, it uses this method to register itself.\n\t     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n\t     *\n\t     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n\t     * and what the view's state context is.\n\t     *\n\t     * Note: There is no corresponding `deregisterUIView`.\n\t     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n\t     *\n\t     * @param uiView The metadata for a UIView\n\t     * @return a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUIView = function (uiView) {\n\t        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this._uiViews;\n\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t        if (uiViews.filter(fqnMatches).length)\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx === -1) {\n\t                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n\t            common_1.removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    ;\n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this._uiViews.map(hof_1.prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * This should be used by a framework implementation to calculate the values for\n\t     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        else if (uiViewContextAnchor === '.') {\n\t            uiViewContextAnchor = context.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    return ViewService;\n\t}());\n\t/**\n\t * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t *\n\t * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t *\n\t * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t *\n\t * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t *\n\t * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t * - the ui-view's name matches the ViewConfig's target name\n\t * - the ui-view's context matches the ViewConfig's anchor\n\t *\n\t * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t * - There exists a parent ui-view where:\n\t *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t *    - the parent ui-view's context matches the ViewConfig's anchor\n\t * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t *\n\t * Example:\n\t *\n\t * DOM:\n\t * <ui-view>                        <!-- created in the root context (name: \"\") -->\n\t *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t *       </ui-view>\n\t *     </ui-view>\n\t *   </ui-view>\n\t * </ui-view>\n\t *\n\t * uiViews: [\n\t *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t * ]\n\t *\n\t * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t *\n\t * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t *\n\t * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t *   the tail of the ui-view's fqn \"default.bar\"\n\t *\n\t * @internalapi\n\t */\n\tViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n\t    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t    if (uiView.$type !== viewConfig.viewDecl.$type)\n\t        return false;\n\t    // Split names apart from both viewConfig and uiView into segments\n\t    var vc = viewConfig.viewDecl;\n\t    var vcSegments = vc.$uiViewName.split(\".\");\n\t    var uivSegments = uiView.fqn.split(\".\");\n\t    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t        return false;\n\t    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t    var negOffset = (1 - vcSegments.length) || undefined;\n\t    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t}; };\n\texports.ViewService = ViewService;\n\t//# sourceMappingURL=view.js.map\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar stateMatcher_1 = __webpack_require__(45);\n\tvar stateBuilder_1 = __webpack_require__(46);\n\tvar stateQueueManager_1 = __webpack_require__(47);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar StateRegistry = (function () {\n\t    /** @internalapi */\n\t    function StateRegistry(_router) {\n\t        this._router = _router;\n\t        this.states = {};\n\t        this.listeners = [];\n\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n\t        this._registerRoot();\n\t    }\n\t    /** @internalapi */\n\t    StateRegistry.prototype._registerRoot = function () {\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    };\n\t    /** @internalapi */\n\t    StateRegistry.prototype.dispose = function () {\n\t        var _this = this;\n\t        this.stateQueue.dispose();\n\t        this.listeners = [];\n\t        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n\t    };\n\t    /**\n\t     * Listen for a State Registry events\n\t     *\n\t     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let allStates = registry.get();\n\t     *\n\t     * // Later, invoke deregisterFn() to remove the listener\n\t     * let deregisterFn = registry.onStatesChanged((event, states) => {\n\t     *   switch(event) {\n\t     *     case: 'registered':\n\t     *       states.forEach(state => allStates.push(state));\n\t     *       break;\n\t     *     case: 'deregistered':\n\t     *       states.forEach(state => {\n\t     *         let idx = allStates.indexOf(state);\n\t     *         if (idx !== -1) allStates.splice(idx, 1);\n\t     *       });\n\t     *       break;\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param listener a callback function invoked when the registered states changes.\n\t     *        The function receives two parameters, `event` and `state`.\n\t     *        See [[StateRegistryListener]]\n\t     * @return a function that deregisters the listener\n\t     */\n\t    StateRegistry.prototype.onStatesChanged = function (listener) {\n\t        this.listeners.push(listener);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.listeners)(listener);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Gets the implicit root state\n\t     *\n\t     * Gets the root of the state tree.\n\t     * The root state is implicitly created by UI-Router.\n\t     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n\t     *\n\t     * @return the root [[State]]\n\t     */\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    /**\n\t     * Adds a state to the registry\n\t     *\n\t     * Registers a [[StateDeclaration]] or queues it for registration.\n\t     *\n\t     * Note: a state will be queued if the state's parent isn't yet registered.\n\t     *\n\t     * @param stateDefinition the definition of the state to register.\n\t     * @returns the internal [[State]] object.\n\t     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n\t     *          If the state was only queued, then the object is not fully built.\n\t     */\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    /** @hidden */\n\t    StateRegistry.prototype._deregisterTree = function (state) {\n\t        var _this = this;\n\t        var all = this.get().map(function (s) { return s.$$state(); });\n\t        var getChildren = function (states) {\n\t            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n\t            return children.length === 0 ? children : children.concat(getChildren(children));\n\t        };\n\t        var children = getChildren([state]);\n\t        var deregistered = [state].concat(children).reverse();\n\t        deregistered.forEach(function (state) {\n\t            var $ur = _this._router.urlRouter;\n\t            // Remove URL rule\n\t            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n\t            // Remove state from registry\n\t            delete _this.states[state.name];\n\t        });\n\t        return deregistered;\n\t    };\n\t    /**\n\t     * Removes a state from the registry\n\t     *\n\t     * This removes a state from the registry.\n\t     * If the state has children, they are are also removed from the registry.\n\t     *\n\t     * @param stateOrName the state's name or object representation\n\t     * @returns {State[]} a list of removed states\n\t     */\n\t    StateRegistry.prototype.deregister = function (stateOrName) {\n\t        var _state = this.get(stateOrName);\n\t        if (!_state)\n\t            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\t        var deregisteredStates = this._deregisterTree(_state.$$state());\n\t        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n\t        return deregisteredStates;\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\texports.StateRegistry = StateRegistry;\n\t//# sourceMappingURL=stateRegistry.js.map\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar glob_1 = __webpack_require__(10);\n\tvar common_1 = __webpack_require__(6);\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = predicates_1.isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        else if (isStr) {\n\t            var matches = common_1.values(this._states)\n\t                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n\t            if (matches.length > 1) {\n\t                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n\t            }\n\t            return matches[0];\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\texports.StateMatcher = StateMatcher;\n\t//# sourceMappingURL=stateMatcher.js.map\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\tvar hof_1 = __webpack_require__(8);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar parseUrl = function (url) {\n\t    if (!predicates_1.isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\tfunction nameBuilder(state) {\n\t    return state.name;\n\t}\n\tfunction selfBuilder(state) {\n\t    state.self.$$state = function () { return state; };\n\t    return state.self;\n\t}\n\tfunction dataBuilder(state) {\n\t    if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t    }\n\t    return state.data;\n\t}\n\tvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n\t    return function urlBuilder(state) {\n\t        var stateDec = state;\n\t        // For future states, i.e., states whose name ends with `.**`,\n\t        // match anything that starts with the url prefix\n\t        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n\t            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n\t        }\n\t        var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t            params: state.params || {},\n\t            paramMap: function (paramConfig, isSearch) {\n\t                if (stateDec.reloadOnSearch === false && isSearch)\n\t                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t                return paramConfig;\n\t            }\n\t        });\n\t        if (!url)\n\t            return null;\n\t        if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t    };\n\t};\n\tvar getNavigableBuilder = function (isRoot) {\n\t    return function navigableBuilder(state) {\n\t        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    };\n\t};\n\tvar getParamsBuilder = function (paramFactory) {\n\t    return function paramsBuilder(state) {\n\t        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n\t        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t};\n\tfunction pathBuilder(state) {\n\t    return state.parent ? state.parent.path.concat(state) : [state];\n\t}\n\tfunction includesBuilder(state) {\n\t    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t    includes[state.name] = true;\n\t    return includes;\n\t}\n\t/**\n\t * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * validates the `resolve` property and converts it to a [[Resolvable]] array.\n\t *\n\t * resolve: input value can be:\n\t *\n\t * {\n\t *   // analyzed but not injected\n\t *   myFooResolve: function() { return \"myFooData\"; },\n\t *\n\t *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n\t *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; \"DependencyName\" dep as string\n\t *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; DependencyType dep as token (compared using ===)\n\t *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n\t *\n\t *   // val.$inject used as deps\n\t *   // where:\n\t *   //     corgeResolve.$inject = [\"DependencyName\"];\n\t *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n\t *   // then \"DependencyName\" dep as string\n\t *   myCorgeResolve: corgeResolve,\n\t *\n\t *  // inject service by name\n\t *  // When a string is found, desugar creating a resolve that injects the named service\n\t *   myGraultResolve: \"SomeService\"\n\t * }\n\t *\n\t * or:\n\t *\n\t * [\n\t *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n\t *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n\t *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n\t * ]\n\t */\n\tfunction resolvablesBuilder(state) {\n\t    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n\t    var objects2Tuples = function (resolveObj, resolvePolicies) {\n\t        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n\t    };\n\t    /** fetch DI annotations from a function or ng1-style array */\n\t    var annotate = function (fn) {\n\t        var $injector = coreservices_1.services.$injector;\n\t        // ng1 doesn't have an $injector until runtime.\n\t        // If the $injector doesn't exist, use \"deferred\" literal as a\n\t        // marker indicating they should be annotated when runtime starts\n\t        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n\t    };\n\t    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\t    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n\t    /** true if the object looks like a provide literal, or a ng2 Provider */\n\t    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n\t    /** true if the object looks like a tuple from obj2Tuples */\n\t    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n\t    /** extracts the token from a Provider or provide literal */\n\t    var token = function (p) { return p.provide || p.token; };\n\t    /** Given a literal resolve or provider object, returns a Resolvable */\n\t    var literal2Resolvable = hof_1.pattern([\n\t        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n\t        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n\t        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n\t        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n\t        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n\t    ]);\n\t    var tuple2Resolvable = hof_1.pattern([\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n\t    ]);\n\t    var item2Resolvable = hof_1.pattern([\n\t        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n\t        [isResolveLiteral, literal2Resolvable],\n\t        [isLikeNg2Provider, literal2Resolvable],\n\t        [isTupleFromObj, tuple2Resolvable],\n\t        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n\t    ]);\n\t    // If resolveBlock is already an array, use it as-is.\n\t    // Otherwise, assume it's an object and convert to an Array of tuples\n\t    var decl = state.resolve;\n\t    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n\t    return items.map(item2Resolvable);\n\t}\n\texports.resolvablesBuilder = resolvablesBuilder;\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[State]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[State]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, urlMatcherFactory) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var root = function () { return matcher.find(\"\"); };\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        function parentBuilder(state) {\n\t            if (isRoot(state))\n\t                return null;\n\t            return matcher.find(self.parentName(state)) || root();\n\t        }\n\t        this.builders = {\n\t            name: [nameBuilder],\n\t            self: [selfBuilder],\n\t            parent: [parentBuilder],\n\t            data: [dataBuilder],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [getUrlBuilder(urlMatcherFactory, root)],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [getNavigableBuilder(isRoot)],\n\t            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/statebuilders/views.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [pathBuilder],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [includesBuilder],\n\t            resolvables: [resolvablesBuilder]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent))\n\t            return null;\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        var name = state.name || \"\";\n\t        var segments = name.split('.');\n\t        if (segments.length > 1) {\n\t            if (state.parent) {\n\t                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n\t            }\n\t            var lastSegment = segments.pop();\n\t            if (lastSegment === '**')\n\t                segments.pop();\n\t            return segments.join(\".\");\n\t        }\n\t        if (!state.parent)\n\t            return \"\";\n\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\texports.StateBuilder = StateBuilder;\n\t//# sourceMappingURL=stateBuilder.js.map\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/** @internalapi */\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n\t        this.$registry = $registry;\n\t        this.$urlRouter = $urlRouter;\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.listeners = listeners;\n\t        this.queue = [];\n\t    }\n\t    /** @internalapi */\n\t    StateQueueManager.prototype.dispose = function () {\n\t        this.queue = [];\n\t    };\n\t    StateQueueManager.prototype.register = function (config) {\n\t        var _a = this, states = _a.states, queue = _a.queue;\n\t        // Wrap a new object around the state so we can store our private details easily.\n\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n\t            self: config,\n\t            resolve: config.resolve || [],\n\t            toString: function () { return config.name; }\n\t        }));\n\t        if (!predicates_1.isString(state.name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t        queue.push(state);\n\t        this.flush();\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function () {\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var registered = [], // states that got registered\n\t        orphans = [], // states that don't yet have a parent registered\n\t        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\t        while (queue.length > 0) {\n\t            var state = queue.shift();\n\t            var result = builder.build(state);\n\t            var orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                var existingState = this.$registry.get(state.name);\n\t                if (existingState && existingState.name === state.name) {\n\t                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t                }\n\t                if (existingState && existingState.name === state.name + \".**\") {\n\t                    // Remove future state of the same name\n\t                    this.$registry.deregister(existingState);\n\t                }\n\t                states[state.name] = state;\n\t                this.attachRoute(state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                registered.push(state);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[state.name];\n\t            previousQueueLength[state.name] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t                queue.push(state);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        if (registered.length) {\n\t            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function (state) {\n\t        if (state.abstract || !state.url)\n\t            return;\n\t        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n\t    };\n\t    return StateQueueManager;\n\t}());\n\texports.StateQueueManager = StateQueueManager;\n\t//# sourceMappingURL=stateQueueManager.js.map\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar queue_1 = __webpack_require__(11);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar node_1 = __webpack_require__(21);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar glob_1 = __webpack_require__(10);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Provides state related service functions\n\t *\n\t * This class provides services related to ui-router states.\n\t * An instance of this class is located on the global [[UIRouter]] object.\n\t */\n\tvar StateService = (function () {\n\t    /** @internalapi */\n\t    function StateService(router) {\n\t        this.router = router;\n\t        /** @internalapi */\n\t        this.invalidCallbacks = [];\n\t        /** @hidden */\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error && $error$.stack) {\n\t                console.error($error$);\n\t                console.error($error$.stack);\n\t            }\n\t            else if ($error$ instanceof rejectFactory_1.Rejection) {\n\t                console.error($error$.toString());\n\t                if ($error$.detail && $error$.detail.stack)\n\t                    console.error($error$.detail.stack);\n\t            }\n\t            else {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n\t        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        /**\n\t         * The [[Transition]] currently in progress (or null)\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.transition]]\n\t         */\n\t        get: function () { return this.router.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        /**\n\t         * The latest successful state parameters\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.params]]\n\t         */\n\t        get: function () { return this.router.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        /**\n\t         * The current [[StateDeclaration]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.current]]\n\t         */\n\t        get: function () { return this.router.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        /**\n\t         * The current [[State]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.$current]]\n\t         */\n\t        get: function () { return this.router.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /** @internalapi */\n\t    StateService.prototype.dispose = function () {\n\t        this.defaultErrorHandler(common_1.noop);\n\t        this.invalidCallbacks = [];\n\t    };\n\t    /**\n\t     * Handler for when [[transitionTo]] is called with an invalid state.\n\t     *\n\t     * Invokes the [[onInvalid]] callbacks, in natural order.\n\t     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n\t     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n\t     *\n\t     * @internalapi\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n\t        var _this = this;\n\t        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t        var globals = this.router.globals;\n\t        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n\t        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof targetState_1.TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid())\n\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t            if (latestThing() !== latest)\n\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n\t            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n\t            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * Registers an Invalid State handler\n\t     *\n\t     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n\t     * has been called with an invalid state reference parameter\n\t     *\n\t     * Example:\n\t     * ```js\n\t     * stateService.onInvalid(function(to, from, injector) {\n\t     *   if (to.name() === 'foo') {\n\t     *     let lazyLoader = injector.get('LazyLoadService');\n\t     *     return lazyLoader.load('foo')\n\t     *         .then(() => stateService.target('foo'));\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param {function} callback invoked when the toState is invalid\n\t     *   This function receives the (invalid) toState, the fromState, and an injector.\n\t     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n\t     *   If one is returned, it is treated as a redirect.\n\t     *\n\t     * @returns a function which deregisters the callback\n\t     */\n\t    StateService.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.invalidCallbacks)(callback);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Reloads the current state\n\t     *\n\t     * A method that force reloads the current state, or a partial state hierarchy.\n\t     * All resolves are re-resolved, and components reinstantiated.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * Note: `reload()` is just an alias for:\n\t     *\n\t     * ```js\n\t     * $state.transitionTo($state.current, $state.params, {\n\t     *   reload: true, inherit: false\n\t     * });\n\t     * ```\n\t     *\n\t     * @param reloadState A state name or a state object.\n\t     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Transition to a different state or parameters\n\t     *\n\t     * Convenience method for transitioning to a new state.\n\t     *\n\t     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t     * This allows you to easily use an absolute or relative to path and specify\n\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param to Absolute state name, state object, or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n\t     *\n\t     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n\t     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n\t     *\n\t     *    Parameter inheritance only works between common ancestor states, I.e.\n\t     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     *    will get you all current parameters, etc.\n\t     *\n\t     * @param options Transition options\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * - Possible success values:\n\t     *    - $state.current\n\t     *\n\t     * - Possible rejection reasons:\n\t     *   - transition superseded - when a newer transition has been started after this one\n\t     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n\t     *   - transition failed - when a transition hook errors\n\t     *   - resolve error - when a resolve has errored or rejected\n\t     *\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a [[TargetState]]\n\t     *\n\t     * This is a factory method for creating a TargetState\n\t     *\n\t     * This may be returned from a Transition Hook to redirect a transition, for example.\n\t     */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        var reg = this.router.stateRegistry;\n\t        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = reg.matcher.find(identifier, options.relative);\n\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    ;\n\t    StateService.prototype.getCurrentPath = function () {\n\t        var _this = this;\n\t        var globals = this.router.globals;\n\t        var latestSuccess = globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n\t        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t    };\n\t    /**\n\t     * Low-level method for transitioning to a new state.\n\t     *\n\t     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to State name or state object.\n\t     * @param toParams A map of the parameters that will be sent to the state,\n\t     *      will populate $stateParams.\n\t     * @param options Transition options\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[go]]\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var router = this.router;\n\t        var globals = router.globals;\n\t        var transHistory = globals.transitionHistory;\n\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t        var ref = this.target(to, toParams, options);\n\t        var currentPath = this.getCurrentPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return common_1.silentRejection(ref.error());\n\t        /**\n\t         * Special handling for Ignored, Aborted, and Redirected transitions\n\t         *\n\t         * The semantics for the transition.run() promise and the StateService.transitionTo()\n\t         * promise differ. For instance, the run() promise may be rejected because it was\n\t         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n\t         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n\t         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n\t         */\n\t        var rejectedTransitionHandler = function (transition) { return function (error) {\n\t            if (error instanceof rejectFactory_1.Rejection) {\n\t                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n\t                    router.urlRouter.update();\n\t                    return coreservices_1.services.$q.when(globals.current);\n\t                }\n\t                var detail = error.detail;\n\t                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n\t                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n\t                    // by returning the promise for the new (redirect) `Transition.run()`.\n\t                    var redirect = transition.redirect(detail);\n\t                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n\t                }\n\t                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t                    router.urlRouter.update();\n\t                }\n\t            }\n\t            var errorHandler = _this.defaultErrorHandler();\n\t            errorHandler(error);\n\t            return coreservices_1.services.$q.reject(error);\n\t        }; };\n\t        var transition = this.router.transitionService.create(currentPath, ref);\n\t        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n\t        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return common_1.extend(transitionToPromise, { transition: transition });\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *is* the provided state\n\t     *\n\t     * Similar to [[includes]] but only checks for the full state name.\n\t     * If params is supplied then it will be tested for strict equality against the current\n\t     * active params object, so all params must match with none missing and no extras.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     * ```\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * ```html\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *includes* the provided state\n\t     *\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * #### Example when `$state.$current.name === 'contacts.details.item'`\n\t     * ```js\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     * ```\n\t     *\n\t     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n\t     * ```js\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * ```\n\t     *\n\t     * @param stateOrName A partial name, relative name, glob pattern,\n\t     *   or state object to be searched for within the current state name.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`,\n\t     *   that you'd like to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (!predicates_1.isDefined(include[state.name]))\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Generates a URL for a state and parameters\n\t     *\n\t     * Returns the url for the given state populated with the given params.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param params An object of parameter values to fill the state's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current\n\t        };\n\t        options = common_1.defaults(options, defaultHrefOpts);\n\t        params = params || {};\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t            absolute: options.absolute\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Sets or gets the default [[transitionTo]] error handler.\n\t     *\n\t     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n\t     * This includes errors caused by resolves and transition hooks.\n\t     *\n\t     * Note:\n\t     * This handler does not receive certain Transition rejections.\n\t     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n\t     *\n\t     * The built-in default error handler logs the error to the console.\n\t     *\n\t     * You can provide your own custom handler.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * stateService.defaultErrorHandler(function() {\n\t     *   // Do not log transitionTo errors\n\t     * });\n\t     * ```\n\t     *\n\t     * @param handler a global error handler function\n\t     * @returns the current global error handler\n\t     */\n\t    StateService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        var reg = this.router.stateRegistry;\n\t        if (arguments.length === 0)\n\t            return reg.get();\n\t        return reg.get(stateOrName, base || this.$current);\n\t    };\n\t    /**\n\t     * Lazy loads a state\n\t     *\n\t     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n\t     *\n\t     * @param stateOrName the state that should be lazy loaded\n\t     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n\t     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n\t     * This noop transition is not actually run.\n\t     *\n\t     * @returns a promise to lazy load\n\t     */\n\t    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n\t        var state = this.get(stateOrName);\n\t        if (!state || !state.lazyLoad)\n\t            throw new Error(\"Can not lazy load \" + stateOrName);\n\t        var currentPath = this.getCurrentPath();\n\t        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n\t        transition = transition || this.router.transitionService.create(currentPath, target);\n\t        return lazyLoad_1.lazyLoadState(transition, state);\n\t    };\n\t    return StateService;\n\t}());\n\texports.StateService = StateService;\n\t//# sourceMappingURL=stateService.js.map\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar stateParams_1 = __webpack_require__(50);\n\tvar queue_1 = __webpack_require__(11);\n\tvar common_1 = __webpack_require__(6);\n\t/**\n\t * Global router state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, etc.\n\t */\n\tvar Globals = (function () {\n\t    /** @hidden */\n\t    function Globals(transitionService) {\n\t        var _this = this;\n\t        /** @inheritdoc */\n\t        this.params = new stateParams_1.StateParams();\n\t        /** @internalapi */\n\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t        /** @internalapi */\n\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t        // TODO: This probably belongs in a hooks/globals.ts\n\t        var beforeNewTransition = function ($transition$) {\n\t            _this.transition = $transition$;\n\t            _this.transitionHistory.enqueue($transition$);\n\t            var updateGlobalState = function () {\n\t                _this.successfulTransitions.enqueue($transition$);\n\t                _this.$current = $transition$.$to();\n\t                _this.current = _this.$current.self;\n\t                common_1.copy($transition$.params(), _this.params);\n\t            };\n\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t                _this.transition = null; };\n\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t        };\n\t        transitionService.onBefore({}, beforeNewTransition);\n\t    }\n\t    return Globals;\n\t}());\n\texports.Globals = Globals;\n\t//# sourceMappingURL=globals.js.map\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        common_1.extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return common_1.extend({}, inherited, newParams);\n\t    };\n\t    ;\n\t    return StateParams;\n\t}());\n\texports.StateParams = StateParams;\n\t//# sourceMappingURL=stateParams.js.map\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\t/** @hidden */\n\tvar makeStub = function (keys) {\n\t    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n\t};\n\t/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n\t/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n\t/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n\t/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n\t/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n\t/**\n\t * API for URL management\n\t */\n\tvar UrlService = (function () {\n\t    /** @hidden */\n\t    function UrlService(router, lateBind) {\n\t        if (lateBind === void 0) { lateBind = true; }\n\t        this.router = router;\n\t        this.rules = {};\n\t        this.config = {};\n\t        // proxy function calls from UrlService to the LocationService/LocationConfig\n\t        var locationServices = function () { return router.locationService; };\n\t        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n\t        var locationConfig = function () { return router.locationConfig; };\n\t        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n\t        var umf = function () { return router.urlMatcherFactory; };\n\t        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n\t        var urlRouter = function () { return router.urlRouter; };\n\t        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n\t        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n\t    }\n\t    UrlService.prototype.url = function (newurl, replace, state) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.path = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.search = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.hash = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.onChange = function (callback) { return; };\n\t    ;\n\t    /**\n\t     * Returns the current URL parts\n\t     *\n\t     * This method returns the current URL components as a [[UrlParts]] object.\n\t     *\n\t     * @returns the current url parts\n\t     */\n\t    UrlService.prototype.parts = function () {\n\t        return { path: this.path(), search: this.search(), hash: this.hash() };\n\t    };\n\t    UrlService.prototype.dispose = function () { };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.sync = function (evt) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.listen = function (enabled) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.deferIntercept = function (defer) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.match = function (urlParts) { return; };\n\t    return UrlService;\n\t}());\n\t/** @hidden */\n\tUrlService.locationServiceStub = makeStub(locationServicesFns);\n\t/** @hidden */\n\tUrlService.locationConfigStub = makeStub(locationConfigFns);\n\texports.UrlService = UrlService;\n\t//# sourceMappingURL=urlService.js.map\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(22));\n\t__export(__webpack_require__(31));\n\t__export(__webpack_require__(50));\n\t__export(__webpack_require__(23));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module path */ /** for typedoc */\n\t__export(__webpack_require__(21));\n\t__export(__webpack_require__(24));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module resolve */ /** for typedoc */\n\t__export(__webpack_require__(27));\n\t__export(__webpack_require__(25));\n\t__export(__webpack_require__(26));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(46));\n\t__export(__webpack_require__(34));\n\t__export(__webpack_require__(45));\n\t__export(__webpack_require__(47));\n\t__export(__webpack_require__(44));\n\t__export(__webpack_require__(48));\n\t__export(__webpack_require__(18));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * # Transition subsystem\n\t *\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See:\n\t * - [[TransitionService]]\n\t * - [[Transition]]\n\t * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module transition\n\t */ /** for typedoc */\n\t__export(__webpack_require__(16));\n\t__export(__webpack_require__(20));\n\t__export(__webpack_require__(19));\n\t__export(__webpack_require__(13));\n\t__export(__webpack_require__(14));\n\t__export(__webpack_require__(17));\n\t__export(__webpack_require__(42));\n\t__export(__webpack_require__(35));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(30));\n\t__export(__webpack_require__(29));\n\t__export(__webpack_require__(32));\n\t__export(__webpack_require__(33));\n\t__export(__webpack_require__(51));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(43));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t/**\n\t * # Core classes and interfaces\n\t *\n\t * The classes and interfaces that are core to ui-router and do not belong\n\t * to a more specific subsystem (such as resolve).\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module core\n\t */ /** for typedoc */\n\t\"use strict\";\n\t/** @internalapi */\n\tvar UIRouterPluginBase = (function () {\n\t    function UIRouterPluginBase() {\n\t    }\n\t    UIRouterPluginBase.prototype.dispose = function (router) { };\n\t    return UIRouterPluginBase;\n\t}());\n\texports.UIRouterPluginBase = UIRouterPluginBase;\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MnViewConfig, Resolvable, ResolveContext, ViewService, hasAnyKey, ref, services, viewConfigId;\n\t\n\tref = __webpack_require__(4), services = ref.services, ViewService = ref.ViewService, ResolveContext = ref.ResolveContext, Resolvable = ref.Resolvable;\n\t\n\tviewConfigId = 0;\n\t\n\thasAnyKey = function(keys, obj) {\n\t  return _.reduce(keys, (function(memo, key) {\n\t    return memo || (obj[key] != null);\n\t  }), false);\n\t};\n\t\n\texports.mnViewsBuilder = function(state) {\n\t  var keys, views, viewsObject;\n\t  if (!state.parent) {\n\t    return;\n\t  }\n\t  keys = ['view', 'controller'];\n\t  views = {};\n\t  viewsObject = state.views || {\n\t    $default: _.pick(state, keys)\n\t  };\n\t  _.each(viewsObject, function(config, name) {\n\t    var normalized;\n\t    name = name || '$default';\n\t    config.resolveAs = config.resolveAs || '$resolve';\n\t    config.$type = 'backbone';\n\t    config.$context = state;\n\t    config.$name = name;\n\t    normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n\t    config.$uiViewName = normalized.uiViewName;\n\t    config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t    return views[name] = config;\n\t  });\n\t  return views;\n\t};\n\t\n\texports.MnViewConfig = MnViewConfig = (function() {\n\t  function MnViewConfig(path, viewDecl) {\n\t    this.path = path;\n\t    this.viewDecl = viewDecl;\n\t    this.loaded = true;\n\t    this.$id = viewConfigId++;\n\t  }\n\t\n\t  MnViewConfig.prototype.load = function() {\n\t    return services.$q.when(this);\n\t  };\n\t\n\t  return MnViewConfig;\n\n\t})();\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(62));\n\t//# sourceMappingURL=vanilla.js.map\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * Naive, pure JS implementation of core ui-router services\n\t *\n\t *\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t__export(__webpack_require__(63));\n\t__export(__webpack_require__(64));\n\t__export(__webpack_require__(65));\n\t__export(__webpack_require__(67));\n\t__export(__webpack_require__(68));\n\t__export(__webpack_require__(69));\n\t__export(__webpack_require__(70));\n\t__export(__webpack_require__(71));\n\t__export(__webpack_require__(72));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t/**\n\t * An angular1-like promise api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This API provides native ES6 promise support wrapped as a $q-like API.\n\t * Internally, UI-Router uses this $q object to perform promise operations.\n\t * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n\t *\n\t * $q-like promise api\n\t */\n\texports.$q = {\n\t    /** Normalizes a value as a promise */\n\t    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n\t    /** Normalizes a value as a promise rejection */\n\t    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n\t    /** @returns a deferred object, which has `resolve` and `reject` functions */\n\t    defer: function () {\n\t        var deferred = {};\n\t        deferred.promise = new Promise(function (resolve, reject) {\n\t            deferred.resolve = resolve;\n\t            deferred.reject = reject;\n\t        });\n\t        return deferred;\n\t    },\n\t    /** Like Promise.all(), but also supports object key/promise notation like $q */\n\t    all: function (promises) {\n\t        if (index_1.isArray(promises)) {\n\t            return new Promise(function (resolve, reject) {\n\t                var results = [];\n\t                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n\t                    .then(function () { resolve(results); }, reject);\n\t            });\n\t        }\n\t        if (index_1.isObject(promises)) {\n\t            // Convert promises map to promises array.\n\t            // When each promise resolves, map it to a tuple { key: key, val: val }\n\t            var chain = Object.keys(promises)\n\t                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n\t            // Then wait for all promises to resolve, and convert them back to an object\n\t            return exports.$q.all(chain).then(function (values) {\n\t                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n\t            });\n\t        }\n\t    }\n\t};\n\t//# sourceMappingURL=$q.js.map\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t// globally available injectables\n\tvar globals = {};\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t/**\n\t * A basic angular1-like injector api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This object provides a naive implementation of a globally scoped dependency injection system.\n\t * It supports the following DI approaches:\n\t *\n\t * ### Function parameter names\n\t *\n\t * A function's `.toString()` is called, and the parameter names are parsed.\n\t * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n\t *\n\t * ```js\n\t * function injectedFunction(FooService, BarService) {\n\t *   // FooService and BarService are injected\n\t * }\n\t * ```\n\t *\n\t * ### Function annotation\n\t *\n\t * A function may be annotated with an array of dependency names as the `$inject` property.\n\t *\n\t * ```js\n\t * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n\t * function injectedFunction(fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }\n\t * ```\n\t *\n\t * ### Array notation\n\t *\n\t * An array provides the names of the dependencies to inject (as strings).\n\t * The function is the last element of the array.\n\t *\n\t * ```js\n\t * [ 'FooService', 'BarService', function (fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }]\n\t * ```\n\t *\n\t * @type {$InjectorLike}\n\t */\n\texports.$injector = {\n\t    /** Gets an object from DI based on a string token */\n\t    get: function (name) { return globals[name]; },\n\t    /** Returns true if an object named `name` exists in global DI */\n\t    has: function (name) { return exports.$injector.get(name) != null; },\n\t    /**\n\t     * Injects a function\n\t     *\n\t     * @param fn the function to inject\n\t     * @param context the function's `this` binding\n\t     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n\t     */\n\t    invoke: function (fn, context, locals) {\n\t        var all = index_1.extend({}, globals, locals || {});\n\t        var params = exports.$injector.annotate(fn);\n\t        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n\t        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n\t        if (index_1.isFunction(fn))\n\t            return fn.apply(context, args);\n\t        else\n\t            return fn.slice(-1)[0].apply(context, args);\n\t    },\n\t    /**\n\t     * Returns a function's dependencies\n\t     *\n\t     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n\t     * @return an array of `string`s\n\t     */\n\t    annotate: function (fn) {\n\t        if (!index_1.isInjectable(fn))\n\t            throw new Error(\"Not an injectable function: \" + fn);\n\t        if (fn && fn.$inject)\n\t            return fn.$inject;\n\t        if (index_1.isArray(fn))\n\t            return fn.slice(0, -1);\n\t        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n\t        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\t        return result || [];\n\t    }\n\t};\n\t//# sourceMappingURL=$injector.js.map\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */ /** */\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(66);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A base `LocationServices` */\n\tvar BaseLocationServices = (function () {\n\t    function BaseLocationServices(router, fireAfterUpdate) {\n\t        var _this = this;\n\t        this.fireAfterUpdate = fireAfterUpdate;\n\t        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n\t        this._listeners = [];\n\t        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n\t        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n\t        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n\t        this._location = window && window.location;\n\t        this._history = window && window.history;\n\t    }\n\t    BaseLocationServices.prototype.url = function (url, replace) {\n\t        if (replace === void 0) { replace = true; }\n\t        if (predicates_1.isDefined(url) && url !== this._get()) {\n\t            this._set(null, null, url, replace);\n\t            if (this.fireAfterUpdate) {\n\t                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n\t                this._listeners.forEach(function (cb) { return cb(evt_1); });\n\t            }\n\t        }\n\t        return utils_1.buildUrl(this);\n\t    };\n\t    BaseLocationServices.prototype.onChange = function (cb) {\n\t        var _this = this;\n\t        this._listeners.push(cb);\n\t        return function () { return common_1.removeFrom(_this._listeners, cb); };\n\t    };\n\t    BaseLocationServices.prototype.dispose = function (router) {\n\t        common_1.deregAll(this._listeners);\n\t    };\n\t    return BaseLocationServices;\n\t}());\n\texports.BaseLocationServices = BaseLocationServices;\n\t//# sourceMappingURL=baseLocationService.js.map\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\tvar common_1 = __webpack_require__(6);\n\tvar beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\texports.splitHash = beforeAfterSubstr(\"#\");\n\texports.splitQuery = beforeAfterSubstr(\"?\");\n\texports.splitEqual = beforeAfterSubstr(\"=\");\n\texports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\n\texports.keyValsToObjectR = function (accum, _a) {\n\t    var key = _a[0], val = _a[1];\n\t    if (!accum.hasOwnProperty(key)) {\n\t        accum[key] = val;\n\t    }\n\t    else if (index_1.isArray(accum[key])) {\n\t        accum[key].push(val);\n\t    }\n\t    else {\n\t        accum[key] = [accum[key], val];\n\t    }\n\t    return accum;\n\t};\n\texports.getParams = function (queryString) {\n\t    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n\t};\n\tfunction parseUrl(url) {\n\t    var orEmptyString = function (x) { return x || \"\"; };\n\t    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n\t    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n\t    return { path: path, search: search, hash: hash, url: url };\n\t}\n\texports.parseUrl = parseUrl;\n\texports.buildUrl = function (loc) {\n\t    var path = loc.path();\n\t    var searchObject = loc.search();\n\t    var hash = loc.hash();\n\t    var search = Object.keys(searchObject).map(function (key) {\n\t        var param = searchObject[key];\n\t        var vals = index_1.isArray(param) ? param : [param];\n\t        return vals.map(function (val) { return key + \"=\" + val; });\n\t    }).reduce(common_1.unnestR, []).join(\"&\");\n\t    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n\t};\n\tfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n\t    return function (router) {\n\t        var service = router.locationService = new serviceClass(router);\n\t        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n\t        function dispose(router) {\n\t            router.dispose(service);\n\t            router.dispose(configuration);\n\t        }\n\t        return { name: name, service: service, configuration: configuration, dispose: dispose };\n\t    };\n\t}\n\texports.locationPluginFactory = locationPluginFactory;\n\t//# sourceMappingURL=utils.js.map\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\n\tvar HashLocationService = (function (_super) {\n\t    __extends(HashLocationService, _super);\n\t    function HashLocationService(router) {\n\t        var _this = _super.call(this, router, false) || this;\n\t        window.addEventListener('hashchange', _this._listener, false);\n\t        return _this;\n\t    }\n\t    HashLocationService.prototype._get = function () {\n\t        return utils_1.trimHashVal(this._location.hash);\n\t    };\n\t    HashLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._location.hash = url;\n\t    };\n\t    HashLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener('hashchange', this._listener);\n\t    };\n\t    return HashLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.HashLocationService = HashLocationService;\n\t//# sourceMappingURL=hashLocationService.js.map\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that gets/sets the current location from an in-memory object */\n\tvar MemoryLocationService = (function (_super) {\n\t    __extends(MemoryLocationService, _super);\n\t    function MemoryLocationService(router) {\n\t        return _super.call(this, router, true) || this;\n\t    }\n\t    MemoryLocationService.prototype._get = function () {\n\t        return this._url;\n\t    };\n\t    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._url = url;\n\t    };\n\t    return MemoryLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.MemoryLocationService = MemoryLocationService;\n\t//# sourceMappingURL=memoryLocationService.js.map\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/**\n\t * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n\t *\n\t * Uses `history.pushState` and `history.replaceState`\n\t */\n\tvar PushStateLocationService = (function (_super) {\n\t    __extends(PushStateLocationService, _super);\n\t    function PushStateLocationService(router) {\n\t        var _this = _super.call(this, router, true) || this;\n\t        _this._config = router.urlService.config;\n\t        window.addEventListener(\"popstate\", _this._listener, false);\n\t        return _this;\n\t    }\n\t    ;\n\t    PushStateLocationService.prototype._get = function () {\n\t        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n\t        search = utils_1.splitQuery(search)[1]; // strip ? if found\n\t        hash = utils_1.splitHash(hash)[1]; // strip # if found\n\t        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n\t    };\n\t    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n\t        var _a = this, _config = _a._config, _history = _a._history;\n\t        var fullUrl = _config.baseHref() + url;\n\t        if (replace) {\n\t            _history.replaceState(state, title, fullUrl);\n\t        }\n\t        else {\n\t            _history.pushState(state, title, fullUrl);\n\t        }\n\t    };\n\t    PushStateLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener(\"popstate\", this._listener);\n\t    };\n\t    return PushStateLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.PushStateLocationService = PushStateLocationService;\n\t//# sourceMappingURL=pushStateLocationService.js.map\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\n\tvar MemoryLocationConfig = (function () {\n\t    function MemoryLocationConfig() {\n\t        var _this = this;\n\t        this._baseHref = '';\n\t        this._port = 80;\n\t        this._protocol = \"http\";\n\t        this._host = \"localhost\";\n\t        this._hashPrefix = \"\";\n\t        this.port = function () { return _this._port; };\n\t        this.protocol = function () { return _this._protocol; };\n\t        this.host = function () { return _this._host; };\n\t        this.baseHref = function () { return _this._baseHref; };\n\t        this.html5Mode = function () { return false; };\n\t        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n\t        this.dispose = common_1.noop;\n\t    }\n\t    return MemoryLocationConfig;\n\t}());\n\texports.MemoryLocationConfig = MemoryLocationConfig;\n\t//# sourceMappingURL=memoryLocationConfig.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar predicates_1 = __webpack_require__(7);\n\t/** A `LocationConfig` that delegates to the browser's `location` object */\n\tvar BrowserLocationConfig = (function () {\n\t    function BrowserLocationConfig(router, _isHtml5) {\n\t        if (_isHtml5 === void 0) { _isHtml5 = false; }\n\t        this._isHtml5 = _isHtml5;\n\t        this._baseHref = undefined;\n\t        this._hashPrefix = \"\";\n\t    }\n\t    BrowserLocationConfig.prototype.port = function () {\n\t        return parseInt(location.port);\n\t    };\n\t    BrowserLocationConfig.prototype.protocol = function () {\n\t        return location.protocol;\n\t    };\n\t    BrowserLocationConfig.prototype.host = function () {\n\t        return location.host;\n\t    };\n\t    BrowserLocationConfig.prototype.html5Mode = function () {\n\t        return this._isHtml5;\n\t    };\n\t    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n\t        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n\t    };\n\t    ;\n\t    BrowserLocationConfig.prototype.baseHref = function (href) {\n\t        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n\t    };\n\t    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n\t        var baseTags = document.getElementsByTagName(\"base\");\n\t        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n\t    };\n\t    BrowserLocationConfig.prototype.dispose = function () { };\n\t    return BrowserLocationConfig;\n\t}());\n\texports.BrowserLocationConfig = BrowserLocationConfig;\n\t//# sourceMappingURL=browserLocationConfig.js.map\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar browserLocationConfig_1 = __webpack_require__(71);\n\tvar hashLocationService_1 = __webpack_require__(67);\n\tvar utils_1 = __webpack_require__(66);\n\tvar pushStateLocationService_1 = __webpack_require__(69);\n\tvar memoryLocationService_1 = __webpack_require__(68);\n\tvar memoryLocationConfig_1 = __webpack_require__(70);\n\tvar _injector_1 = __webpack_require__(64);\n\tvar _q_1 = __webpack_require__(63);\n\tvar coreservices_1 = __webpack_require__(9);\n\tfunction servicesPlugin(router) {\n\t    coreservices_1.services.$injector = _injector_1.$injector;\n\t    coreservices_1.services.$q = _q_1.$q;\n\t    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n\t}\n\texports.servicesPlugin = servicesPlugin;\n\t/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\n\texports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\n\texports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\n\texports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n\t//# sourceMappingURL=plugins.js.map\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, ResolveContext, UIViewMarionette, id,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tid = 0;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tResolveContext = __webpack_require__(4).ResolveContext;\n\t\n\texports.UIViewMarionette = UIViewMarionette = (function(superClass) {\n\t  extend(UIViewMarionette, superClass);\n\t\n\t  function UIViewMarionette() {\n\t    return UIViewMarionette.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UIViewMarionette.prototype.initialize = function(router, mnLayout, mnRegion, mnRegionName) {\n\t    var name, parentContext, parentFqn, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n\t    this.router = router;\n\t    this.mnRegion = mnRegion;\n\t    console.log('new uiview ' + mnRegionName);\n\t    this.listenTo(mnLayout, \"before:destroy\", this.destroy);\n\t    name = mnRegionName || '$default';\n\t    parentContext = mnLayout != null ? (ref = mnLayout.parent) != null ? (ref1 = ref.uiView) != null ? (ref2 = ref1.activeUIView.config) != null ? (ref3 = ref2.viewDecl) != null ? ref3.$context : void 0 : void 0 : void 0 : void 0 : void 0;\n\t    parentFqn = mnLayout != null ? (ref4 = mnLayout.parent) != null ? (ref5 = ref4.uiView) != null ? (ref6 = ref5.activeUIView) != null ? ref6.fqn : void 0 : void 0 : void 0 : void 0;\n\t    return this.activeUIView = {\n\t      $type: 'backbone',\n\t      id: id++,\n\t      name: name,\n\t      fqn: parentFqn ? parentFqn + \".\" + name : name,\n\t      creationContext: parentContext || this.router.stateRegistry.root(),\n\t      configUpdated: (function(_this) {\n\t        return function(config) {\n\t          return _this.onConfigUpdated(config);\n\t        };\n\t      })(this),\n\t      config: void 0\n\t    };\n\t  };\n\t\n\t  UIViewMarionette.prototype.register = function() {\n\t    return this.deregister = this.router.viewService.registerUIView(this.activeUIView);\n\t  };\n\t\n\t  UIViewMarionette.prototype.onConfigUpdated = function(newConfig) {\n\t    if (!newConfig) {\n\t      return this.clearPreviousConfig();\n\t    }\n\t    if (newConfig.viewDecl.$type !== 'backbone') {\n\t      return;\n\t    }\n\t    if (this.activeUIView.config === newConfig) {\n\t      return;\n\t    }\n\t    return this.updateView(newConfig);\n\t  };\n\t\n\t  UIViewMarionette.prototype.updateView = function(newConfig) {\n\t    var controller, resolved, view;\n\t    this.activeUIView.config = newConfig;\n\t    resolved = this.getResolved(newConfig);\n\t    view = this.getView(newConfig, {\n\t      resolved: resolved\n\t    });\n\t    controller = this.getController(newConfig, {\n\t      resolved: resolved,\n\t      view: view\n\t    });\n\t    if (view != null) {\n\t      this.mnRegion.show(view);\n\t      if (controller != null) {\n\t        return this.listenToOnce(view, \"destroy\", function() {\n\t          return controller.destroy();\n\t        });\n\t      }\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getResolved = function(config) {\n\t    var context, i, key, keys, len, resolved;\n\t    context = new ResolveContext(config.path);\n\t    resolved = {};\n\t    keys = _.filter(context.getTokens(), function(token) {\n\t      return typeof token === 'string';\n\t    });\n\t    for (i = 0, len = keys.length; i < len; i++) {\n\t      key = keys[i];\n\t      resolved[key] = context.getResolvable(key).data;\n\t    }\n\t    return resolved;\n\t  };\n\t\n\t  UIViewMarionette.prototype.getView = function(config, viewOptions) {\n\t    var ref, view;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.view : void 0 : void 0) != null) {\n\t      return view = new config.viewDecl.view(viewOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getController = function(config, controllerOptions) {\n\t    var ref;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.controller : void 0 : void 0) != null) {\n\t      return new config.viewDecl.controller(controllerOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.clearPreviousConfig = function() {\n\t    var ref;\n\t    this.mnRegion.empty();\n\t    (this.activeUIView.view != null) && ((ref = this.activeUIView.controller) != null ? ref.triggerMethod('view:destroyed') : void 0);\n\t    return this.activeUIView.config = void 0;\n\t  };\n\t\n\t  UIViewMarionette.prototype.onBeforeDestroy = function() {\n\t    return typeof this.deregister === \"function\" ? this.deregister() : void 0;\n\t  };\n\t\n\t  return UIViewMarionette;\n\t\n\t})(Mn.Object);\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UIRouterMarionette, UISref, UISrefActive,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tUIRouterMarionette = __webpack_require__(1).UIRouterMarionette;\n\t\n\texports.UISref = UISref = (function(superClass) {\n\t  extend(UISref, superClass);\n\t\n\t  function UISref() {\n\t    return UISref.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISref.prototype.ui = {\n\t    sref: '[ui-sref]'\n\t  };\n\t\n\t  UISref.prototype.events = {\n\t    'click @ui.ref': 'onClickLink'\n\t  };\n\t\n\t  UISref.prototype.onClickLink = function() {};\n\t\n\t  UISref.prototype.onAttach = function() {\n\t    var router;\n\t    router = UIRouterMarionette.getInstance();\n\t    return this.ui.sref.each(function(i, e) {\n\t      var params, state, url;\n\t      e = $(e);\n\t      state = e.attr('ui-sref');\n\t      try {\n\t        params = JSON.parse(e.attr('ui-sparams'));\n\t      } catch (undefined) {}\n\t      url = router.stateService.href(state, params);\n\t      return e.attr('href', url);\n\t    });\n\t  };\n\t\n\t  return UISref;\n\t\n\t})(Mn.Behavior);\n\t\n\texports.UISrefActive = UISrefActive = (function(superClass) {\n\t  extend(UISrefActive, superClass);\n\t\n\t  function UISrefActive() {\n\t    return UISrefActive.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISrefActive.prototype.ui = {\n\t    active: '[ui-sref-active]'\n\t  };\n\t\n\t  UISrefActive.prototype.defaults = {\n\t    activeClasses: 'ui-state-active'\n\t  };\n\t\n\t  UISrefActive.prototype.initialize = function() {\n\t    this.router = UIRouterMarionette.getInstance();\n\t    return this.deregister = this.router.transitionService.onSuccess({}, (function(_this) {\n\t      return function(transition) {\n\t        return _this.onStateChange();\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onRender = function() {\n\t    return this.onStateChange();\n\t  };\n\t\n\t  UISrefActive.prototype.onStateChange = function() {\n\t    return this.ui.active.each((function(_this) {\n\t      return function(i, el) {\n\t        var $el, classFn, compareState, params;\n\t        $el = $(el);\n\t        params = $el.attr('ui-sparams');\n\t        if (params) {\n\t          params = JSON.parse(params);\n\t        }\n\t        compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref');\n\t        classFn = _this.router.stateService.includes(compareState, params) ? 'addClass' : 'removeClass';\n\t        return $el[classFn](_this.options.activeClasses);\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onBeforeDestroy = function() {\n\t    return this.deregister();\n\t  };\n\t\n\t  UISrefActive.prototype.removeListeners = function() {\n\t    return this.ui.active.off('ui:state:change');\n\t  };\n\t\n\t  return UISrefActive;\n\t\n\t})(Mn.Behavior);\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UILayoutMn2, UIRouterMarionette, UIViewMarionette,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\tUIRouterMarionette = __webpack_require__(3).UIRouterMarionette;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tmodule.exports = UILayoutMn2 = (function(superClass) {\n\t  extend(UILayoutMn2, superClass);\n\t\n\t  function UILayoutMn2() {\n\t    UILayoutMn2.__super__.constructor.apply(this, arguments);\n\t    this.on(\"attach\", this.onAttachUI);\n\t    this.on(\"before:destroy\", this.onBeforeDestroyUI);\n\t  }\n\t\n\t  UILayoutMn2.prototype.regions = {\n\t    \"$default\": \"[ui-view]\"\n\t  };\n\t\n\t  UILayoutMn2.prototype.onAttachUI = function(me, parentRegion) {\n\t    var ref, region, regionName;\n\t    this.parent = parentRegion;\n\t    ref = this.regions;\n\t    for (regionName in ref) {\n\t      if (!hasProp.call(ref, regionName)) continue;\n\t      region = ref[regionName];\n\t      this[regionName].uiView = new UIViewMarionette(UIRouterMarionette.getInstance(), this, this[regionName], regionName);\n\t      this[regionName].uiView.register();\n\t    }\n\t  };\n\t\n\t  UILayoutMn2.prototype.onBeforeDestroyUI = function() {\n\t    return this.parent = null;\n\t  };\n\t\n\t  return UILayoutMn2;\n\t\n\t})(Mn.LayoutView);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ui-router-marionette.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 862003ef0328f95c200a","_ = require('underscore')\n{\n  $q\n  UIViewMarionette\n  Router\n} = require('./router')\n\n{\n  UISref\n  UISrefActive\n} = require('./marionette/behaviors')\n\nUILayoutMn2 = require('./ui_layout_mn2')\n\n\n_.extend exports, {\n  Router\n  UISref\n  UISrefActive\n  UILayoutMn2\n  UIViewMarionette\n  $q\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}\n// module id = 2\n// module chunks = 0 1","{ UIRouter, $q } = require('ui-router-core')\n{ mnViewsBuilder, MnViewConfig } = require('./state_views_builder')\n{ hashLocationPlugin, servicesPlugin } = require('ui-router-core/lib/vanilla')\n{ UIViewMarionette } = require('./uiview')\n\nrouterInstance = null\n\nviewConfigFactory = (node, config) ->\n  new MnViewConfig(node, config)\n\n\nclass UIRouterMarionette extends UIRouter\n  @getInstance: ->\n    routerInstance or= new @\n\n  constructor: ->\n    super\n    @_started = false\n    @viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory)\n    @plugin(servicesPlugin)\n    @plugin(hashLocationPlugin)\n\n    @stateRegistry.decorator(\"views\", mnViewsBuilder)\n    routerInstance = @\n\n  start: (@rootRegion, options) ->\n    throw new Error(\"Router was already started\") if @_started\n\n    if options?\n      @handleOptions(options)\n\n    @rootRegion.uiView = new UIViewMarionette(@, null, @rootRegion, \"\")\n    @rootRegion.uiView.register()\n\n    @urlMatcherFactory.$get()\n    @urlService.listen()\n    @urlService.sync()\n    @_started = true\n    return @\n\n  handleOptions: (options) ->\n    if typeof options.onMnRoute is 'function'\n      @onMnRoute(options.onMnRoute)\n\n  onMnRoute: (onRoute) ->\n    oldProcessOnRoute = Marionette.AppRouter::_processOnRoute\n    uiRouter = @\n    Marionette.AppRouter::_processOnRoute = (mnRouteName, mnRouteArgs) ->\n      mnRoutePath = _.invert(this.getOption('appRoutes'))[mnRouteName]\n      onRoute.call(@, mnRouteName, mnRouteArgs, mnRoutePath, uiRouter.stateService)\n      oldProcessOnRoute.call(@, mnRouteName, mnRouteArgs)\n\n\nexports.UIViewMarionette = UIViewMarionette\nexports.Router = UIRouterMarionette\n\n\n\n// WEBPACK FOOTER //\n// ./src/router.coffee","/**\n * @coreapi\n * @module common\n */ /** */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./common/index\"));\n__export(require(\"./params/index\"));\n__export(require(\"./path/index\"));\n__export(require(\"./resolve/index\"));\n__export(require(\"./state/index\"));\n__export(require(\"./transition/index\"));\n__export(require(\"./url/index\"));\n__export(require(\"./view/index\"));\n__export(require(\"./globals\"));\n__export(require(\"./router\"));\n__export(require(\"./interface\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/index.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module common */ /** for typedoc */\n__export(require(\"./common\"));\n__export(require(\"./coreservices\"));\n__export(require(\"./glob\"));\n__export(require(\"./hof\"));\n__export(require(\"./predicates\"));\n__export(require(\"./queue\"));\n__export(require(\"./strings\"));\n__export(require(\"./trace\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/index.js\n// module id = 5\n// module chunks = 0 1","/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar hof_1 = require(\"./hof\");\nvar coreservices_1 = require(\"./coreservices\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = angular.extend || _extend;\nexports.equals = angular.equals || _equals;\nexports.identity = function (x) { return x; };\nexports.noop = function () { return undefined; };\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    if (opts === void 0) { opts = {}; }\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var defaults = merge.apply(null, [{}].concat(defaultsList));\n    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n}\nexports.defaults = defaults;\n/**\n * Merges properties from the list of objects to the destination object.\n * If a property already exists in the destination object, then it is not overwritten.\n */\nfunction merge(dst) {\n    var objs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objs[_i - 1] = arguments[_i];\n    }\n    exports.forEach(objs, function (obj) {\n        exports.forEach(obj, function (value, key) {\n            if (!dst.hasOwnProperty(key))\n                dst[key] = value;\n        });\n    });\n    return dst;\n}\nexports.merge = merge;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\nfunction pickOmitImpl(predicate, obj) {\n    var keys = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        keys[_i - 2] = arguments[_i];\n    }\n    var objCopy = {};\n    for (var key in obj) {\n        if (predicate(keys, key))\n            objCopy[key] = obj[key];\n    }\n    return objCopy;\n}\n/** Return a copy of the object only containing the whitelisted properties. */\nfunction pick(obj) {\n    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n}\nexports.pick = pick;\n/** Return a copy of the object omitting the blacklisted properties. */\nfunction omit(obj) {\n    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var arrayArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrayArgs[_i] = arguments[_i];\n    }\n    if (arrayArgs.length === 0)\n        return [];\n    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _copyProps(to, from) {\n    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n    return to;\n}\nfunction _extend(toObj) {\n    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n}\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function (a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/common.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */ /** */\nvar hof_1 = require(\"./hof\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/predicates.js\n// module id = 7\n// module chunks = 0 1","/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\n\"use strict\";\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/hof.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/coreservices.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** @deprecated whats the point? */\n    Glob.is = function (text) {\n        return text.indexOf('*') > -1;\n    };\n    /** @deprecated whats the point? */\n    Glob.fromString = function (text) {\n        if (!this.is(text))\n            return null;\n        return new Glob(text);\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/glob.js\n// module id = 10\n// module chunks = 0 1","/**\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/queue.js\n// module id = 11\n// module chunks = 0 1","/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar common_1 = require(\"./common\");\nvar hof_1 = require(\"./hof\");\nvar transition_1 = require(\"../transition/transition\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/strings.js\n// module id = 12\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var type = this.type, message = this.message, detail = detailString(this.detail);\n        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isTransitionRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n    };\n    /** Returns a TransitionRejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a TransitionRejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a TransitionRejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a TransitionRejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/rejectFactory.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar hookBuilder_1 = require(\"./hookBuilder\");\nvar node_1 = require(\"../path/node\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar param_1 = require(\"../params/param\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar router_1 = require(\"../router\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /**\n         * Checks if this transition is currently active/running.\n         */\n        this.isActive = function () { return _this === _this._options.current(); };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n        this.applyViewConfigs(router);\n        this.applyRootResolvables(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    Transition.prototype.applyRootResolvables = function (router) {\n        var _this = this;\n        var rootResolvables = [\n            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n        ];\n        var rootNode = this._treeChanges.to[0];\n        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n        context.addResolvables(rootResolvables, rootNode.state);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless  the target state explicitly specifies location)\n        if (this.options().source === 'url') {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.length === 0;\n    };\n    /**\n     * @hidden\n     */\n    Transition.prototype.hookBuilder = function () {\n        return new hookBuilder_1.HookBuilder(this);\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        var hookBuilder = this.hookBuilder();\n        var globals = this.router.globals;\n        globals.transitionHistory.enqueue(this);\n        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n            syncResult.catch(function () { return 0; }); // issue #2676\n            var rejectReason = syncResult._transitionRejection;\n            this._deferred.reject(rejectReason);\n            return this.promise;\n        }\n        if (!this.valid()) {\n            var error = new Error(this.error());\n            this._deferred.reject(error);\n            return this.promise;\n        }\n        if (this.ignored()) {\n            trace_1.trace.traceTransitionIgnored(this);\n            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n            return this.promise;\n        }\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n            runAllHooks(onSuccessHooks);\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n            runAllHooks(onErrorHooks);\n        };\n        trace_1.trace.traceTransitionStart(this);\n        // Chain the next hook off the previous\n        var appendHookToChain = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n        asyncHooks.reduce(appendHookToChain, syncResult)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transition.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"./strings\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/trace.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/interface.js\n// module id = 16\n// module chunks = 0 1","\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.stateService = function () { return _this.transition.router.stateService; };\n        this.rejectIfSuperseded = function () {\n            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n    }\n    TransitionHook.prototype.invokeHook = function () {\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        if (this.rejectIfSuperseded()) {\n            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n        }\n        var cb = hook.callback;\n        var bind = this.options.bind;\n        var trans = this.transition;\n        var state = this.stateContext;\n        var errorHandler = hook.eventType.getErrorHandler(this);\n        var resultHandler = hook.eventType.getResultHandler(this);\n        resultHandler = resultHandler || common_1.identity;\n        if (!errorHandler) {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        try {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        catch (error) {\n            return errorHandler(error);\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.rejectIfSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess the resolved value\n            return result.then(this.handleHookResult.bind(this));\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and start a redirected Transition (to the TargetState).\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n     *\n     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n     */\n    TransitionHook.runOnBeforeHooks = function (hooks) {\n        var results = [];\n        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n            var hook = hooks_1[_i];\n            var hookResult = hook.invokeHook();\n            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n                // Break on first thrown error or false/TargetState\n                return hookResult;\n            }\n            results.push(hookResult);\n        }\n        return results\n            .filter(predicates_1.isPromise)\n            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n    };\n    return TransitionHook;\n}());\nTransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n        return hook.handleHookResult(result);\n    };\n};\nTransitionHook.IGNORE_RESULT = function (hook) {\n    return function (result) { return undefined; };\n};\nTransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n        return (hook.stateService().defaultErrorHandler()(error), undefined);\n    };\n};\nTransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n        return rejectFactory_1.Rejection.errored(error).toPromise();\n    };\n};\nTransitionHook.THROW_ERROR = function (hook) {\n    return undefined;\n};\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionHook.js\n// module id = 17\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/targetState.js\n// module id = 18\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar glob_1 = require(\"../common/glob\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookRegistry.js\n// module id = 19\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n        this.treeChanges = transition.treeChanges();\n        this.transitionOptions = transition.options();\n        this.toState = common_1.tail(this.treeChanges.to).state;\n        this.fromState = common_1.tail(this.treeChanges.from).state;\n        this.$transitions = transition.router.transitionService;\n        this.baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        return this.$transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var _this = this;\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n        if (!matchingHooks)\n            return [];\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(_this.treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, _this.baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookBuilder.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\n/** @module path */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar param_1 = require(\"../params/param\");\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrPath) {\n        if (stateOrPath instanceof PathNode) {\n            var node = stateOrPath;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrPath;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, keys) {\n        var _this = this;\n        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n        var paramValsEq = function (key) {\n            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n        };\n        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    /**\n     * Returns a new path which is a subpath of the first path which matched the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * Nodes are compared using their state property and parameter values.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param ignoreDynamicParams don't compare dynamic parameter values\n     */\n    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n        var matching = [];\n        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n            var a = pathA[i], b = pathB[i];\n            if (a.state !== b.state)\n                break;\n            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n            if (changedParams.length)\n                break;\n            matching.push(a);\n        }\n        return matching;\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=node.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/node.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n    });\n}\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var $$getDefaultValue = function () {\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            return defaultValue;\n        };\n        var $replace = function (val) {\n            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n            return replacement.length ? replacement[0] : val;\n        };\n        value = $replace(value);\n        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/param.js\n// module id = 22\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramType.js\n// module id = 23\n// module chunks = 0 1","/** @module path */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar targetState_1 = require(\"../state/targetState\");\nvar node_1 = require(\"../path/node\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathFactory = (function () {\n    function PathFactory() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathFactory.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathFactory.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathFactory.buildToPath = function (fromPath, targetState) {\n        var toPath = PathFactory.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathFactory.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var staticParams = function (state) {\n            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n        };\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, staticParams(node1.state));\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = node_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathFactory.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathFactory;\n}());\n/** Gets the raw parameter values from a path */\nPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\nexports.PathFactory = PathFactory;\n//# sourceMappingURL=pathFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/pathFactory.js\n// module id = 24\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar trace_1 = require(\"../common/trace\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n                return r.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolvable.js\n// module id = 25\n// module chunks = 0 1","\"use strict\";\n/** @module resolve */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar interface_1 = require(\"./interface\");\nvar resolvable_1 = require(\"./resolvable\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar strings_1 = require(\"../common/strings\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Depenency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolveContext.js\n// module id = 26\n// module chunks = 0 1","\"use strict\";\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/interface.js\n// module id = 27\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = require(\"./url/urlMatcherFactory\");\nvar urlRouter_1 = require(\"./url/urlRouter\");\nvar transitionService_1 = require(\"./transition/transitionService\");\nvar view_1 = require(\"./view/view\");\nvar stateRegistry_1 = require(\"./state/stateRegistry\");\nvar stateService_1 = require(\"./state/stateService\");\nvar globals_1 = require(\"./globals\");\nvar common_1 = require(\"./common/common\");\nvar predicates_1 = require(\"./common/predicates\");\nvar urlService_1 = require(\"./url/urlService\");\nvar trace_1 = require(\"./common/trace\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */\n        this.$id = _routerInstance++;\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.Globals(this.transitionService);\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._disposables = [];\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(this.stateRegistry);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/router.js\n// module id = 28\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar param_1 = require(\"../params/param\");\nvar paramTypes_1 = require(\"../params/paramTypes\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcherFactory.js\n// module id = 29\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar param_1 = require(\"../params/param\");\nvar strings_1 = require(\"../common/strings\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this], parent: null, pattern: null };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        var parent = this._cache.parent;\n        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n            null);\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var _this = this;\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        return common_1.pairs(params || {}).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return validParamVal(_this.parameter(key), val);\n        }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        if (!this.validates(values))\n            return null;\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n        /**\n         * Given a Param,\n         * Applies the parameter value, then returns details about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a Param.  Fetch details about the parameter value\n            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (param) {\n            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        var splitOnSlash = strings_1.splitOnDelim('/');\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         */\n        var segments = function (matcher) {\n            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                .reduce(common_1.unnestR, [])\n                .reduce(strings_1.joinNeighborsR, [])\n                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                .reduce(common_1.unnestR, []);\n        };\n        var aSegments = segments(a), bSegments = segments(b);\n        // console.table( { aSegments, bSegments });\n        // Sort slashes first, then static strings, the Params\n        var weight = hof_1.pattern([\n            [hof_1.eq(\"/\"), hof_1.val(1)],\n            [predicates_1.isString, hof_1.val(2)],\n            [hof_1.is(param_1.Param), hof_1.val(3)]\n        ]);\n        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n        // console.table(pairs);\n        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcher.js\n// module id = 30\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramTypes.js\n// module id = 31\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar hof_1 = require(\"../common/hof\");\nvar urlRule_1 = require(\"./urlRule\");\nvar targetState_1 = require(\"../state/targetState\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash()\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        if (!urlMatcher.validates(params))\n            return null;\n        var url = urlMatcher.format(params);\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this.sort();\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n        this.sort();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n        }\n        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this.sort();\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\n//# sourceMappingURL=urlRouter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRouter.js\n// module id = 32\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar stateObject_1 = require(\"../state/stateObject\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[State]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRule.js\n// module id = 33\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar State = (function () {\n    function State(config) {\n        common_1.extend(this, config);\n        // Object.freeze(this);\n    }\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    State.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    State.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    State.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param`eters\n     *\n     * Gets [[Param]] information that is owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    State.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    State.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    State.prototype.toString = function () {\n        return this.fqn();\n    };\n    return State;\n}());\nexports.State = State;\n//# sourceMappingURL=stateObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateObject.js\n// module id = 34\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar transition_1 = require(\"./transition\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar resolve_1 = require(\"../hooks/resolve\");\nvar views_1 = require(\"../hooks/views\");\nvar url_1 = require(\"../hooks/url\");\nvar redirectTo_1 = require(\"../hooks/redirectTo\");\nvar onEnterExitRetain_1 = require(\"../hooks/onEnterExitRetain\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar transitionEventType_1 = require(\"./transitionEventType\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineDefaultPaths();\n        this._defineDefaultEvents();\n        this._registerDefaultTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        delete router.globals.transition;\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultPaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionService.js\n// module id = 35\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state)\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/resolve.js\n// module id = 36\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/views.js\n// module id = 37\n// module chunks = 0 1","\"use strict\";\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/url.js\n// module id = 38\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** */\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar targetState_1 = require(\"../state/targetState\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/redirectTo.js\n// module id = 39\n// module chunks = 0 1","\"use strict\";\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var hookFn = state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/onEnterExitRetain.js\n// module id = 40\n// module chunks = 0 1","\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/lazyLoad.js\n// module id = 41\n// module chunks = 0 1","\"use strict\";\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.rejectIfSuperseded = rejectIfSuperseded;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionEventType.js\n// module id = 42\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar trace_1 = require(\"../common/trace\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return the number of dots in the fully qualified name\n        function uiViewDepth(uiView) {\n            return uiView.fqn.split(\".\").length;\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/view.js\n// module id = 43\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar stateMatcher_1 = require(\"./stateMatcher\");\nvar stateBuilder_1 = require(\"./stateBuilder\");\nvar stateQueueManager_1 = require(\"./stateQueueManager\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[State]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[State]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {State[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateRegistry.js\n// module id = 44\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar predicates_1 = require(\"../common/predicates\");\nvar glob_1 = require(\"../common/glob\");\nvar common_1 = require(\"../common/common\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base) {\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr) {\n            var matches = common_1.values(this._states)\n                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateMatcher.js\n// module id = 45\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[State]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[State]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent))\n            return null;\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateBuilder.js\n// module id = 46\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar stateObject_1 = require(\"./stateObject\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (config) {\n        var _a = this, states = _a.states, queue = _a.queue;\n        // Wrap a new object around the state so we can store our private details easily.\n        // @TODO: state = new State(extend({}, config, { ... }))\n        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n            self: config,\n            resolve: config.resolve || [],\n            toString: function () { return config.name; }\n        }));\n        if (!predicates_1.isString(state.name))\n            throw new Error(\"State must have a valid name\");\n        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n            throw new Error(\"State '\" + state.name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = this.$registry.get(state.name);\n                if (existingState && existingState.name === state.name) {\n                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n                }\n                if (existingState && existingState.name === state.name + \".**\") {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingState);\n                }\n                states[state.name] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[state.name];\n            previousQueueLength[state.name] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateQueueManager.js\n// module id = 47\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar queue_1 = require(\"../common/queue\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar node_1 = require(\"../path/node\");\nvar transitionService_1 = require(\"../transition/transitionService\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar targetState_1 = require(\"./targetState\");\nvar param_1 = require(\"../params/param\");\nvar glob_1 = require(\"../common/glob\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[State]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid())\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            if (latestThing() !== latest)\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false\n        });\n    };\n    ;\n    /**\n     * Transition to a different state or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n     * This allows you to easily use an absolute or relative to path and specify\n     * only the parameters you'd like to update (while letting unspecified parameters\n     * inherit from the currently active ancestor states).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     *\n     * @param to Absolute state name, state object, or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n     *\n     *    Parameter inheritance only works between common ancestor states, I.e.\n     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     *    will get you all current parameters, etc.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * - Possible success values:\n     *    - $state.current\n     *\n     * - Possible rejection reasons:\n     *   - transition superseded - when a newer transition has been started after this one\n     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n     *   - transition failed - when a transition hook errors\n     *   - resolve error - when a resolve has errored or rejected\n     *\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        var transHistory = globals.transitionHistory;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    router.urlRouter.update();\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    router.urlRouter.update();\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n            absolute: options.absolute\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateService.js\n// module id = 48\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = require(\"./params/stateParams\");\nvar queue_1 = require(\"./common/queue\");\nvar common_1 = require(\"./common/common\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar Globals = (function () {\n    /** @hidden */\n    function Globals(transitionService) {\n        var _this = this;\n        /** @inheritdoc */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n        // TODO: This probably belongs in a hooks/globals.ts\n        var beforeNewTransition = function ($transition$) {\n            _this.transition = $transition$;\n            _this.transitionHistory.enqueue($transition$);\n            var updateGlobalState = function () {\n                _this.successfulTransitions.enqueue($transition$);\n                _this.$current = $transition$.$to();\n                _this.current = _this.$current.self;\n                common_1.copy($transition$.params(), _this.params);\n            };\n            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n                _this.transition = null; };\n            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n        };\n        transitionService.onBefore({}, beforeNewTransition);\n    }\n    return Globals;\n}());\nexports.Globals = Globals;\n//# sourceMappingURL=globals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/globals.js\n// module id = 49\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/stateParams.js\n// module id = 50\n// module chunks = 0 1","/**\n * @coreapi\n * @module url\n */ /** */\n\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlService.js\n// module id = 51\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./param\"));\n__export(require(\"./paramTypes\"));\n__export(require(\"./stateParams\"));\n__export(require(\"./paramType\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/index.js\n// module id = 52\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module path */ /** for typedoc */\n__export(require(\"./node\"));\n__export(require(\"./pathFactory\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/index.js\n// module id = 53\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module resolve */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./resolvable\"));\n__export(require(\"./resolveContext\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/index.js\n// module id = 54\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./stateBuilder\"));\n__export(require(\"./stateObject\"));\n__export(require(\"./stateMatcher\"));\n__export(require(\"./stateQueueManager\"));\n__export(require(\"./stateRegistry\"));\n__export(require(\"./stateService\"));\n__export(require(\"./targetState\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/index.js\n// module id = 55\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./hookBuilder\"));\n__export(require(\"./hookRegistry\"));\n__export(require(\"./rejectFactory\"));\n__export(require(\"./transition\"));\n__export(require(\"./transitionHook\"));\n__export(require(\"./transitionEventType\"));\n__export(require(\"./transitionService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/index.js\n// module id = 56\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./urlMatcher\"));\n__export(require(\"./urlMatcherFactory\"));\n__export(require(\"./urlRouter\"));\n__export(require(\"./urlRule\"));\n__export(require(\"./urlService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/index.js\n// module id = 57\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./view\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/index.js\n// module id = 58\n// module chunks = 0 1","/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\n\"use strict\";\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/interface.js\n// module id = 59\n// module chunks = 0 1","# state->view logic specific to backbone (marionette)\n# ref: ui-router-ng1/statebuilders/views.ts\n\n# guess there's some missing magic here\n\n{ services, ViewService, ResolveContext, Resolvable } = require('ui-router-core')\n# AppLayout = require('javascripts/lib/views/layout')\nviewConfigId = 0\n\nhasAnyKey = (keys, obj) ->\n  # unused, copied from ui-router for ng1\n  _.reduce keys, ((memo, key) -> memo or obj[key]?), false\n\n\n\nexports.mnViewsBuilder = (state) ->\n  return if not state.parent\n\n  keys = ['view', 'controller']\n\n  views = {}\n  viewsObject = state.views or {$default: _.pick(state, keys)}\n\n  _.each viewsObject, (config, name) ->\n    name = name or '$default'\n\n    config.resolveAs = config.resolveAs or '$resolve'\n    config.$type = 'backbone'\n    config.$context = state\n    config.$name = name\n\n    normalized = ViewService.normalizeUIViewTarget config.$context, config.$name\n    config.$uiViewName = normalized.uiViewName\n    config.$uiViewContextAnchor = normalized.uiViewContextAnchor\n    views[name] = config\n\n  return views\n\n\n\nexports.MnViewConfig = class MnViewConfig\n  constructor: (@path, @viewDecl) ->\n    @loaded = true\n    @$id = viewConfigId++\n\n  load: ->\n    services.$q.when(@)\n\n\n\n// WEBPACK FOOTER //\n// ./src/state_views_builder.coffee","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./vanilla/index\"));\n//# sourceMappingURL=vanilla.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla.js\n// module id = 61\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * Naive, pure JS implementation of core ui-router services\n *\n *\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(require(\"./$q\"));\n__export(require(\"./$injector\"));\n__export(require(\"./baseLocationService\"));\n__export(require(\"./hashLocationService\"));\n__export(require(\"./memoryLocationService\"));\n__export(require(\"./pushStateLocationService\"));\n__export(require(\"./memoryLocationConfig\"));\n__export(require(\"./browserLocationConfig\"));\n__export(require(\"./plugins\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/index.js\n// module id = 62\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return new Promise(function (resolve, reject) {\n                var results = [];\n                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n                    .then(function () { resolve(results); }, reject);\n            });\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=$q.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$q.js\n// module id = 63\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=$injector.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$injector.js\n// module id = 64\n// module chunks = 0 1","/**\n * @internalapi\n * @module vanilla\n */ /** */\n\"use strict\";\nvar utils_1 = require(\"./utils\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/baseLocationService.js\n// module id = 65\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\nvar common_1 = require(\"../common/common\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/utils.js\n// module id = 66\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/hashLocationService.js\n// module id = 67\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationService.js\n// module id = 68\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/pushStateLocationService.js\n// module id = 69\n// module chunks = 0 1","\"use strict\";\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationConfig.js\n// module id = 70\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = require(\"../common/predicates\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        return parseInt(location.port);\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol;\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/browserLocationConfig.js\n// module id = 71\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = require(\"./browserLocationConfig\");\nvar hashLocationService_1 = require(\"./hashLocationService\");\nvar utils_1 = require(\"./utils\");\nvar pushStateLocationService_1 = require(\"./pushStateLocationService\");\nvar memoryLocationService_1 = require(\"./memoryLocationService\");\nvar memoryLocationConfig_1 = require(\"./memoryLocationConfig\");\nvar _injector_1 = require(\"./$injector\");\nvar _q_1 = require(\"./$q\");\nvar coreservices_1 = require(\"../common/coreservices\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = _injector_1.$injector;\n    coreservices_1.services.$q = _q_1.$q;\n    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/plugins.js\n// module id = 72\n// module chunks = 0 1","id = 0\nMn = require('backbone.marionette')\n{ ResolveContext } = require('ui-router-core')\n\n\n\nexports.UIViewMarionette = class UIViewMarionette extends Mn.Object\n  # Side note:\n  # If Marionette provided a way to use custom Region subclasses on a per-View\n  # basis I could register ui-views directly in the Region constructor instead\n  # of having this separate UIViewMarionette class and a custom\n  # LayoutView subclass, but I don't want to do that globally and attempt to\n  # register regions that aren't going to be managed by ui-router.\n\n  initialize: (@router, mnLayout, @mnRegion, mnRegionName) ->\n    console.log 'new uiview ' + mnRegionName\n    # Leverage Marionette's view lifecycle to know when to unregister\n    # the ui-view\n    @listenTo mnLayout, \"before:destroy\", @destroy\n\n    # Except for the top-level region passed to router.start(), a name should\n    # always be provided (even if it is '$default')\n    name = mnRegionName || '$default'\n    # TBH I'm not entirely sure what the context is for.\n    parentContext = mnLayout?.parent?.uiView?.activeUIView.config?.viewDecl?.$context\n    # nested FQNs will end up as something like\n    # '$default.$default.myNamedUIView.$default'\n    parentFqn = mnLayout?.parent?.uiView?.activeUIView?.fqn\n\n    @activeUIView =\n      $type: 'backbone'\n      id: id++\n      name: name\n      fqn: if parentFqn then \"#{parentFqn}.#{name}\" else name\n      creationContext: parentContext || @router.stateRegistry.root()\n      configUpdated: (config) => @onConfigUpdated(config)\n      config: undefined\n\n  register: ->\n    @deregister = @router.viewService.registerUIView(@activeUIView)\n\n  onConfigUpdated: (newConfig) ->\n    # If no config was provided (which happens right after registering this view\n    # or or when entering a state that has nothing to put in this slot), we want\n    # to make sure that the ui-view element is empty.\n    return @clearPreviousConfig() if not newConfig\n\n    # We somehow got a config for a different framework's ui-router integration\n    # (I imagine this is mainly an angular 1 to 2 migration thing?)\n    return if newConfig.viewDecl.$type isnt 'backbone'\n\n    # Got the currently active view config again.\n    return if @activeUIView.config is newConfig\n\n    @updateView(newConfig)\n\n  updateView: (newConfig) ->\n    @activeUIView.config = newConfig\n\n    # Create view and controller instances if they were specified in the\n    # state config.\n    resolved = @getResolved(newConfig)\n    view = @getView(newConfig, resolved: resolved)\n    controller = @getController(newConfig, resolved: resolved, view: view)\n\n    if view?\n      @mnRegion.show view\n      if controller?\n        @listenToOnce view, \"destroy\", ->\n          controller.destroy()\n\n  getResolved: (config) ->\n    # Map all resolved objects (plus $stateParams and $transition$)\n    # to a plain object to pass to the view and controller\n    context = new ResolveContext(config.path)\n    resolved = {}\n    keys = _.filter context.getTokens(), (token) -> typeof token is 'string'\n    resolved[key] = context.getResolvable(key).data for key in keys\n\n    return resolved\n\n  getView: (config, viewOptions) ->\n    if config?.viewDecl?.view?\n      view = new config.viewDecl.view(viewOptions)\n\n  getController: (config, controllerOptions) ->\n    if config?.viewDecl?.controller?\n      return new config.viewDecl.controller(controllerOptions)\n\n  clearPreviousConfig: ->\n    @mnRegion.empty()\n    @activeUIView.view? && @activeUIView.controller?.triggerMethod('view:destroyed')\n    @activeUIView.config = undefined\n\n  onBeforeDestroy: ->\n    @deregister?()\n\n\n\n// WEBPACK FOOTER //\n// ./src/uiview.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}\n// module id = 74\n// module chunks = 0 1","Mn = require('backbone.marionette')\n{ UIRouterMarionette } = require('../index')\n\n\n# A helper behavior for linking to states with or without state parameters.\n# Element attributes:\n#   ui-sref=\"app.state.substate\"\n#   ui-sparams='{\"client_id\": 5}' - optional if state doesn't need params or\n#                                   you're linking to a sibling/child state\n#                                   with the same parameters.\n#                                   The value should be HTML-encoded JSON.\n#                                   A template helper method is helpful here.\n# Behavior options: none\n#\nexports.UISref = class UISref extends Mn.Behavior\n  ui:\n    sref: '[ui-sref]'\n\n  events:\n    'click @ui.ref': 'onClickLink'\n\n  onClickLink: ->\n    # maybe parse and navigate to state if this element was inserted after\n    # original dom insertion (through data binding or whatever)\n\n  onAttach: ->\n    # Go through all the ui-sref links and turn their ui-sref and HTML-escaped\n    # ui-sparams attributes into a functioning app state link\n    router = UIRouterMarionette.getInstance()\n    @ui.sref.each (i, e) ->\n      e = $(e)\n      state = e.attr('ui-sref')\n      try\n        params = JSON.parse(e.attr 'ui-sparams')\n      url = router.stateService.href(state, params)\n\n      e.attr('href', url)\n\n\n\n# A behavior to toggle CSS classes on an element when a particular state\n# (with or without specific state parameters) is active.\n# Targets elements with a ui-sref-active attribute.\n# ui-sref-active can optionally have a value selecting the specific state\n# you want to watch for. If no value is provided, it will look to the state\n# referenced by ui-sref.\n# To help with lists that point at the same state with different state params,\n# the behavior will also compare the contents of ui-sparams, if present.\n# The default class is 'ui-state-active' but this can be customized in the\n# behavior options:\n# class MyView extends Marionette.ItemView\n#   behaviors:\n#     UISref: {}\n#     UISrefActive: {activeClasses: 'state-is-active'}\n#\nexports.UISrefActive = class UISrefActive extends Mn.Behavior\n  ui:\n    active: '[ui-sref-active]'\n\n  defaults:\n    activeClasses: 'ui-state-active'\n\n  initialize: ->\n    @router = UIRouterMarionette.getInstance()\n    @deregister = @router.transitionService.onSuccess {}, (transition) => @onStateChange()\n\n  onRender: ->\n    @onStateChange()\n\n  onStateChange: ->\n    @ui.active.each (i, el) =>\n      $el = $(el)\n      params = $el.attr('ui-sparams')\n      if params\n        params = JSON.parse(params)\n      compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref') # fall back to the state in ui-sref if the ui-sref-active attribute is present but empty\n      classFn = if @router.stateService.includes(compareState, params) then 'addClass' else 'removeClass'\n      $el[classFn](@options.activeClasses)\n\n  onBeforeDestroy: ->\n    @deregister()\n\n  removeListeners: ->\n    @ui.active.off('ui:state:change')\n\n\n\n// WEBPACK FOOTER //\n// ./src/marionette/behaviors.coffee","{ UIViewMarionette } = require('./uiview')\n{ UIRouterMarionette } = require('./router')\nMn = require('backbone.marionette')\n# A layout view for Marionette 2.x apps.\n# When the regions are created they also get registered as UIViews.\nmodule.exports = class UILayoutMn2 extends Mn.LayoutView\n  constructor: ->\n    super\n\n    @on \"attach\", @onAttachUI\n\n    @on \"before:destroy\", @onBeforeDestroyUI\n\n  regions:\n    # Register the first element with a ui-view attribute as the\n    # default region and UIView.\n    \"$default\": \"[ui-view]\"\n\n  onAttachUI: (me, parentRegion) ->\n    @parent = parentRegion\n    for own regionName, region of @regions\n      @[regionName].uiView = new UIViewMarionette UIRouterMarionette.getInstance(), @, @[regionName], regionName\n      @[regionName].uiView.register()\n    return\n\n  onBeforeDestroyUI: ->\n    @parent = null\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui_layout_mn2.coffee"],"sourceRoot":""}