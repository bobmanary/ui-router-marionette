{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///ui-router-marionette.min.js","webpack:///webpack/bootstrap fbbb5f460b2da7b44954?2dfe","webpack:///./src/index.coffee?3d3c","webpack:///external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}?8e93","webpack:///./src/router/index.coffee?7535","webpack:///./~/ui-router-core/lib/index.js?eb25","webpack:///./~/ui-router-core/lib/common/index.js?0a2c","webpack:///./~/ui-router-core/lib/common/common.js?cf4d","webpack:///./~/ui-router-core/lib/common/predicates.js?d043","webpack:///./~/ui-router-core/lib/common/hof.js?f100","webpack:///./~/ui-router-core/lib/common/coreservices.js?cdcd","webpack:///./~/ui-router-core/lib/common/glob.js?6b30","webpack:///./~/ui-router-core/lib/common/queue.js?d4a0","webpack:///./~/ui-router-core/lib/common/strings.js?311e","webpack:///./~/ui-router-core/lib/transition/rejectFactory.js?f278","webpack:///./~/ui-router-core/lib/transition/transition.js?cb73","webpack:///./~/ui-router-core/lib/common/trace.js?439e","webpack:///./~/ui-router-core/lib/transition/interface.js?90d0","webpack:///./~/ui-router-core/lib/transition/transitionHook.js?f358","webpack:///./~/ui-router-core/lib/state/targetState.js?a35d","webpack:///./~/ui-router-core/lib/transition/hookRegistry.js?e1c9","webpack:///./~/ui-router-core/lib/transition/hookBuilder.js?a5b9","webpack:///./~/ui-router-core/lib/path/node.js?8b12","webpack:///./~/ui-router-core/lib/params/param.js?ed16","webpack:///./~/ui-router-core/lib/params/paramType.js?33d4","webpack:///./~/ui-router-core/lib/path/pathFactory.js?a7a1","webpack:///./~/ui-router-core/lib/resolve/resolvable.js?1f09","webpack:///./~/ui-router-core/lib/resolve/resolveContext.js?1544","webpack:///./~/ui-router-core/lib/resolve/interface.js?a665","webpack:///./~/ui-router-core/lib/router.js?8102","webpack:///./~/ui-router-core/lib/url/urlMatcherFactory.js?891b","webpack:///./~/ui-router-core/lib/url/urlMatcher.js?d438","webpack:///./~/ui-router-core/lib/params/paramTypes.js?9d59","webpack:///./~/ui-router-core/lib/url/urlRouter.js?3a6c","webpack:///./~/ui-router-core/lib/url/urlRule.js?c28b","webpack:///./~/ui-router-core/lib/state/stateObject.js?c26a","webpack:///./~/ui-router-core/lib/transition/transitionService.js?3f7a","webpack:///./~/ui-router-core/lib/hooks/resolve.js?2c64","webpack:///./~/ui-router-core/lib/hooks/views.js?e195","webpack:///./~/ui-router-core/lib/hooks/url.js?b25f","webpack:///./~/ui-router-core/lib/hooks/redirectTo.js?5ea3","webpack:///./~/ui-router-core/lib/hooks/onEnterExitRetain.js?34a6","webpack:///./~/ui-router-core/lib/hooks/lazyLoad.js?7404","webpack:///./~/ui-router-core/lib/transition/transitionEventType.js?45f4","webpack:///./~/ui-router-core/lib/view/view.js?9313","webpack:///./~/ui-router-core/lib/state/stateRegistry.js?6ad5","webpack:///./~/ui-router-core/lib/state/stateMatcher.js?30f3","webpack:///./~/ui-router-core/lib/state/stateBuilder.js?a704","webpack:///./~/ui-router-core/lib/state/stateQueueManager.js?a439","webpack:///./~/ui-router-core/lib/state/stateService.js?0391","webpack:///./~/ui-router-core/lib/globals.js?0b2e","webpack:///./~/ui-router-core/lib/params/stateParams.js?da15","webpack:///./~/ui-router-core/lib/url/urlService.js?242b","webpack:///./~/ui-router-core/lib/params/index.js?06e6","webpack:///./~/ui-router-core/lib/path/index.js?c60f","webpack:///./~/ui-router-core/lib/resolve/index.js?785f","webpack:///./~/ui-router-core/lib/state/index.js?f8ea","webpack:///./~/ui-router-core/lib/transition/index.js?5aa5","webpack:///./~/ui-router-core/lib/url/index.js?33c0","webpack:///./~/ui-router-core/lib/view/index.js?03f5","webpack:///./~/ui-router-core/lib/interface.js?70a6","webpack:///./src/router/state_views_builder.coffee?534d","webpack:///./~/ui-router-core/lib/vanilla.js?67d6","webpack:///./~/ui-router-core/lib/vanilla/index.js?6019","webpack:///./~/ui-router-core/lib/vanilla/$q.js?b905","webpack:///./~/ui-router-core/lib/vanilla/$injector.js?e177","webpack:///./~/ui-router-core/lib/vanilla/baseLocationService.js?6a47","webpack:///./~/ui-router-core/lib/vanilla/utils.js?762f","webpack:///./~/ui-router-core/lib/vanilla/hashLocationService.js?8c71","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationService.js?f52a","webpack:///./~/ui-router-core/lib/vanilla/pushStateLocationService.js?25c4","webpack:///./~/ui-router-core/lib/vanilla/memoryLocationConfig.js?ea76","webpack:///./~/ui-router-core/lib/vanilla/browserLocationConfig.js?3d33","webpack:///./~/ui-router-core/lib/vanilla/plugins.js?4ce6","webpack:///./src/router/uiview.coffee?1554","webpack:///external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}?4413","webpack:///./src/router/marionette/behaviors.coffee?0d6a","webpack:///./src/router/ui_layout_mn2.coffee?3307"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_74__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","$q","UILayoutMn2","UIRouterMarionette","UISref","UISrefActive","UIViewMarionette","_","ref","ref1","extend","MnViewConfig","UIRouter","hashLocationPlugin","mnViewsBuilder","ref2","routerInstance","servicesPlugin","viewConfigFactory","child","parent","ctor","constructor","key","hasProp","prototype","__super__","hasOwnProperty","node","config","superClass","apply","arguments","_started","viewService","_pluginapi","_viewConfigFactory","plugin","stateRegistry","decorator","getInstance","start","rootRegion","Error","uiView","register","urlMatcherFactory","$get","urlService","listen","sync","__export","createProxyFunctions","source","target","bind","fnNames","latebind","bindFunction","fnName","makeLateRebindFn","Object","keys","reduce","acc","name","_inArray","array","obj","indexOf","_removeFrom","idx","splice","_pushTo","arr","val","push","defaults","opts","defaultsList","_i","length","merge","concat","pick","dst","objs","forEach","value","ancestors","first","second","path","n","pickOmitImpl","predicate","objCopy","inArray","restArgs","omit","notInArray","item","pluck","collection","propName","map","hof_1","prop","filter","callback","predicates_1","isArray","result","accept","x","i","find","pushR","assertFn","predicateOrMap","errMsg","isFunction","arrayTuples","arrayArgs","min","Math","Array","ignored","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_copyProps","to","from","_extend","toObj","identity","_equals","o1","o2","t1","t2","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","predicates","any","b","fn","a1","a2","t","coreservices_1","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","equals","noop","inherit","extra","args","slice","curry","removeFrom","pushTo","deregAll","functions","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","uniqR","token","unnest","flatten","assertPredicate","assertMap","pairs","sortBy","propFn","checkFn","a","composeSort","sortFns","prev","silenceUncaughtInPromise","promise","catch","e","silentRejection","error","services","reject","isInjectable","head","not","toStr","tis","isUndefined","isDefined","isNull","o","isNullOrUndefined","or","isNumber","isObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","funcs","reverse","fn1","fn2","invoke","pattern","struct","propEq","split","is","eq","other","v","notImplemented","fnname","$injector","Glob","text","glob","regexpString","seg","join","regexp","RegExp","matches","test","fromString","Queue","_items","_limit","enqueue","items","shift","dequeue","size","clear","current","remove","peekTail","peekHead","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","splitOnDelim","delim","re","common_1","joinNeighborsR","rejectFactory_1","transition_1","resolvable_1","stringifyPatternFn","isTransitionRejectionPromise","Rejection","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","RejectType","strings_1","type","message","detail","detailString","d","toPromise","then","superseded","options","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","errored","ERROR","trace_1","interface_1","transitionHook_1","hookRegistry_1","hookBuilder_1","node_1","pathFactory_1","targetState_1","param_1","resolveContext_1","router_1","stateSelf","fromPath","targetState","router","_deferred","defer","_registeredHooks","isActive","_options","_targetState","valid","$id","transitionService","_transitionCount","toPath","PathFactory","buildToPath","_treeChanges","treeChanges","reloadState","createTransitionHookRegFns","onCreateHooks","hookBuilder","buildHooksForPhase","TransitionHookPhase","CREATE","TransitionHook","runAllHooks","applyViewConfigs","applyRootResolvables","onBefore","criteria","onStart","onExit","onRetain","onEnter","onFinish","onSuccess","onError","_getEvents","hookPhase","makeEvent","getHooks","hookName","enteringStates","entering","state","$view","rootResolvables","params","rootNode","context","ResolveContext","addResolvables","$from","$to","self","compare","matchState","pathname","freeze","injector","pathName","subPath","getResolveTokens","getTokens","addResolvable","resolvable","stateName","topath","targetNode","resolveContext","redirectedFrom","originalTransition","rf","exiting","retained","views","redirect","redirects","trans","redirectOpts","location","newOptions","TargetState","identifier","$state","newTransition","create","originalEnteringNodes","redirectEnteringNodes","nodeIsReloading","includes","matchingEnteringNodes","PathNode","matching","resolvables","_changedParams","tc","reload","pathsDiffer","tuple","nodeSchemas","paramSchema","_a","paramValues","toValues","fromValues","tuples","schema","toVals","fromVals","Param","changed","dynamic","changes","HookBuilder","run","globals","transitionHistory","onBeforeHooks","BEFORE","syncResult","runOnBeforeHooks","rejectReason","trace","traceTransitionIgnored","transitionSuccess","traceSuccess","success","resolve","onSuccessHooks","SUCCESS","transitionError","reason","traceError","_error","onErrorHooks","traceTransitionStart","appendHookToChain","nextHook","invokeHook","asyncHooks","ASYNC","abstract","validates","parameters","fromStateOrName","toStateOrName","avoidEmptyHash","fromParams","toValid","toParams","diToken","uiViewString","viewData","creationContext","fqn","normalizedCat","input","Category","viewConfigString","viewConfig","viewDecl","$context","$uiViewName","$uiViewContextAnchor","Trace","_enabled","approximateDigests","_set","enabled","categories","k","parseInt","isNaN","category","enable","disable","TRANSITION","tid","transitionStr","console","log","traceHookInvocation","step","HOOK","event","registeredHook","traceHookResult","hookResult","transitionOptions","hookResultStr","traceResolvePath","when","RESOLVE","pathStr","traceResolvableResolved","resolvableStr","data","finalState","traceUIViewEvent","UIVIEW","traceUIViewConfigUpdated","traceUIViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUIViewEvent","TransitionHookScope","defaultOptions","transition","traceData","stateContext","stateService","rejectIfSuperseded","eventType","hook","_deregistered","errorHandler","getErrorHandler","resultHandler","getResultHandler","handleHookResult","isTargetState","hooks","results","hooks_1","chain","HANDLE_RESULT","IGNORE_RESULT","LOG_ERROR","defaultErrorHandler","REJECT_ERROR","THROW_ERROR","_identifier","_definition","_params","exists","base","relative","isDef","criterion","matchGlobs","_state","globStrings","toMatch","glob_1","matchFn","registry","hookRegistrationFn","matchObject","RegisteredHook","tranSvc","matchCriteria","priority","_matchingNodes","nodes","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","paths","mn","pathtype","isStateHook","scope","STATE","allMatched","every","tupleSort","reverseDepthSort","l","r","factor","depthDelta","toState","fromState","$transitions","baseHookOptions","phase","buildHooks","hookType","matchingHooks","getMatchingHooks","makeTransitionHooks","matchingNodes","criteriaMatchPath","transitionHook","sort","reverseSort","isCreate","registries","reg","stateOrPath","res","clone","applyRawParams","getParamVal","paramDef","pDef","parameter","paramValsEq","pathA","pathB","ignoreDynamicParams","changedParams","param","unwrapShorthand","cfg","isShorthand","$$fn","getType","urlType","paramTypes","DefType","CONFIG","PATH","SEARCH","paramType_1","ParamType","getSquashPolicy","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","hasOwn","getArrayMode","arrayDefaults","arrayParamNomenclature","$asArray","raw","defaultSquashPolicy","isDefaultValue","$$getDefaultValue","defaultValue","$replace","replacement","$normalize","isSearch","normalized","encoded","encode","exec","values1","values2","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","$arrayMode","def","decode","$subPattern","sub","makeTargetState","buildPath","inheritParams","states","viewDecls","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","applyToParams","retainedNode","cloned","keep","staticParams","nodesMatch","node1","node2","retainedWithToParams","elementIdx","defaultResolvePolicy","async","arg1","resolveFn","deps","policy","resolved","literal","getPolicy","thisPolicy","statePolicy","resolvePolicy","getResolvableDependencies","getDependencies","get","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","cache","take","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","fromData","resolvePolicies","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","_path","getResolvable","subContext","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","promises","nodeResolvables","nowait","wait","getResult","_injector","UIInjectorImpl","availableResolvables","getDependency","fromInjector","getNative","native","getAsync","WAIT","NOWAIT","RXWAIT","urlMatcherFactory_1","urlRouter_1","transitionService_1","view_1","stateRegistry_1","stateService_1","globals_1","urlService_1","_routerInstance","locationService","locationConfig","UrlService","locationServiceStub","locationConfigStub","ViewService","TransitionService","Globals","UrlMatcherFactory","urlRouter","UrlRouter","StateRegistry","StateService","_disposables","_plugins","_rootViewContext","$current","disposable","dispose","pluginInstance","getPlugin","pluginName","urlMatcher_1","paramTypes_1","ParamTypes","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strict","caseInsensitive","paramFactory","fromConfig","fromSearch","UrlMatcher","strictMode","compile","isMatcher","object","definition","definitionFn","_flushTypeQueue","quoteRegExp","string","surroundPattern","memoizeTo","_cache","_children","_segments","_compiled","paramMap","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","makeRegexpType","substring","index","lastIndex","search","append","url","isRoot","hash","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","j","validParamVal","getDetails","urlMatchers","pathSegmentsAndParams","queryParams","pathString","encodeDashes","encodeURIComponent","queryString","charCodeAt","toUpperCase","matcher","staticSegments","splitOnSlash","segments","aSegments","bSegments","weight","cmp","weightPair","initDefaultTypes","makeDefaultType","valToString","defaultTypeBase","String","query","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","json","typeQueue","defaultTypes","makeType","types","appendBasePath","isHtml5","absolute","baseHref","defaultRuleSortFn","urlRule_1","getMatcher","URLMATCHER","REGEXP","RAW","OTHER","_sortFn","_rules","interceptDeferred","_id","_router","urlRuleFactory","UrlRuleFactory","_otherwiseFn","compareFn","rules","best","checkRule","rule","matchPriority","evt","defaultPrevented","$url","applyResult","newurl","go","handler","_stopFn","onChange","update","read","urlMatcher","href","html5Mode","hashPrefix","slash","port","protocol","host","isUrlRule","removeRule","otherwise","handlerFn","deferIntercept","stateObject_1","what","makeRule","_what","fromUrlMatcher","State","fromRegExp","BaseUrlRule","optional","matched","_handler","details","transitionTo","global","sticky","redirectUrlTo","Number","matchingKeys","inherited","resolve_1","views_1","url_1","redirectTo_1","onEnterExitRetain_1","lazyLoad_1","transitionEventType_1","defaultTransOpts","notify","custom","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineDefaultPaths","_defineDefaultEvents","_registerDefaultTransitionHooks","onCreate","hooksArray","Phase","TH","_defineEvent","_definePathType","hookOrder","TransitionEventType","transitionHookTypes","cmpByPhase","hookScope","fns","redirectTo","registerRedirectToHook","registerOnExitHook","registerOnRetainHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","loadViews","registerLoadEnteringViews","activateViews","registerActivateViews","updateUrl","registerUpdateUrl","lazyLoad","registerLazyLoadHook","eagerResolvePath","lazyResolveState","loadEnteringViews","enteringViews","load","exitingViews","vc","deactivateViewConfig","activateViewConfig","$urlRouter","navigable","urlOptions","redirectToHook","handleResult","makeEnterExitRetainHook","hookFn","onExitHook","onRetainHook","onEnterHook","lazyLoadState","updateStateRegistry","lazyLoadFn","$$state","err","lazyLoadHook","retryTransition","orig","parts","_uiViews","_viewConfigs","_viewConfigFactories","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","decl","cfgFactory","$type","cfgs","uiViewDepth","viewConfigDepth","count","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","configUpdated","registerUIView","uiViews","fqnMatches","available","active","normalizeUIViewTarget","rawViewName","viewAtContext","uiViewName","uiViewContextAnchor","relativeViewNameSugar","charAt","relativeMatch","anchor","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","stateMatcher_1","stateBuilder_1","stateQueueManager_1","listeners","StateMatcher","builder","StateBuilder","stateQueue","StateQueueManager","_registerRoot","rootStateDef","#","_root","deregister","onStatesChanged","listener","stateDefinition","_deregisterTree","s","getChildren","children","deregistered","$ur","stateOrName","deregisteredStates","found","func","_states","isRelative","isStr","baseState","splitName","pathLength","relName","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","objects2Tuples","resolveObj","annotate","strictDi","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","parseUrl","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","parsed","paramConfig","reloadOnSearch","getNavigableBuilder","getParamsBuilder","makeConfigParam","urlParams","nonUrlParams","parentBuilder","parentName","builders","build","parentFn","lastSegment","pop","$registry","queue","flush","registered","orphans","previousQueueLength","orphanIdx","existingState","attachRoute","queue_1","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","defineProperty","enumerable","configurable","_handleInvalidTargetState","invokeNextCallback","nextCallback","callbackQueue","callbackResult","checkForRedirect","latestThing","latest","onInvalid","defautGoOpts","transOpts","getCurrentPath","latestSuccess","successfulTransitions","rootPath","transHistory","currentPath","rejectedTransitionHandler","transitionToPromise","include","defaultHrefOpts","lossy","$inherit","nav","stateParams_1","StateParams","beforeNewTransition","$transition$","updateGlobalState","clearCurrentTransition","newParams","parentParams","parents","inheritList","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","lateBind","locationServices","umf","urlParts","UIRouterPluginBase","hasAnyKey","viewConfigId","viewsObject","$default","each","resolveAs","$name","index_1","Promise","deferred","wait4","STRIP_COMMENTS","ARGUMENT_NAMES","has","locals","ensureExist","$inject","utils_1","BaseLocationServices","fireAfterUpdate","_listener","_listeners","_get","getParams","_location","_history","history","evt_1","Event","buildUrl","orEmptyString","splitHash","beforehash","_b","splitQuery","locationPluginFactory","serviceClass","configurationClass","service","configuration","splitEqual","trimHashVal","keyValsToObjectR","accum","loc","searchObject","vals","__extends","__","baseLocationService_1","HashLocationService","_super","addEventListener","title","removeEventListener","MemoryLocationService","_url","PushStateLocationService","_config","fullUrl","replaceState","pushState","MemoryLocationConfig","_baseHref","_port","_protocol","_host","_hashPrefix","newval","BrowserLocationConfig","_isHtml5","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","_injector_1","_q_1","browserLocationConfig_1","hashLocationService_1","pushStateLocationService_1","memoryLocationService_1","memoryLocationConfig_1","pushStateLocationPlugin","memoryLocationPlugin","Mn","initialize","mnLayout","mnRegion","mnRegionName","parentContext","parentFqn","ref3","ref4","ref5","ref6","listenTo","destroy","activeUIView","onConfigUpdated","newConfig","clearPreviousConfig","updateView","controller","getResolved","getView","getController","show","listenToOnce","len","viewOptions","controllerOptions","empty","triggerMethod","onBeforeDestroy","ui","sref","events","click @ui.ref","onClickLink","onAttach","$","attr","Behavior","activeClasses","onStateChange","onRender","el","$el","classFn","compareState","removeListeners","off","on","onAttachUI","onBeforeDestroyUI","regions","me","parentRegion","region","regionName","LayoutView"],"mappings":"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","file":"ui-router-marionette.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UIRouterMarionette\", [\"underscore\", \"backbone.marionette\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UIRouterMarionette\"] = factory(require(\"underscore\"), require(\"backbone.marionette\"));\n\telse\n\t\troot[\"UIRouterMarionette\"] = factory(root[\"_\"], root[\"Marionette\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_74__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, UILayoutMn2, UIRouterMarionette, UISref, UISrefActive, UIViewMarionette, _, ref, ref1;\n\t\n\t_ = __webpack_require__(2);\n\t\n\tref = __webpack_require__(3), $q = ref.$q, UIViewMarionette = ref.UIViewMarionette, UIRouterMarionette = ref.UIRouterMarionette;\n\t\n\tref1 = __webpack_require__(75), UISref = ref1.UISref, UISrefActive = ref1.UISrefActive;\n\t\n\tUILayoutMn2 = __webpack_require__(76);\n\t\n\t_.extend(exports, {\n\t  UIRouterMarionette: UIRouterMarionette,\n\t  UISref: UISref,\n\t  UISrefActive: UISrefActive,\n\t  UILayoutMn2: UILayoutMn2,\n\t  UIViewMarionette: UIViewMarionette,\n\t  $q: $q\n\t});\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $q, MnViewConfig, UIRouter, UIRouterMarionette, UIViewMarionette, hashLocationPlugin, mnViewsBuilder, ref, ref1, ref2, routerInstance, servicesPlugin, viewConfigFactory,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tref = __webpack_require__(4), UIRouter = ref.UIRouter, $q = ref.$q;\n\t\n\tref1 = __webpack_require__(60), mnViewsBuilder = ref1.mnViewsBuilder, MnViewConfig = ref1.MnViewConfig;\n\t\n\tref2 = __webpack_require__(61), hashLocationPlugin = ref2.hashLocationPlugin, servicesPlugin = ref2.servicesPlugin;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\trouterInstance = null;\n\t\n\tviewConfigFactory = function(node, config) {\n\t  return new MnViewConfig(node, config);\n\t};\n\t\n\tUIRouterMarionette = (function(superClass) {\n\t  extend(UIRouterMarionette, superClass);\n\t\n\t  UIRouterMarionette.getInstance = function() {\n\t    return routerInstance || (routerInstance = new this);\n\t  };\n\t\n\t  function UIRouterMarionette() {\n\t    UIRouterMarionette.__super__.constructor.apply(this, arguments);\n\t    this._started = false;\n\t    this.viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory);\n\t    this.plugin(servicesPlugin);\n\t    this.plugin(hashLocationPlugin);\n\t    this.stateRegistry.decorator(\"views\", mnViewsBuilder);\n\t    routerInstance = this;\n\t  }\n\t\n\t  UIRouterMarionette.prototype.start = function(rootRegion) {\n\t    this.rootRegion = rootRegion;\n\t    if (this._started) {\n\t      throw new Error(\"Router was already started\");\n\t    }\n\t    this.rootRegion.uiView = new UIViewMarionette(this, null, this.rootRegion, \"\");\n\t    this.rootRegion.uiView.register();\n\t    this.urlMatcherFactory.$get();\n\t    this.urlService.listen();\n\t    this.urlService.sync();\n\t    this._started = true;\n\t    return this;\n\t  };\n\t\n\t  return UIRouterMarionette;\n\t\n\t})(UIRouter);\n\t\n\texports.UIViewMarionette = UIViewMarionette;\n\t\n\texports.UIRouterMarionette = UIRouterMarionette;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module common\n\t */ /** */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(52));\n\t__export(__webpack_require__(53));\n\t__export(__webpack_require__(54));\n\t__export(__webpack_require__(55));\n\t__export(__webpack_require__(56));\n\t__export(__webpack_require__(57));\n\t__export(__webpack_require__(58));\n\t__export(__webpack_require__(49));\n\t__export(__webpack_require__(28));\n\t__export(__webpack_require__(59));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module common */ /** for typedoc */\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(12));\n\t__export(__webpack_require__(15));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * These functions are exported, but are subject to change without notice.\n\t *\n\t * @preferred\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\texports.copy = angular.copy || _copy;\n\texports.forEach = angular.forEach || _forEach;\n\texports.extend = angular.extend || _extend;\n\texports.equals = angular.equals || _equals;\n\texports.identity = function (x) { return x; };\n\texports.noop = function () { return undefined; };\n\t/**\n\t * Builds proxy functions on the `to` object which pass through to the `from` object.\n\t *\n\t * For each key in `fnNames`, creates a proxy function on the `to` object.\n\t * The proxy function calls the real function on the `from` object.\n\t *\n\t *\n\t * #### Example:\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * ```js\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * #### Example:\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param source A function that returns the source object which contains the original functions to be bound\n\t * @param target A function that returns the target object which will receive the bound functions\n\t * @param bind A function that returns the object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n\t */\n\tfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n\t    if (latebind === void 0) { latebind = false; }\n\t    var bindFunction = function (fnName) {\n\t        return source()[fnName].bind(bind());\n\t    };\n\t    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n\t        target[fnName] = bindFunction(fnName);\n\t        return target[fnName].apply(null, arguments);\n\t    }; };\n\t    fnNames = fnNames || Object.keys(source());\n\t    return fnNames.reduce(function (acc, name) {\n\t        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n\t        return acc;\n\t    }, target);\n\t}\n\texports.createProxyFunctions = createProxyFunctions;\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\texports.inherit = function (parent, extra) {\n\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t};\n\t/**\n\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t * This is similar to es6 rest parameters.\n\t *\n\t * Optionally, the argument at index idx may itself already be an array.\n\t *\n\t * For example,\n\t * given either:\n\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t * or:\n\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t * then:\n\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t *\n\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t *\n\t * given:\n\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t * then:\n\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t */\n\tvar restArgs = function (args, idx) {\n\t    if (idx === void 0) { idx = 0; }\n\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\texports.inArray = hof_1.curry(_inArray);\n\tfunction _inArray(array, obj) {\n\t    return array.indexOf(obj) !== -1;\n\t}\n\texports._inArray = _inArray;\n\t/**\n\t * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n\t * The same array is returned\n\t */\n\texports.removeFrom = hof_1.curry(_removeFrom);\n\tfunction _removeFrom(array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t}\n\texports._removeFrom = _removeFrom;\n\t/** pushes a values to an array and returns the value */\n\texports.pushTo = hof_1.curry(_pushTo);\n\tfunction _pushTo(arr, val) {\n\t    return (arr.push(val), val);\n\t}\n\texports._pushTo = _pushTo;\n\t/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\n\texports.deregAll = function (functions) {\n\t    return functions.slice().forEach(function (fn) {\n\t        typeof fn === 'function' && fn();\n\t        exports.removeFrom(functions, fn);\n\t    });\n\t};\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    if (opts === void 0) { opts = {}; }\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t}\n\texports.defaults = defaults;\n\t/**\n\t * Merges properties from the list of objects to the destination object.\n\t * If a property already exists in the destination object, then it is not overwritten.\n\t */\n\tfunction merge(dst) {\n\t    var objs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        objs[_i - 1] = arguments[_i];\n\t    }\n\t    exports.forEach(objs, function (obj) {\n\t        exports.forEach(obj, function (value, key) {\n\t            if (!dst.hasOwnProperty(key))\n\t                dst[key] = value;\n\t        });\n\t    });\n\t    return dst;\n\t}\n\texports.merge = merge;\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\texports.ancestors = ancestors;\n\tfunction pickOmitImpl(predicate, obj) {\n\t    var keys = [];\n\t    for (var _i = 2; _i < arguments.length; _i++) {\n\t        keys[_i - 2] = arguments[_i];\n\t    }\n\t    var objCopy = {};\n\t    for (var key in obj) {\n\t        if (predicate(keys, key))\n\t            objCopy[key] = obj[key];\n\t    }\n\t    return objCopy;\n\t}\n\t/** Return a copy of the object only containing the whitelisted properties. */\n\tfunction pick(obj) {\n\t    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n\t}\n\texports.pick = pick;\n\t/** Return a copy of the object omitting the blacklisted properties. */\n\tfunction omit(obj) {\n\t    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n\t    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n\t}\n\texports.omit = omit;\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, hof_1.prop(propName));\n\t}\n\texports.pluck = pluck;\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    exports.forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\texports.filter = filter;\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    exports.forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\texports.find = find;\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\texports.mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\texports.map = map;\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\texports.values = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return obj[key]; });\n\t};\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flattenR = function (memo, elem) {\n\t    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n\t};\n\t/**\n\t * Reduce function that pushes an object to an array, then returns the array.\n\t * Mostly just for [[flattenR]] and [[uniqR]]\n\t */\n\tfunction pushR(arr, obj) {\n\t    arr.push(obj);\n\t    return arr;\n\t}\n\texports.pushR = pushR;\n\t/** Reduce function that filters out duplicates */\n\texports.uniqR = function (acc, token) {\n\t    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n\t};\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\texports.assertPredicate = assertFn;\n\t/**\n\t * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n\t * @example\n\t * ```\n\t *\n\t * var data = { foo: 1, bar: 2 };\n\t *\n\t * let keys = [ 'foo', 'bar' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // values is [1, 2]\n\t *\n\t * let keys = [ 'foo', 'bar', 'baz' ]\n\t * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n\t * // throws Error(\"Key not found\")\n\t * ```\n\t */\n\texports.assertMap = assertFn;\n\tfunction assertFn(predicateOrMap, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        var result = predicateOrMap(obj);\n\t        if (!result) {\n\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.assertFn = assertFn;\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\texports.pairs = function (obj) {\n\t    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n\t};\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var arrayArgs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        arrayArgs[_i] = arguments[_i];\n\t    }\n\t    if (arrayArgs.length === 0)\n\t        return [];\n\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t}\n\texports.arrayTuples = arrayTuples;\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (predicates_1.isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!predicates_1.isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\texports.applyPairs = applyPairs;\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\texports.tail = tail;\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return exports.extend(dest, src);\n\t}\n\t/** Naive forEach implementation works with Objects or Arrays */\n\tfunction _forEach(obj, cb, _this) {\n\t    if (predicates_1.isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _copyProps(to, from) {\n\t    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n\t    return to;\n\t}\n\tfunction _extend(toObj) {\n\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t/**\n\t * Create a sort function\n\t *\n\t * Creates a sort function which sorts by a numeric property.\n\t *\n\t * The `propFn` should return the property as a number which can be sorted.\n\t *\n\t * #### Example:\n\t * This example returns the `priority` prop.\n\t * ```js\n\t * var sortfn = sortBy(obj => obj.priority)\n\t * // equivalent to:\n\t * var longhandSortFn = (a, b) => a.priority - b.priority;\n\t * ```\n\t *\n\t * #### Example:\n\t * This example uses [[prop]]\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'))\n\t * ```\n\t *\n\t * The `checkFn` can be used to exclude objects from sorting.\n\t *\n\t * #### Example:\n\t * This example only sorts objects with type === 'FOO'\n\t * ```js\n\t * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n\t * ```\n\t *\n\t * @param propFn a function that returns the property (as a number)\n\t * @param checkFn a predicate\n\t *\n\t * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n\t */\n\texports.sortBy = function (propFn, checkFn) {\n\t    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n\t    return function (a, b) {\n\t        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n\t    };\n\t};\n\t/**\n\t * Composes a list of sort functions\n\t *\n\t * Creates a sort function composed of multiple sort functions.\n\t * Each sort function is invoked in series.\n\t * The first sort function to return non-zero \"wins\".\n\t *\n\t * @param sortFns list of sort functions\n\t */\n\texports.composeSort = function () {\n\t    var sortFns = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        sortFns[_i] = arguments[_i];\n\t    }\n\t    return function (a, b) {\n\t        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n\t    };\n\t};\n\t// issue #2676\n\texports.silenceUncaughtInPromise = function (promise) {\n\t    return promise.catch(function (e) { return 0; }) && promise;\n\t};\n\texports.silentRejection = function (error) {\n\t    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n\t};\n\t//# sourceMappingURL=common.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** Predicates\n\t *\n\t * These predicates return true/false based on the input.\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_predicates\n\t */ /** */\n\tvar hof_1 = __webpack_require__(8);\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\texports.isUndefined = tis('undefined');\n\texports.isDefined = hof_1.not(exports.isUndefined);\n\texports.isNull = function (o) { return o === null; };\n\texports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\n\texports.isFunction = tis('function');\n\texports.isNumber = tis('number');\n\texports.isString = tis('string');\n\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\texports.isArray = Array.isArray;\n\texports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\n\texports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val) {\n\t    if (exports.isArray(val) && val.length) {\n\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t    }\n\t    return exports.isFunction(val);\n\t}\n\texports.isInjectable = isInjectable;\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\t//# sourceMappingURL=predicates.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Higher order functions\n\t *\n\t * These utility functions are exported, but are subject to change without notice.\n\t *\n\t * @module common_hof\n\t */ /** */\n\t\"use strict\";\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\texports.curry = curry;\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\texports.compose = compose;\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\texports.pipe = pipe;\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\texports.prop = function (name) {\n\t    return function (obj) { return obj && obj[name]; };\n\t};\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\texports.parse = function (name) {\n\t    return pipe.apply(null, name.split(\".\").map(exports.prop));\n\t};\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\texports.not = function (fn) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return !fn.apply(null, args);\n\t    };\n\t};\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\texports.and = and;\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\texports.or = or;\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\texports.all = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n\t};\n\texports.any = function (fn1) {\n\t    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n\t};\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\texports.is = function (ctor) {\n\t    return function (obj) {\n\t        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n\t    };\n\t};\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\texports.eq = function (val) { return function (other) {\n\t    return val === other;\n\t}; };\n\t/** Given a value, returns a function which returns the value */\n\texports.val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) {\n\t        return obj[fnName].apply(obj, args);\n\t    };\n\t}\n\texports.invoke = invoke;\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\texports.pattern = pattern;\n\t//# sourceMappingURL=hof.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t};\n\texports.services = services;\n\t//# sourceMappingURL=coreservices.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */\n\t/**\n\t * Matches state names using glob-like pattern strings.\n\t *\n\t * Globs can be used in specific APIs including:\n\t *\n\t * - [[StateService.is]]\n\t * - [[StateService.includes]]\n\t * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n\t *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n\t *\n\t * A `Glob` string is a pattern which matches state names.\n\t * Nested state names are split into segments (separated by a dot) when processing.\n\t * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n\t *\n\t * Globs work according to the following rules:\n\t *\n\t * ### Exact match:\n\t *\n\t * The glob `'A.B'` matches the state named exactly `'A.B'`.\n\t *\n\t * | Glob        |Matches states named|Does not match state named|\n\t * |:------------|:--------------------|:---------------------|\n\t * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n\t * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n\t * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n\t *\n\t * ### Single star (`*`)\n\t *\n\t * A single star (`*`) is a wildcard that matches exactly one segment.\n\t *\n\t * | Glob        |Matches states named  |Does not match state named |\n\t * |:------------|:---------------------|:--------------------------|\n\t * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n\t * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n\t * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n\t *\n\t * ### Double star (`**`)\n\t *\n\t * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n\t *\n\t * | Glob        |Matches states named                           |Does not match state named         |\n\t * |:------------|:----------------------------------------------|:----------------------------------|\n\t * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n\t * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n\t * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n\t * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n\t *\n\t */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t        var regexpString = this.text.split('.')\n\t            .map(function (seg) {\n\t            if (seg === '**')\n\t                return '(?:|(?:\\\\.[^.]*)*)';\n\t            if (seg === '*')\n\t                return '\\\\.[^.]*';\n\t            return '\\\\.' + seg;\n\t        }).join('');\n\t        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        return this.regexp.test('.' + name);\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.is = function (text) {\n\t        return text.indexOf('*') > -1;\n\t    };\n\t    /** @deprecated whats the point? */\n\t    Glob.fromString = function (text) {\n\t        if (!this.is(text))\n\t            return null;\n\t        return new Glob(text);\n\t    };\n\t    return Glob;\n\t}());\n\texports.Glob = Glob;\n\t//# sourceMappingURL=glob.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\texports.Queue = Queue;\n\t//# sourceMappingURL=queue.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Functions that manipulate strings\n\t *\n\t * Although these functions are exported, they are subject to change without notice.\n\t *\n\t * @module common_strings\n\t */ /** */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar transition_1 = __webpack_require__(14);\n\tvar resolvable_1 = __webpack_require__(25);\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\texports.maxLength = maxLength;\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\texports.padString = padString;\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\texports.kebobString = kebobString;\n\tfunction _toJson(obj) {\n\t    return JSON.stringify(obj);\n\t}\n\tfunction _fromJson(json) {\n\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t}\n\tfunction promiseToString(p) {\n\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t    var fnName = fn['name'] || \"\";\n\t    if (fnName && toStr.match(/function \\(/)) {\n\t        return 'function ' + fnName + toStr.substr(9);\n\t    }\n\t    return toStr;\n\t}\n\texports.functionToString = functionToString;\n\tfunction fnToString(fn) {\n\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\texports.fnToString = fnToString;\n\tvar stringifyPatternFn = null;\n\tvar stringifyPattern = function (value) {\n\t    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\t    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n\t        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t        [predicates_1.isNull, hof_1.val(\"null\")],\n\t        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n\t        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t        [predicates_1.isInjectable, functionToString],\n\t        [hof_1.val(true), common_1.identity]\n\t    ]);\n\t    return stringifyPatternFn(value);\n\t};\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val) {\n\t        if (predicates_1.isObject(val)) {\n\t            if (seen.indexOf(val) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val);\n\t        }\n\t        return stringifyPattern(val);\n\t    }\n\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t}\n\texports.stringify = stringify;\n\t/** Returns a function that splits a string on a character or substring */\n\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\t/**\n\t * Splits on a delimiter, but returns the delimiters in the array\n\t *\n\t * #### Example:\n\t * ```js\n\t * var splitOnSlashes = splitOnDelim('/');\n\t * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n\t * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n\t * ```\n\t */\n\tfunction splitOnDelim(delim) {\n\t    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n\t    return function (str) {\n\t        return str.split(re).filter(common_1.identity);\n\t    };\n\t}\n\texports.splitOnDelim = splitOnDelim;\n\t;\n\t/**\n\t * Reduce fn that joins neighboring strings\n\t *\n\t * Given an array of strings, returns a new array\n\t * where all neighboring strings have been joined.\n\t *\n\t * #### Example:\n\t * ```js\n\t * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n\t * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n\t * ```\n\t */\n\tfunction joinNeighborsR(acc, x) {\n\t    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n\t        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n\t    return common_1.pushR(acc, x);\n\t}\n\texports.joinNeighborsR = joinNeighborsR;\n\t;\n\t//# sourceMappingURL=strings.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar RejectType;\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n\t})(RejectType = exports.RejectType || (exports.RejectType = {}));\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) {\n\t            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n\t        };\n\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition\";\n\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a TransitionRejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid\";\n\t        return new Rejection(RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored\";\n\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition has been aborted\";\n\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.errored = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition errored\";\n\t        return new Rejection(RejectType.ERROR, message, detail);\n\t    };\n\t    return Rejection;\n\t}());\n\texports.Rejection = Rejection;\n\t//# sourceMappingURL=rejectFactory.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar hookBuilder_1 = __webpack_require__(20);\n\tvar node_1 = __webpack_require__(21);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar router_1 = __webpack_require__(28);\n\t/** @hidden */\n\tvar stateSelf = hof_1.prop(\"self\");\n\t/**\n\t * Represents a transition between two states.\n\t *\n\t * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n\t *\n\t * This object contains all contextual information about the to/from states, parameters, resolves.\n\t * It has information about all states being entered and exited as a result of the transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param router The [[UIRouter]] instance\n\t     */\n\t    function Transition(fromPath, targetState, router) {\n\t        var _this = this;\n\t        /** @hidden */\n\t        this._deferred = coreservices_1.services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n\t        this._registeredHooks = {};\n\t        /**\n\t         * Checks if this transition is currently active/running.\n\t         */\n\t        this.isActive = function () { return _this === _this._options.current(); };\n\t        this.router = router;\n\t        this._targetState = targetState;\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t        this.$id = router.transitionService._transitionCount++;\n\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        this.createTransitionHookRegFns();\n\t        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n\t        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n\t        this.applyViewConfigs(router);\n\t        this.applyRootResolvables(router);\n\t    }\n\t    /** @hidden */\n\t    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    Transition.prototype.onError = function (criteria, callback, options) { return; };\n\t    /** @hidden\n\t     * Creates the transition-level hook registration functions\n\t     * (which can then be used to register hooks)\n\t     */\n\t    Transition.prototype.createTransitionHookRegFns = function () {\n\t        var _this = this;\n\t        this.router.transitionService._pluginapi._getEvents()\n\t            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n\t            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n\t    };\n\t    /** @internalapi */\n\t    Transition.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    Transition.prototype.applyViewConfigs = function (router) {\n\t        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n\t        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n\t    };\n\t    Transition.prototype.applyRootResolvables = function (router) {\n\t        var _this = this;\n\t        var rootResolvables = [\n\t            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n\t            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n\t            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n\t        ];\n\t        var rootNode = this._treeChanges.to[0];\n\t        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n\t        context.addResolvables(rootResolvables, rootNode.state);\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal from [State] object\n\t     */\n\t    Transition.prototype.$from = function () {\n\t        return common_1.tail(this._treeChanges.from).state;\n\t    };\n\t    /**\n\t     * @internalapi\n\t     *\n\t     * @returns the internal to [State] object\n\t     */\n\t    Transition.prototype.$to = function () {\n\t        return common_1.tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * Returns the state that the transition is coming *from*.\n\t     *\n\t     * @returns The state declaration object for the Transition's (\"from state\").\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * Returns the state that the transition is going *to*.\n\t     *\n\t     * @returns The state declaration object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Gets the Target State\n\t     *\n\t     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n\t     *\n\t     * @returns the [[TargetState]] of this Transition\n\t     */\n\t    Transition.prototype.targetState = function () {\n\t        return this._targetState;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n\t    };\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    /**\n\t     * Creates a [[UIInjector]] Dependency Injector\n\t     *\n\t     * Returns a Dependency Injector for the Transition's target state (to state).\n\t     * The injector provides resolve values which the target state has access to.\n\t     *\n\t     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ entering: 'myState' }, trans => {\n\t     *   var myResolveValue = trans.injector().get('myResolve');\n\t     *   // Inject a global service from the global/native injector (if it exists)\n\t     *   var MyService = trans.injector().get('MyService');\n\t     * })\n\t     * ```\n\t     *\n\t     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n\t     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n\t     * #### Example:\n\t     * ```js\n\t     * .onBefore({}, trans => {\n\t     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n\t     *     return myResolveValue !== 'ABORT';\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n\t     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n\t     * #### Example:\n\t     * ```js\n\t     * .onEnter({ to: 'foo.bar' }, trans => {\n\t     *   // returns result of `foo` state's `data` resolve\n\t     *   // even though `foo.bar` also has a `data` resolve\n\t     *   var fooData = trans.injector('foo').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n\t     * The resolve data from the `from` path will be returned.\n\t     * #### Example:\n\t     * ```js\n\t     * .onExit({ exiting: 'foo.bar' }, trans => {\n\t     *   // Gets the resolve value of `data` from the exiting state.\n\t     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n\t     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n\t     *\n\t     * @returns a [[UIInjector]]\n\t     */\n\t    Transition.prototype.injector = function (state, pathName) {\n\t        if (pathName === void 0) { pathName = \"to\"; }\n\t        var path = this._treeChanges[pathName];\n\t        if (state)\n\t            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n\t        return new resolveContext_1.ResolveContext(path).injector();\n\t    };\n\t    /**\n\t     * Gets all available resolve tokens (keys)\n\t     *\n\t     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n\t     * available to the Transition.\n\t     *\n\t     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n\t     * in the Transition's [[TreeChanges.to]] path.\n\t     *\n\t     * #### Example:\n\t     * This example logs all resolve values\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n\t     * ```\n\t     *\n\t     * #### Example:\n\t     * This example creates promises for each resolve value.\n\t     * This triggers fetches of resolves (if any have not yet been fetched).\n\t     * When all promises have all settled, it logs the resolve values.\n\t     * ```js\n\t     * let tokens = trans.getResolveTokens();\n\t     * let promise = tokens.map(token => trans.injector().getAsync(token));\n\t     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n\t     * ```\n\t     *\n\t     * Note: Angular 1 users whould use `$q.all()`\n\t     *\n\t     * @param pathname resolve context's path name (e.g., `to` or `from`)\n\t     *\n\t     * @returns an array of resolve tokens (keys)\n\t     */\n\t    Transition.prototype.getResolveTokens = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n\t    };\n\t    /**\n\t     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * transitionService.onBefore({}, transition => {\n\t     *   transition.addResolvable({\n\t     *     token: 'myResolve',\n\t     *     deps: ['MyService'],\n\t     *     resolveFn: myService => myService.getData()\n\t     *   });\n\t     * });\n\t     * ```\n\t     *\n\t     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n\t     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolvable = function (resolvable, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t        var resolveContext = new resolveContext_1.ResolveContext(topath);\n\t        resolveContext.addResolvables([resolvable], targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the transition from which this transition was redirected.\n\t     *\n\t     * If the current transition is a redirect, this method returns the transition that was redirected.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let transitionA = $state.go('A').transition\n\t     * transitionA.onStart({}, () => $state.target('B'));\n\t     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n\t     *   trans.to().name === 'B'; // true\n\t     *   trans.redirectedFrom() === transitionA; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.redirectedFrom = function () {\n\t        return this._options.redirectedFrom || null;\n\t    };\n\t    /**\n\t     * Gets the original transition in a redirect chain\n\t     *\n\t     * A transition might belong to a long chain of multiple redirects.\n\t     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * // states\n\t     * registry.register({ name: 'A', redirectTo: 'B' });\n\t     * registry.register({ name: 'B', redirectTo: 'C' });\n\t     * registry.register({ name: 'C', redirectTo: 'D' });\n\t     * registry.register({ name: 'D' });\n\t     *\n\t     * let transitionA = $state.go('A').transition\n\t     *\n\t     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n\t     *   trans.to().name === 'D'; // true\n\t     *   trans.redirectedFrom().to().name === 'C'; // true\n\t     *   trans.originalTransition() === transitionA; // true\n\t     *   trans.originalTransition().to().name === 'A'; // true\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns The original Transition that started a redirect chain\n\t     */\n\t    Transition.prototype.originalTransition = function () {\n\t        var rf = this.redirectedFrom();\n\t        return (rf && rf.originalTransition()) || this;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t    };\n\t    Transition.prototype.treeChanges = function (pathname) {\n\t        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n\t    };\n\t    /**\n\t     * Creates a new transition that is a redirection of the current one.\n\t     *\n\t     * This transition can be returned from a [[TransitionService]] hook to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns Returns a new [[Transition]] instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var redirects = 1, trans = this;\n\t        while ((trans = trans.redirectedFrom()) != null) {\n\t            if (++redirects > 20)\n\t                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n\t        }\n\t        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n\t        // If the original transition was caused by URL sync, then use { location: 'replace' }\n\t        // on the new transition (unless  the target state explicitly specifies location)\n\t        if (this.options().source === 'url') {\n\t            redirectOpts.location = 'replace';\n\t        }\n\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n\t        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n\t        var originalEnteringNodes = this._treeChanges.entering;\n\t        var redirectEnteringNodes = newTransition._treeChanges.entering;\n\t        // --- Re-use resolve data from original transition ---\n\t        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n\t        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n\t        // redirected transition.\n\t        //\n\t        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n\t        // You can wait for the resolve, then redirect to a child state based on the result.\n\t        // The redirected transition does not have to re-fetch the resolve.\n\t        // ---------------------------------------------------------\n\t        var nodeIsReloading = function (reloadState) { return function (node) {\n\t            return reloadState && node.state.includes[reloadState.name];\n\t        }; };\n\t        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n\t        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n\t            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n\t        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n\t        matchingEnteringNodes.forEach(function (node, idx) {\n\t            node.resolvables = originalEnteringNodes[idx].resolvables;\n\t        });\n\t        return newTransition;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var tc = this._treeChanges;\n\t        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n\t        // If user explicitly wants a reload\n\t        if (this._options.reload)\n\t            return undefined;\n\t        // If any states are exiting or entering\n\t        if (tc.exiting.length || tc.entering.length)\n\t            return undefined;\n\t        // If to/from path lengths differ\n\t        if (tc.to.length !== tc.from.length)\n\t            return undefined;\n\t        // If the to/from paths are different\n\t        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n\t            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n\t            .reduce(common_1.anyTrueR, false);\n\t        if (pathsDiffer)\n\t            return undefined;\n\t        // Find any parameter values that differ\n\t        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n\t        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return param_1.Param.changed(schema, toVals, fromVals);\n\t        }).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.length === 0;\n\t    };\n\t    /**\n\t     * @hidden\n\t     */\n\t    Transition.prototype.hookBuilder = function () {\n\t        return new hookBuilder_1.HookBuilder(this);\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @internalapi\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n\t        var hookBuilder = this.hookBuilder();\n\t        var globals = this.router.globals;\n\t        globals.transitionHistory.enqueue(this);\n\t        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n\t        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t            var rejectReason = syncResult._transitionRejection;\n\t            this._deferred.reject(rejectReason);\n\t            return this.promise;\n\t        }\n\t        if (!this.valid()) {\n\t            var error = new Error(this.error());\n\t            this._deferred.reject(error);\n\t            return this.promise;\n\t        }\n\t        if (this.ignored()) {\n\t            trace_1.trace.traceTransitionIgnored(this);\n\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t            return this.promise;\n\t        }\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var transitionSuccess = function () {\n\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this.to());\n\t            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n\t            runAllHooks(onSuccessHooks);\n\t        };\n\t        var transitionError = function (reason) {\n\t            trace_1.trace.traceError(reason, _this);\n\t            _this.success = false;\n\t            _this._deferred.reject(reason);\n\t            _this._error = reason;\n\t            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n\t            runAllHooks(onErrorHooks);\n\t        };\n\t        trace_1.trace.traceTransitionStart(this);\n\t        // Chain the next hook off the previous\n\t        var appendHookToChain = function (prev, nextHook) {\n\t            return prev.then(function () { return nextHook.invokeHook(); });\n\t        };\n\t        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n\t        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n\t        asyncHooks.reduce(appendHookToChain, syncResult)\n\t            .then(transitionSuccess, transitionError);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error() || this.success !== undefined;\n\t    };\n\t    /**\n\t     * The Transition error reason.\n\t     *\n\t     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n\t     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n\t     *\n\t     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self.abstract)\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        if (!param_1.Param.validates(state.parameters(), this.params()))\n\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t        if (this.success === false)\n\t            return this._error;\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    return Transition;\n\t}());\n\t/** @hidden */\n\tTransition.diToken = Transition;\n\texports.Transition = Transition;\n\t//# sourceMappingURL=transition.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * # Transition tracing (debug)\n\t *\n\t * Enable transition tracing to print transition information to the console,\n\t * in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n\t *\n\t * ### ES6\n\t * ```js\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * ### CJS\n\t * ```js\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * ### Globals\n\t * ```js\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * ### Angular 1:\n\t * ```js\n\t * app.run($trace => $trace.enable());\n\t * ```\n\t *\n\t * @coreapi\n\t * @module trace\n\t */ /** for typedoc */\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction uiViewString(viewData) {\n\t    if (!viewData)\n\t        return 'ui-view (defunct)';\n\t    return \"[ui-view#\" + viewData.id + \" tag \" +\n\t        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n\t        (\"fqn: '\" + viewData.fqn + \"', \") +\n\t        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t}\n\t/**\n\t * Trace categories Enum\n\t *\n\t * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\tvar Category;\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n\t})(Category = exports.Category || (exports.Category = {}));\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    /** @hidden */\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(Category)\n\t                .map(function (k) { return parseInt(k, 10); })\n\t                .filter(function (k) { return !isNaN(k); })\n\t                .map(function (key) { return Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    /**\n\t     * Enables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enable(\"TRANSITION\");\n\t     * ```\n\t     *\n\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    /**\n\t     * Disables a trace [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.disable(\"VIEWCONFIG\");\n\t     * ```\n\t     *\n\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```js\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, when, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceError = function (reason, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, trans) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n\t        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceUIViewFill = function (viewData, html) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** @internalapi called by ui-router code */\n\t    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\texports.Trace = Trace;\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * #### Example:\n\t * ```js\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\texports.trace = trace;\n\t//# sourceMappingURL=trace.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar TransitionHookPhase;\n\t(function (TransitionHookPhase) {\n\t    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n\t    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n\t    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n\t})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\n\tvar TransitionHookScope;\n\t(function (TransitionHookScope) {\n\t    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n\t    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n\t})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar defaultOptions = {\n\t    current: common_1.noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null\n\t};\n\t/** @hidden */\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(transition, stateContext, registeredHook, options) {\n\t        var _this = this;\n\t        this.transition = transition;\n\t        this.stateContext = stateContext;\n\t        this.registeredHook = registeredHook;\n\t        this.options = options;\n\t        this.stateService = function () { return _this.transition.router.stateService; };\n\t        this.rejectIfSuperseded = function () {\n\t            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n\t        };\n\t        this.options = common_1.defaults(options, defaultOptions);\n\t    }\n\t    TransitionHook.prototype.invokeHook = function () {\n\t        var hook = this.registeredHook;\n\t        if (hook._deregistered)\n\t            return;\n\t        var options = this.options;\n\t        trace_1.trace.traceHookInvocation(this, this.transition, options);\n\t        if (this.rejectIfSuperseded()) {\n\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t        }\n\t        var cb = hook.callback;\n\t        var bind = this.options.bind;\n\t        var trans = this.transition;\n\t        var state = this.stateContext;\n\t        var errorHandler = hook.eventType.getErrorHandler(this);\n\t        var resultHandler = hook.eventType.getResultHandler(this);\n\t        resultHandler = resultHandler || common_1.identity;\n\t        if (!errorHandler) {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        try {\n\t            return resultHandler(cb.call(bind, trans, state));\n\t        }\n\t        catch (error) {\n\t            return errorHandler(error);\n\t        }\n\t    };\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false (cancel), a TargetState (redirect),\n\t     * or a promise (which may later resolve to false or a redirect)\n\t     *\n\t     * This also handles \"transition superseded\" -- when a new transition\n\t     * was started while the hook was still running\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (result) {\n\t        // This transition is no longer current.\n\t        // Another transition started while this hook was still running.\n\t        if (this.rejectIfSuperseded()) {\n\t            // Abort this transition\n\t            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n\t        }\n\t        // Hook returned a promise\n\t        if (predicates_1.isPromise(result)) {\n\t            // Wait for the promise, then reprocess the resolved value\n\t            return result.then(this.handleHookResult.bind(this));\n\t        }\n\t        trace_1.trace.traceHookResult(result, this.transition, this.options);\n\t        // Hook returned false\n\t        if (result === false) {\n\t            // Abort this Transition\n\t            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n\t        }\n\t        var isTargetState = hof_1.is(targetState_1.TargetState);\n\t        // hook returned a TargetState\n\t        if (isTargetState(result)) {\n\t            // Halt the current Transition and start a redirected Transition (to the TargetState).\n\t            return rejectFactory_1.Rejection.redirected(result).toPromise();\n\t        }\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t    };\n\t    /**\n\t     * Run all TransitionHooks, ignoring their return value.\n\t     */\n\t    TransitionHook.runAllHooks = function (hooks) {\n\t        hooks.forEach(function (hook) { return hook.invokeHook(); });\n\t    };\n\t    /**\n\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n\t     *\n\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t     */\n\t    TransitionHook.runOnBeforeHooks = function (hooks) {\n\t        var results = [];\n\t        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n\t            var hook = hooks_1[_i];\n\t            var hookResult = hook.invokeHook();\n\t            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n\t                // Break on first thrown error or false/TargetState\n\t                return hookResult;\n\t            }\n\t            results.push(hookResult);\n\t        }\n\t        return results\n\t            .filter(predicates_1.isPromise)\n\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t    };\n\t    return TransitionHook;\n\t}());\n\tTransitionHook.HANDLE_RESULT = function (hook) {\n\t    return function (result) {\n\t        return hook.handleHookResult(result);\n\t    };\n\t};\n\tTransitionHook.IGNORE_RESULT = function (hook) {\n\t    return function (result) { return undefined; };\n\t};\n\tTransitionHook.LOG_ERROR = function (hook) {\n\t    return function (error) {\n\t        return (hook.stateService().defaultErrorHandler()(error), undefined);\n\t    };\n\t};\n\tTransitionHook.REJECT_ERROR = function (hook) {\n\t    return function (error) {\n\t        return rejectFactory_1.Rejection.errored(error).toPromise();\n\t    };\n\t};\n\tTransitionHook.THROW_ERROR = function (hook) {\n\t    return undefined;\n\t};\n\texports.TransitionHook = TransitionHook;\n\t//# sourceMappingURL=transitionHook.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * Encapsulate the target (destination) state/params/options of a [[Transition]].\n\t *\n\t * This class is frequently used to redirect a transition to a new destination.\n\t *\n\t * See:\n\t *\n\t * - [[HookResult]]\n\t * - [[TransitionHookFn]]\n\t * - [[TransitionService.onStart]]\n\t *\n\t * To create a `TargetState`, use [[StateService.target]].\n\t *\n\t * ---\n\t *\n\t * This class wraps:\n\t *\n\t * 1) an identifier for a state\n\t * 2) a set of parameters\n\t * 3) and transition options\n\t * 4) the registered state object (the [[StateDeclaration]])\n\t *\n\t * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n\t * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n\t * The `TargetState` class normalizes those options.\n\t *\n\t * A `TargetState` may be valid (the state being targeted exists in the registry)\n\t * or invalid (the state being targeted is not registered).\n\t */\n\tvar TargetState = (function () {\n\t    /**\n\t     * The TargetState constructor\n\t     *\n\t     * Note: Do not construct a `TargetState` manually.\n\t     * To create a `TargetState`, use the [[StateService.target]] factory method.\n\t     *\n\t     * @param _identifier An identifier for a state.\n\t     *    Either a fully-qualified state name, or the object used to define the state.\n\t     * @param _definition The internal state representation, if exists.\n\t     * @param _params Parameters for the target state\n\t     * @param _options Transition options.\n\t     *\n\t     * @internalapi\n\t     */\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    /** The name of the state this object targets */\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    /** The identifier used when creating this TargetState */\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    /** The target parameter values */\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    /** The internal state object (if it was found) */\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    /** The internal state declaration (if it was found) */\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    /** The target options */\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /** True if the target state was found */\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    /** True if the object is valid */\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /** If the object is invalid, returns the reason why */\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    TargetState.prototype.toString = function () {\n\t        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n\t    };\n\t    return TargetState;\n\t}());\n\t/** Returns true if the object has a state property that might be a state or state name */\n\tTargetState.isDef = function (obj) {\n\t    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n\t};\n\texports.TargetState = TargetState;\n\t//# sourceMappingURL=targetState.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16); // has or is using\n\tvar glob_1 = __webpack_require__(10);\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t *\n\t * @hidden\n\t *\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = new glob_1.Glob(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\texports.matchState = matchState;\n\t/**\n\t * @internalapi\n\t * The registration data for a registered transition hook\n\t */\n\tvar RegisteredHook = (function () {\n\t    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.tranSvc = tranSvc;\n\t        this.eventType = eventType;\n\t        this.callback = callback;\n\t        this.matchCriteria = matchCriteria;\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t        this._deregistered = false;\n\t    }\n\t    /**\n\t     * Gets the matching [[PathNode]]s\n\t     *\n\t     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n\t     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n\t     *\n\t     * Returning `null` is significant to distinguish between the default\n\t     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n\t     * when the nodes is an empty array.\n\t     *\n\t     * This is useful to allow a transition match criteria of `entering: true`\n\t     * to still match a transition, even when `entering === []`.  Contrast that\n\t     * with `entering: (state) => true` which only matches when a state is actually\n\t     * being entered.\n\t     */\n\t    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Gets the default match criteria (all `true`)\n\t     *\n\t     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n\t     *\n\t     * ```js\n\t     * {\n\t     *   to: true,\n\t     *   from: true,\n\t     *   entering: true,\n\t     *   exiting: true,\n\t     *   retained: true,\n\t     * }\n\t     */\n\t    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n\t        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n\t    };\n\t    /**\n\t     * Gets matching nodes as [[IMatchingNodes]]\n\t     *\n\t     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n\t     *\n\t     * ```js\n\t     * let matches: IMatchingNodes = {\n\t     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n\t     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n\t     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n\t     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n\t     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n\t     * };\n\t     * ```\n\t     */\n\t    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n\t        var _this = this;\n\t        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n\t        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n\t        return paths.reduce(function (mn, pathtype) {\n\t            // STATE scope criteria matches against every node in the path.\n\t            // TRANSITION scope criteria matches against only the last node in the path\n\t            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n\t            var path = treeChanges[pathtype.name] || [];\n\t            var nodes = isStateHook ? path : [common_1.tail(path)];\n\t            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n\t            return mn;\n\t        }, {});\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    RegisteredHook.prototype.matches = function (treeChanges) {\n\t        var matches = this._getMatchingNodes(treeChanges);\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = common_1.values(matches).every(common_1.identity);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return RegisteredHook;\n\t}());\n\texports.RegisteredHook = RegisteredHook;\n\t/** @hidden Return a registration function of the requested type. */\n\tfunction makeEvent(registry, transitionService, eventType) {\n\t    // Create the object which holds the registered transition hooks.\n\t    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n\t    var hooks = _registeredHooks[eventType.name] = [];\n\t    // Create hook registration function on the IHookRegistry for the event\n\t    registry[eventType.name] = hookRegistrationFn;\n\t    function hookRegistrationFn(matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n\t        hooks.push(registeredHook);\n\t        return function deregisterEventHook() {\n\t            registeredHook._deregistered = true;\n\t            common_1.removeFrom(hooks)(registeredHook);\n\t        };\n\t    }\n\t    return hookRegistrationFn;\n\t}\n\texports.makeEvent = makeEvent;\n\t//# sourceMappingURL=hookRegistry.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar interface_1 = __webpack_require__(16);\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder(transition) {\n\t        this.transition = transition;\n\t        this.treeChanges = transition.treeChanges();\n\t        this.transitionOptions = transition.options();\n\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t        this.$transitions = transition.router.transitionService;\n\t        this.baseHookOptions = {\n\t            transition: transition,\n\t            current: transition.options().current\n\t        };\n\t    }\n\t    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n\t        var _this = this;\n\t        return this.$transitions._pluginapi._getEvents(phase)\n\t            .map(function (type) { return _this.buildHooks(type); })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(common_1.identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[PathNode]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     */\n\t    HookBuilder.prototype.buildHooks = function (hookType) {\n\t        var _this = this;\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(_this.treeChanges);\n\t            // Select the PathNode[] that will be used as TransitionHook context objects\n\t            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n\t            // Return an array of HookTuples\n\t            return matchingNodes.map(function (node) {\n\t                var _options = common_1.extend({\n\t                    bind: hook.bind,\n\t                    traceData: { hookType: hookType.name, context: node }\n\t                }, _this.baseHookOptions);\n\t                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n\t                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(common_1.unnestR, [])\n\t            .sort(tupleSort(hookType.reverseSort))\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all RegisteredHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[RegisteredHook]]s\n\t     */\n\t    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n\t        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n\t        // Instance and Global hook registries\n\t        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n\t        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n\t            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\texports.HookBuilder = HookBuilder;\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\t//# sourceMappingURL=hookBuilder.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module path */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar param_1 = __webpack_require__(22);\n\t/**\n\t * A node in a [[TreeChanges]] path\n\t *\n\t * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n\t * Each PathNode corresponds to a state being entered, exited, or retained.\n\t * The stateful information includes parameter values and resolve data.\n\t */\n\tvar PathNode = (function () {\n\t    function PathNode(stateOrPath) {\n\t        if (stateOrPath instanceof PathNode) {\n\t            var node = stateOrPath;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t            this.resolvables = node.resolvables.slice();\n\t            this.views = node.views && node.views.slice();\n\t        }\n\t        else {\n\t            var state = stateOrPath;\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n\t        }\n\t    }\n\t    /** Sets [[paramValues]] for the node, from the values of an object hash */\n\t    PathNode.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    /** Gets a specific [[Param]] metadata that belongs to the node */\n\t    PathNode.prototype.parameter = function (name) {\n\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t    };\n\t    /**\n\t     * @returns true if the state and parameter values for another PathNode are\n\t     * equal to the state and param values for this PathNode\n\t     */\n\t    PathNode.prototype.equals = function (node, keys) {\n\t        var _this = this;\n\t        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n\t        var paramValsEq = function (key) {\n\t            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n\t        };\n\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t    };\n\t    /** Returns a clone of the PathNode */\n\t    PathNode.clone = function (node) {\n\t        return new PathNode(node);\n\t    };\n\t    /**\n\t     * Returns a new path which is a subpath of the first path which matched the second path.\n\t     *\n\t     * The new path starts from root and contains any nodes that match the nodes in the second path.\n\t     * Nodes are compared using their state property and parameter values.\n\t     *\n\t     * @param pathA the first path\n\t     * @param pathB the second path\n\t     * @param ignoreDynamicParams don't compare dynamic parameter values\n\t     */\n\t    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n\t        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n\t        var matching = [];\n\t        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n\t            var a = pathA[i], b = pathB[i];\n\t            if (a.state !== b.state)\n\t                break;\n\t            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n\t                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n\t            if (changedParams.length)\n\t                break;\n\t            matching.push(a);\n\t        }\n\t        return matching;\n\t    };\n\t    return PathNode;\n\t}());\n\texports.PathNode = PathNode;\n\t//# sourceMappingURL=node.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar isShorthand = function (cfg) {\n\t    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n\t};\n\tvar DefType;\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(DefType = exports.DefType || (exports.DefType = {}));\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    return common_1.extend(cfg, {\n\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t    });\n\t}\n\tfunction getType(cfg, urlType, location, id, paramTypes) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n\t        return paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type) {\n\t        var type = location === DefType.CONFIG ? \"any\" :\n\t            location === DefType.PATH ? \"path\" :\n\t                location === DefType.SEARCH ? \"query\" : \"string\";\n\t        return paramTypes.type(type);\n\t    }\n\t    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t        return defaultPolicy;\n\t    if (squash === true || predicates_1.isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t    ];\n\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t    if (predicates_1.isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\tvar Param = (function () {\n\t    function Param(id, type, config, location, urlMatcherFactory) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n\t        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n\t        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n\t        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var $$getDefaultValue = function () {\n\t            if (!coreservices_1.services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n\t            return defaultValue;\n\t        };\n\t        var $replace = function (val) {\n\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t            return replacement.length ? replacement[0] : val;\n\t        };\n\t        value = $replace(value);\n\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    Param.values = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\texports.Param = Param;\n\t//# sourceMappingURL=param.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\t/**\n\t * An internal class which implements [[ParamTypeDefinition]].\n\t *\n\t * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n\t * When a param type definition is registered, an instance of this class is created internally.\n\t *\n\t * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n\t *\n\t * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n\t *\n\t * #### Example:\n\t * ```js\n\t * var paramTypeDef = {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t *\n\t * var paramType = new ParamType(paramTypeDef);\n\t * ```\n\t * @internalapi\n\t */\n\tvar ParamType = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n\t     * @returns a new ParamType object\n\t     */\n\t    function ParamType(def) {\n\t        /** @inheritdoc */\n\t        this.pattern = /.*/;\n\t        /** @inheritdoc */\n\t        this.inherit = true;\n\t        common_1.extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    ParamType.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    ParamType.prototype.equals = function (a, b) { return a == b; };\n\t    ParamType.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    ParamType.prototype.toString = function () {\n\t        return \"{ParamType:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    ParamType.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    ParamType.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t/**\n\t * Wraps up a `ParamType` object to handle array values.\n\t * @internalapi\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) {\n\t        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n\t    }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (predicates_1.isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = common_1.map(arr, callback);\n\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n\t        var paramTypeFn = type[name].bind(type);\n\t        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n\t        _this[name] = wrapperFn(paramTypeFn);\n\t    });\n\t    common_1.extend(this, {\n\t        dynamic: type.dynamic,\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        inherit: type.inherit,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t//# sourceMappingURL=paramType.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module path */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar node_1 = __webpack_require__(21);\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathFactory = (function () {\n\t    function PathFactory() {\n\t    }\n\t    /** Given a PathNode[], create an TargetState */\n\t    PathFactory.makeTargetState = function (path) {\n\t        var state = common_1.tail(path).state;\n\t        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    PathFactory.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathFactory.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    /**\n\t     * Creates ViewConfig objects and adds to nodes.\n\t     *\n\t     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n\t     */\n\t    PathFactory.applyViewConfigs = function ($view, path, states) {\n\t        // Only apply the viewConfigs to the nodes for the given states\n\t        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n\t            var viewDecls = common_1.values(node.state.views || {});\n\t            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n\t            node.views = viewConfigs.reduce(common_1.unnestR, []);\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t            return common_1.extend({}, node && node.paramValues);\n\t        }\n\t        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (param) { return !param.inherit; })\n\t            .map(hof_1.prop('id'));\n\t        /**\n\t         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        function makeInheritedParamsNode(toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n\t            toParamVals = common_1.omit(toParamVals, toKeys);\n\t            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n\t        }\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode);\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var staticParams = function (state) {\n\t            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n\t        };\n\t        var nodesMatch = function (node1, node2) {\n\t            return node1.equals(node2, staticParams(node1.state));\n\t        };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = node_1.PathNode.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        var retainedWithToParams = retained.map(applyToParams);\n\t        entering = toPath.slice(keep);\n\t        to = (retainedWithToParams).concat(entering);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    /**\n\t     * Return a subpath of a path, which stops at the first matching node\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node,\n\t     * stopping when the first node matches the predicate.\n\t     *\n\t     * @param path a path of [[PathNode]]s\n\t     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n\t     * @returns a subpath up to the matching node, or undefined if no match is found\n\t     */\n\t    PathFactory.subPath = function (path, predicate) {\n\t        var node = common_1.find(path, predicate);\n\t        var elementIdx = path.indexOf(node);\n\t        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n\t    };\n\t    return PathFactory;\n\t}());\n\t/** Gets the raw parameter values from a path */\n\tPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\texports.PathFactory = PathFactory;\n\t//# sourceMappingURL=pathFactory.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module resolve\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar trace_1 = __webpack_require__(15);\n\tvar strings_1 = __webpack_require__(12);\n\tvar predicates_1 = __webpack_require__(7);\n\t// TODO: explicitly make this user configurable\n\texports.defaultResolvePolicy = {\n\t    when: \"LAZY\",\n\t    async: \"WAIT\"\n\t};\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(arg1, resolveFn, deps, policy, data) {\n\t        this.resolved = false;\n\t        this.promise = undefined;\n\t        if (arg1 instanceof Resolvable) {\n\t            common_1.extend(this, arg1);\n\t        }\n\t        else if (predicates_1.isFunction(resolveFn)) {\n\t            if (arg1 == null || arg1 == undefined)\n\t                throw new Error(\"new Resolvable(): token argument is required\");\n\t            if (!predicates_1.isFunction(resolveFn))\n\t                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n\t            this.token = arg1;\n\t            this.policy = policy;\n\t            this.resolveFn = resolveFn;\n\t            this.deps = deps || [];\n\t            this.data = data;\n\t            this.resolved = data !== undefined;\n\t            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n\t        }\n\t        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n\t            var literal = arg1;\n\t            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n\t        }\n\t    }\n\t    Resolvable.prototype.getPolicy = function (state) {\n\t        var thisPolicy = this.policy || {};\n\t        var statePolicy = state && state.resolvePolicy || {};\n\t        return {\n\t            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n\t            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n\t        };\n\t    };\n\t    /**\n\t     * Asynchronously resolve this Resolvable's data\n\t     *\n\t     * Given a ResolveContext that this Resolvable is found in:\n\t     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n\t     * and update the Resolvable's state\n\t     */\n\t    Resolvable.prototype.resolve = function (resolveContext, trans) {\n\t        var _this = this;\n\t        var $q = coreservices_1.services.$q;\n\t        // Gets all dependencies from ResolveContext and wait for them to be resolved\n\t        var getResolvableDependencies = function () {\n\t            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n\t                return r.get(resolveContext, trans);\n\t            }));\n\t        };\n\t        // Invokes the resolve function passing the resolved dependencies as arguments\n\t        var invokeResolveFn = function (resolvedDeps) {\n\t            return _this.resolveFn.apply(null, resolvedDeps);\n\t        };\n\t        /**\n\t         * For RXWAIT policy:\n\t         *\n\t         * Given an observable returned from a resolve function:\n\t         * - enables .cache() mode (this allows multicast subscribers)\n\t         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n\t         * - Waits for the promise, then return the cached observable (not the first emitted value).\n\t         */\n\t        var waitForRx = function (observable$) {\n\t            var cached = observable$.cache(1);\n\t            return cached.take(1).toPromise().then(function () { return cached; });\n\t        };\n\t        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n\t        var node = resolveContext.findNode(this);\n\t        var state = node && node.state;\n\t        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n\t        // After the final value has been resolved, update the state of the Resolvable\n\t        var applyResolvedValue = function (resolvedValue) {\n\t            _this.data = resolvedValue;\n\t            _this.resolved = true;\n\t            trace_1.trace.traceResolvableResolved(_this, trans);\n\t            return _this.data;\n\t        };\n\t        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n\t        return this.promise = $q.when()\n\t            .then(getResolvableDependencies)\n\t            .then(invokeResolveFn)\n\t            .then(maybeWaitForRx)\n\t            .then(applyResolvedValue);\n\t    };\n\t    /**\n\t     * Gets a promise for this Resolvable's data.\n\t     *\n\t     * Fetches the data and returns a promise.\n\t     * Returns the existing promise if it has already been fetched once.\n\t     */\n\t    Resolvable.prototype.get = function (resolveContext, trans) {\n\t        return this.promise || this.resolve(resolveContext, trans);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n\t    };\n\t    Resolvable.prototype.clone = function () {\n\t        return new Resolvable(this);\n\t    };\n\t    return Resolvable;\n\t}());\n\tResolvable.fromData = function (token, data) {\n\t    return new Resolvable(token, function () { return data; }, null, null, data);\n\t};\n\texports.Resolvable = Resolvable;\n\t//# sourceMappingURL=resolvable.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar trace_1 = __webpack_require__(15);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar interface_1 = __webpack_require__(27);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar strings_1 = __webpack_require__(12);\n\tvar when = interface_1.resolvePolicies.when;\n\tvar ALL_WHENS = [when.EAGER, when.LAZY];\n\tvar EAGER_WHENS = [when.EAGER];\n\texports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n\t/**\n\t * Encapsulates Depenency Injection for a path of nodes\n\t *\n\t * UI-Router states are organized as a tree.\n\t * A nested state has a path of ancestors to the root of the tree.\n\t * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n\t * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n\t *\n\t * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n\t */\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t    }\n\t    /** Gets all the tokens found in the resolve context, de-duplicated */\n\t    ResolveContext.prototype.getTokens = function () {\n\t        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n\t    };\n\t    /**\n\t     * Gets the Resolvable that matches the token\n\t     *\n\t     * Gets the last Resolvable that matches the token in this context, or undefined.\n\t     * Throws an error if it doesn't exist in the ResolveContext\n\t     */\n\t    ResolveContext.prototype.getResolvable = function (token) {\n\t        var matching = this._path.map(function (node) { return node.resolvables; })\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (r) { return r.token === token; });\n\t        return common_1.tail(matching);\n\t    };\n\t    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n\t    ResolveContext.prototype.getPolicy = function (resolvable) {\n\t        var node = this.findNode(resolvable);\n\t        return resolvable.getPolicy(node.state);\n\t    };\n\t    /**\n\t     * Returns a ResolveContext that includes a portion of this one\n\t     *\n\t     * Given a state, this method creates a new ResolveContext from this one.\n\t     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n\t     *\n\t     * #### Why\n\t     *\n\t     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n\t     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n\t     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n\t     * This method is used to create a narrower context when injecting ancestor nodes.\n\t     *\n\t     * @example\n\t     * `let ABCD = new ResolveContext([A, B, C, D]);`\n\t     *\n\t     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n\t     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n\t     * However, `B` should only be able to access resolvables from `A`, `B`.\n\t     *\n\t     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n\t     * `let AB = ABCD.subcontext(a)`\n\t     */\n\t    ResolveContext.prototype.subContext = function (state) {\n\t        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n\t    };\n\t    /**\n\t     * Adds Resolvables to the node that matches the state\n\t     *\n\t     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n\t     * The resolvable is added to the node matching the `state` parameter.\n\t     *\n\t     * These new resolvables are not automatically fetched.\n\t     * The calling code should either fetch them, fetch something that depends on them,\n\t     * or rely on [[resolvePath]] being called when some state is being entered.\n\t     *\n\t     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n\t     *\n\t     * @param newResolvables the new Resolvables\n\t     * @param state Used to find the node to put the resolvable on\n\t     */\n\t    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n\t        var node = common_1.find(this._path, hof_1.propEq('state', state));\n\t        var keys = newResolvables.map(function (r) { return r.token; });\n\t        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n\t    };\n\t    /**\n\t     * Returns a promise for an array of resolved path Element promises\n\t     *\n\t     * @param when\n\t     * @param trans\n\t     * @returns {Promise<any>|any}\n\t     */\n\t    ResolveContext.prototype.resolvePath = function (when, trans) {\n\t        var _this = this;\n\t        if (when === void 0) { when = \"LAZY\"; }\n\t        // This option determines which 'when' policy Resolvables we are about to fetch.\n\t        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n\t        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n\t        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n\t        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\t        // get the subpath to the state argument, if provided\n\t        trace_1.trace.traceResolvePath(this._path, when, trans);\n\t        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n\t            return function (resolvable) {\n\t                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n\t            };\n\t        };\n\t        // Trigger all the (matching) Resolvables in the path\n\t        // Reduce all the \"WAIT\" Resolvables into an array\n\t        var promises = this._path.reduce(function (acc, node) {\n\t            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n\t            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n\t            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n\t            // For the matching Resolvables, start their async fetch process.\n\t            var subContext = _this.subContext(node.state);\n\t            var getResult = function (r) { return r.get(subContext, trans)\n\t                .then(function (value) { return ({ token: r.token, value: value }); }); };\n\t            nowait.forEach(getResult);\n\t            return acc.concat(wait.map(getResult));\n\t        }, []);\n\t        // Wait for all the \"WAIT\" resolvables\n\t        return coreservices_1.services.$q.all(promises);\n\t    };\n\t    ResolveContext.prototype.injector = function () {\n\t        return this._injector || (this._injector = new UIInjectorImpl(this));\n\t    };\n\t    ResolveContext.prototype.findNode = function (resolvable) {\n\t        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n\t    };\n\t    /**\n\t     * Gets the async dependencies of a Resolvable\n\t     *\n\t     * Given a Resolvable, returns its dependencies as a Resolvable[]\n\t     */\n\t    ResolveContext.prototype.getDependencies = function (resolvable) {\n\t        var _this = this;\n\t        var node = this.findNode(resolvable);\n\t        // Find which other resolvables are \"visible\" to the `resolvable` argument\n\t        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n\t        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n\t        var availableResolvables = subPath\n\t            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n\t            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n\t        var getDependency = function (token) {\n\t            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n\t            if (matching.length)\n\t                return common_1.tail(matching);\n\t            var fromInjector = _this.injector().getNative(token);\n\t            if (!fromInjector) {\n\t                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n\t            }\n\t            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n\t        };\n\t        return resolvable.deps.map(getDependency);\n\t    };\n\t    return ResolveContext;\n\t}());\n\texports.ResolveContext = ResolveContext;\n\tvar UIInjectorImpl = (function () {\n\t    function UIInjectorImpl(context) {\n\t        this.context = context;\n\t        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n\t    }\n\t    UIInjectorImpl.prototype.get = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable) {\n\t            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n\t                return resolvable.get(this.context);\n\t            }\n\t            if (!resolvable.resolved) {\n\t                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n\t            }\n\t            return resolvable.data;\n\t        }\n\t        return this.native && this.native.get(token);\n\t    };\n\t    UIInjectorImpl.prototype.getAsync = function (token) {\n\t        var resolvable = this.context.getResolvable(token);\n\t        if (resolvable)\n\t            return resolvable.get(this.context);\n\t        return coreservices_1.services.$q.when(this.native.get(token));\n\t    };\n\t    UIInjectorImpl.prototype.getNative = function (token) {\n\t        return this.native && this.native.get(token);\n\t    };\n\t    return UIInjectorImpl;\n\t}());\n\t//# sourceMappingURL=resolveContext.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/** @internalapi */\n\texports.resolvePolicies = {\n\t    when: {\n\t        LAZY: \"LAZY\",\n\t        EAGER: \"EAGER\"\n\t    },\n\t    async: {\n\t        WAIT: \"WAIT\",\n\t        NOWAIT: \"NOWAIT\",\n\t        RXWAIT: \"RXWAIT\"\n\t    }\n\t};\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar urlMatcherFactory_1 = __webpack_require__(29);\n\tvar urlRouter_1 = __webpack_require__(32);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar view_1 = __webpack_require__(43);\n\tvar stateRegistry_1 = __webpack_require__(44);\n\tvar stateService_1 = __webpack_require__(48);\n\tvar globals_1 = __webpack_require__(49);\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlService_1 = __webpack_require__(51);\n\tvar trace_1 = __webpack_require__(15);\n\t/** @hidden */\n\tvar _routerInstance = 0;\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n\t * This class instantiates and wires the UI-Router services together.\n\t *\n\t * After a new instance of the UIRouter class is created, it should be configured for your app.\n\t * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n\t *\n\t * ---\n\t *\n\t * Normally the framework code will bootstrap UI-Router.\n\t * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n\t * [[UrlService.listen]] then [[UrlService.sync]].\n\t */\n\tvar UIRouter = (function () {\n\t    /**\n\t     * Creates a new `UIRouter` object\n\t     *\n\t     * @param locationService a [[LocationServices]] implementation\n\t     * @param locationConfig a [[LocationConfig]] implementation\n\t     * @internalapi\n\t     */\n\t    function UIRouter(locationService, locationConfig) {\n\t        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n\t        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n\t        this.locationService = locationService;\n\t        this.locationConfig = locationConfig;\n\t        /** @hidden */\n\t        this.$id = _routerInstance++;\n\t        /** Provides trace information to the console */\n\t        this.trace = trace_1.trace;\n\t        /** Provides services related to ui-view synchronization */\n\t        this.viewService = new view_1.ViewService();\n\t        /** Provides services related to Transitions */\n\t        this.transitionService = new transitionService_1.TransitionService(this);\n\t        /** Global router state */\n\t        this.globals = new globals_1.Globals(this.transitionService);\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t        /**\n\t         * Deprecated for public use. Use [[urlService]] instead.\n\t         * @deprecated\n\t         */\n\t        this.urlRouter = new urlRouter_1.UrlRouter(this);\n\t        /** Provides a registry for states, and related registration services */\n\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n\t        /** Provides services related to states */\n\t        this.stateService = new stateService_1.StateService(this);\n\t        /** Provides services related to the URL */\n\t        this.urlService = new urlService_1.UrlService(this);\n\t        /** @hidden */\n\t        this._disposables = [];\n\t        /** @hidden */\n\t        this._plugins = {};\n\t        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t        this.disposable(this.transitionService);\n\t        this.disposable(this.urlRouter);\n\t        this.disposable(this.stateRegistry);\n\t        this.disposable(locationService);\n\t        this.disposable(locationConfig);\n\t    }\n\t    /** Registers an object to be notified when the router is disposed */\n\t    UIRouter.prototype.disposable = function (disposable) {\n\t        this._disposables.push(disposable);\n\t    };\n\t    /**\n\t     * Disposes this router instance\n\t     *\n\t     * When called, clears resources retained by the router by calling `dispose(this)` on all\n\t     * registered [[disposable]] objects.\n\t     *\n\t     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n\t     *\n\t     * @param disposable (optional) the disposable to dispose\n\t     */\n\t    UIRouter.prototype.dispose = function (disposable) {\n\t        var _this = this;\n\t        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n\t            disposable.dispose(this);\n\t            return undefined;\n\t        }\n\t        this._disposables.slice().forEach(function (d) {\n\t            try {\n\t                typeof d.dispose === 'function' && d.dispose(_this);\n\t                common_1.removeFrom(_this._disposables, d);\n\t            }\n\t            catch (ignored) { }\n\t        });\n\t    };\n\t    /**\n\t     * Adds a plugin to UI-Router\n\t     *\n\t     * This method adds a UI-Router Plugin.\n\t     * A plugin can enhance or change UI-Router behavior using any public API.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n\t     *\n\t     * var plugin = router.addPlugin(MyCoolPlugin);\n\t     * ```\n\t     *\n\t     * ### Plugin authoring\n\t     *\n\t     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n\t     *\n\t     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n\t     * For example, it may configure router options or add a Transition Hook.\n\t     *\n\t     * The plugin can then be published as a separate module.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * export class MyAuthPlugin implements UIRouterPlugin {\n\t     *   constructor(router: UIRouter, options: any) {\n\t     *     this.name = \"MyAuthPlugin\";\n\t     *     let $transitions = router.transitionService;\n\t     *     let $state = router.stateService;\n\t     *\n\t     *     let authCriteria = {\n\t     *       to: (state) => state.data && state.data.requiresAuth\n\t     *     };\n\t     *\n\t     *     function authHook(transition: Transition) {\n\t     *       let authService = transition.injector().get('AuthService');\n\t     *       if (!authService.isAuthenticated()) {\n\t     *         return $state.target('login');\n\t     *       }\n\t     *     }\n\t     *\n\t     *     $transitions.onStart(authCriteria, authHook);\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @param plugin one of:\n\t     *        - a plugin class which implements [[UIRouterPlugin]]\n\t     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n\t     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n\t     * @param options options to pass to the plugin class/factory\n\t     * @returns the registered plugin instance\n\t     */\n\t    UIRouter.prototype.plugin = function (plugin, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var pluginInstance = new plugin(this, options);\n\t        if (!pluginInstance.name)\n\t            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n\t        this._disposables.push(pluginInstance);\n\t        return this._plugins[pluginInstance.name] = pluginInstance;\n\t    };\n\t    UIRouter.prototype.getPlugin = function (pluginName) {\n\t        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n\t    };\n\t    return UIRouter;\n\t}());\n\texports.UIRouter = UIRouter;\n\t//# sourceMappingURL=router.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar param_1 = __webpack_require__(22);\n\tvar paramTypes_1 = __webpack_require__(31);\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        var _this = this;\n\t        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n\t        /** @hidden */ this._isCaseInsensitive = false;\n\t        /** @hidden */ this._isStrictMode = true;\n\t        /** @hidden */ this._defaultSquashPolicy = false;\n\t        /** @hidden */\n\t        this._getConfig = function (config) {\n\t            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n\t        };\n\t        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n\t        this.paramFactory = {\n\t            /** Creates a new [[Param]] from a CONFIG block */\n\t            fromConfig: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url PATH */\n\t            fromPath: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n\t            },\n\t            /** Creates a new [[Param]] from a url SEARCH */\n\t            fromSearch: function (id, type, config) {\n\t                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n\t            },\n\t        };\n\t        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n\t    }\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!predicates_1.isObject(object))\n\t            return false;\n\t        var result = true;\n\t        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n\t            if (predicates_1.isFunction(val))\n\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    ;\n\t    /**\n\t     * Creates and registers a custom [[ParamType]] object\n\t     *\n\t     * A [[ParamType]] can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app runtime starts.\n\t     *        The result of this function should be a [[ParamTypeDefinition]].\n\t     *        The result is merged into the existing `definition`.\n\t     *        See [[ParamType]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n\t     *\n\t     * Note: Register custom types *before using them* in a state definition.\n\t     *\n\t     * See [[ParamTypeDefinition]] for examples\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = this.paramTypes.type(name, definition, definitionFn);\n\t        return !predicates_1.isDefined(definition) ? type : this;\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        this.paramTypes.enqueue = false;\n\t        this.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    ;\n\t    /** @internalapi */\n\t    UrlMatcherFactory.prototype.dispose = function () {\n\t        this.paramTypes.dispose();\n\t    };\n\t    return UrlMatcherFactory;\n\t}());\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\t//# sourceMappingURL=urlMatcherFactory.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar param_1 = __webpack_require__(22);\n\tvar strings_1 = __webpack_require__(12);\n\t/** @hidden */\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\t/** @hidden */\n\tvar memoizeTo = function (obj, prop, fn) {\n\t    return obj[prop] = obj[prop] || fn();\n\t};\n\t/**\n\t * Matches URLs against patterns.\n\t *\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL.\n\t *\n\t * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n\t * parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by [[UrlMatcher.exec]].\n\t *\n\t * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n\t * or colon placeholders (`/somePath/:param`).\n\t *\n\t * - *A parameter RegExp* may be defined for a param after a colon\n\t * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n\t * The regexp must match for the url to be matched.\n\t * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n\t *\n\t * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n\t *   See [[UrlMatcherFactory.type]] for more information.\n\t *\n\t * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n\t *   A catch-all * parameter value will contain the remainder of the URL.\n\t *\n\t * ---\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters).\n\t * A path parameter matches any number of characters other than '/'. For catch-all\n\t * placeholders the path parameter matches any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t */\n\tvar UrlMatcher = (function () {\n\t    /**\n\t     * @param pattern The pattern to compile into a matcher.\n\t     * @param paramTypes The [[ParamTypes]] registry\n\t     * @param config  A configuration object\n\t     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t     */\n\t    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n\t        var _this = this;\n\t        this.config = config;\n\t        /** @hidden */\n\t        this._cache = { path: [this], parent: null, pattern: null };\n\t        /** @hidden */\n\t        this._children = [];\n\t        /** @hidden */\n\t        this._params = [];\n\t        /** @hidden */\n\t        this._segments = [];\n\t        /** @hidden */\n\t        this._compiled = [];\n\t        this.pattern = pattern;\n\t        this.config = common_1.defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: common_1.identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3];\n\t            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n\t                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t            }); };\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern.substring(last, m.index),\n\t                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n\t    }\n\t    /**\n\t     * Creates a new concatenated UrlMatcher\n\t     *\n\t     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n\t     *\n\t     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        url._cache = {\n\t            path: this._cache.path.concat(url),\n\t            parent: this,\n\t            pattern: null,\n\t        };\n\t        return url;\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path[0] === this;\n\t    };\n\t    /** Returns the input pattern string */\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * Tests the specified url/path against this matcher.\n\t     *\n\t     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n\t     * parameter values.  Returns null if the path does not match.\n\t     *\n\t     * The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * ```\n\t     *\n\t     * @param path    The URL path to match, e.g. `$location.path()`.\n\t     * @param search  URL search parameters, e.g. `$location.search()`.\n\t     * @param hash    URL hash e.g. `$location.hash()`.\n\t     * @param options\n\t     *\n\t     * @returns The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = common_1.map(split, reverseString);\n\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        }\n\t        searchParams.forEach(function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (predicates_1.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values[\"#\"] = hash;\n\t        return values;\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n\t    };\n\t    /**\n\t     * @hidden\n\t     * Returns a single parameter from this UrlMatcher by id\n\t     *\n\t     * @param id\n\t     * @param opts\n\t     * @returns {T|Param|any|boolean|UrlMatcher|null}\n\t     */\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var parent = this._cache.parent;\n\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n\t            null);\n\t    };\n\t    /**\n\t     * Validates the input parameter values against this UrlMatcher\n\t     *\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param params The object hash of parameters to validate.\n\t     * @returns Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var _this = this;\n\t        var validParamVal = function (param, val) {\n\t            return !param || param.validates(val);\n\t        };\n\t        return common_1.pairs(params || {}).map(function (_a) {\n\t            var key = _a[0], val = _a[1];\n\t            return validParamVal(_this.parameter(key), val);\n\t        }).reduce(common_1.allTrueR, true);\n\t    };\n\t    /**\n\t     * Given a set of parameter values, creates a URL from this UrlMatcher.\n\t     *\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * ```\n\t     *\n\t     * @param values  the values to substitute for the parameters in this pattern.\n\t     * @returns the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values) {\n\t        if (values === void 0) { values = {}; }\n\t        if (!this.validates(values))\n\t            return null;\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path;\n\t        // Extract all the static segments and Params into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n\t        /**\n\t         * Given a Param,\n\t         * Applies the parameter value, then returns details about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values[param.id]);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (predicates_1.isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (predicates_1.isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (predicates_1.isArray(encoded))\n\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (param) {\n\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!predicates_1.isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.raw)\n\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val) { return param.id + \"=\" + val; });\n\t        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t    };\n\t    /** @hidden */\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n\t            .reduce(common_1.unnestR, [])\n\t            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n\t    };\n\t    /** @hidden Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t    };\n\t    /**\n\t     * Compare two UrlMatchers\n\t     *\n\t     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n\t     * Each static path segment is a static string between a path separator (slash character).\n\t     * Each dynamic segment is a path parameter.\n\t     *\n\t     * The comparison function sorts static segments before dynamic ones.\n\t     */\n\t    UrlMatcher.compare = function (a, b) {\n\t        var splitOnSlash = strings_1.splitOnDelim('/');\n\t        /**\n\t         * Turn a UrlMatcher and all its parent matchers into an array\n\t         * of slash literals '/', string literals, and Param objects\n\t         *\n\t         * This example matcher matches strings like \"/foo/:param/tail\":\n\t         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n\t         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n\t         *\n\t         */\n\t        var segments = function (matcher) {\n\t            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n\t                .reduce(common_1.unnestR, [])\n\t                .reduce(strings_1.joinNeighborsR, [])\n\t                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n\t                .reduce(common_1.unnestR, []);\n\t        };\n\t        var aSegments = segments(a), bSegments = segments(b);\n\t        // console.table( { aSegments, bSegments });\n\t        // Sort slashes first, then static strings, the Params\n\t        var weight = hof_1.pattern([\n\t            [hof_1.eq(\"/\"), hof_1.val(1)],\n\t            [predicates_1.isString, hof_1.val(2)],\n\t            [hof_1.is(param_1.Param), hof_1.val(3)]\n\t        ]);\n\t        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n\t        // console.table(pairs);\n\t        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n\t    };\n\t    return UrlMatcher;\n\t}());\n\t/** @hidden */\n\tUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\texports.UrlMatcher = UrlMatcher;\n\t//# sourceMappingURL=urlMatcher.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module params\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar hof_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar paramType_1 = __webpack_require__(23);\n\t/**\n\t * A registry for parameter types.\n\t *\n\t * This registry manages the built-in (and custom) parameter types.\n\t *\n\t * The built-in parameter types are:\n\t *\n\t * - [[string]]\n\t * - [[path]]\n\t * - [[query]]\n\t * - [[hash]]\n\t * - [[int]]\n\t * - [[bool]]\n\t * - [[date]]\n\t * - [[json]]\n\t * - [[any]]\n\t */\n\tvar ParamTypes = (function () {\n\t    /** @internalapi */\n\t    function ParamTypes() {\n\t        /** @hidden */\n\t        this.enqueue = true;\n\t        /** @hidden */\n\t        this.typeQueue = [];\n\t        /** @internalapi */\n\t        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) {\n\t            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        };\n\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t    }\n\t    /** @internalapi */\n\t    ParamTypes.prototype.dispose = function () {\n\t        this.types = {};\n\t    };\n\t    /**\n\t     * Registers a parameter type\n\t     *\n\t     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n\t     */\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!predicates_1.isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    /** @internalapi */\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\texports.ParamTypes = ParamTypes;\n\t/** @hidden */\n\tfunction initDefaultTypes() {\n\t    var makeDefaultType = function (def) {\n\t        var valToString = function (val) {\n\t            return val != null ? val.toString() : val;\n\t        };\n\t        var defaultTypeBase = {\n\t            encode: valToString,\n\t            decode: valToString,\n\t            is: hof_1.is(String),\n\t            pattern: /.*/,\n\t            equals: function (a, b) { return a == b; },\n\t        };\n\t        return common_1.extend({}, defaultTypeBase, def);\n\t    };\n\t    // Default Parameter Type Definitions\n\t    common_1.extend(ParamTypes.prototype, {\n\t        string: makeDefaultType({}),\n\t        path: makeDefaultType({\n\t            pattern: /[^/]*/,\n\t        }),\n\t        query: makeDefaultType({}),\n\t        hash: makeDefaultType({\n\t            inherit: false,\n\t        }),\n\t        int: makeDefaultType({\n\t            decode: function (val) { return parseInt(val, 10); },\n\t            is: function (val) {\n\t                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n\t            },\n\t            pattern: /-?\\d+/,\n\t        }),\n\t        bool: makeDefaultType({\n\t            encode: function (val) { return val && 1 || 0; },\n\t            decode: function (val) { return parseInt(val, 10) !== 0; },\n\t            is: hof_1.is(Boolean),\n\t            pattern: /0|1/\n\t        }),\n\t        date: makeDefaultType({\n\t            encode: function (val) {\n\t                return !this.is(val) ? undefined : [\n\t                    val.getFullYear(),\n\t                    ('0' + (val.getMonth() + 1)).slice(-2),\n\t                    ('0' + val.getDate()).slice(-2)\n\t                ].join(\"-\");\n\t            },\n\t            decode: function (val) {\n\t                if (this.is(val))\n\t                    return val;\n\t                var match = this.capture.exec(val);\n\t                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t            },\n\t            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t            equals: function (l, r) {\n\t                return ['getFullYear', 'getMonth', 'getDate']\n\t                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t            },\n\t            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t        }),\n\t        json: makeDefaultType({\n\t            encode: common_1.toJson,\n\t            decode: common_1.fromJson,\n\t            is: hof_1.is(Object),\n\t            equals: common_1.equals,\n\t            pattern: /[^/]*/\n\t        }),\n\t        // does not encode/decode\n\t        any: makeDefaultType({\n\t            encode: common_1.identity,\n\t            decode: common_1.identity,\n\t            is: function () { return true; },\n\t            equals: common_1.equals,\n\t        }),\n\t    });\n\t}\n\tinitDefaultTypes();\n\t//# sourceMappingURL=paramTypes.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module url\n\t */\n\t/** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar hof_1 = __webpack_require__(8);\n\tvar urlRule_1 = __webpack_require__(33);\n\tvar targetState_1 = __webpack_require__(18);\n\t/** @hidden */\n\tfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t/** @hidden */\n\tvar getMatcher = hof_1.prop(\"urlMatcher\");\n\t/**\n\t * Default rule priority sorting function.\n\t *\n\t * Sorts rules by:\n\t *\n\t * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n\t * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n\t * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n\t * - Registration order (for rule types other than STATE and URLMATCHER)\n\t *\n\t * @coreapi\n\t */\n\tvar defaultRuleSortFn;\n\tdefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n\t/**\n\t * Updates URL and responds to URL changes\n\t *\n\t * ### Deprecation warning:\n\t * This class is now considered to be an internal API\n\t * Use the [[UrlService]] instead.\n\t * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n\t *\n\t * This class updates the URL when the state changes.\n\t * It also responds to changes in the URL.\n\t */\n\tvar UrlRouter = (function () {\n\t    /** @hidden */\n\t    function UrlRouter(router) {\n\t        /** @hidden */ this._sortFn = defaultRuleSortFn;\n\t        /** @hidden */ this._rules = [];\n\t        /** @hidden */ this.interceptDeferred = false;\n\t        /** @hidden */ this._id = 0;\n\t        this._router = router;\n\t        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n\t        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n\t    }\n\t    /** @internalapi */\n\t    UrlRouter.prototype.dispose = function () {\n\t        this.listen(false);\n\t        this._rules = [];\n\t        delete this._otherwiseFn;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sort = function (compareFn) {\n\t        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n\t    };\n\t    /**\n\t     * Given a URL, check all rules and return the best [[MatchResult]]\n\t     * @param url\n\t     * @returns {MatchResult}\n\t     */\n\t    UrlRouter.prototype.match = function (url) {\n\t        var _this = this;\n\t        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n\t        var rules = this.rules();\n\t        if (this._otherwiseFn)\n\t            rules.push(this._otherwiseFn);\n\t        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n\t        var checkRule = function (rule) {\n\t            var match = rule.match(url, _this._router);\n\t            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n\t        };\n\t        // The rules are pre-sorted.\n\t        // - Find the first matching rule.\n\t        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n\t        // - Choose the rule with the highest match weight.\n\t        var best;\n\t        for (var i = 0; i < rules.length; i++) {\n\t            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n\t            if (best && this._sortFn(rules[i], best.rule) !== 0)\n\t                break;\n\t            var current = checkRule(rules[i]);\n\t            // Pick the best MatchResult\n\t            best = (!best || current && current.weight > best.weight) ? current : best;\n\t        }\n\t        return best;\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.sync = function (evt) {\n\t        if (evt && evt.defaultPrevented)\n\t            return;\n\t        var router = this._router, $url = router.urlService, $state = router.stateService;\n\t        var url = {\n\t            path: $url.path(), search: $url.search(), hash: $url.hash()\n\t        };\n\t        var best = this.match(url);\n\t        var applyResult = hof_1.pattern([\n\t            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n\t            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n\t            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n\t        ]);\n\t        applyResult(best && best.rule.handler(best.match, url, router));\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.listen = function (enabled) {\n\t        var _this = this;\n\t        if (enabled === false) {\n\t            this._stopFn && this._stopFn();\n\t            delete this._stopFn;\n\t        }\n\t        else {\n\t            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n\t        }\n\t    };\n\t    /**\n\t     * Internal API.\n\t     * @internalapi\n\t     */\n\t    UrlRouter.prototype.update = function (read) {\n\t        var $url = this._router.locationService;\n\t        if (read) {\n\t            this.location = $url.path();\n\t            return;\n\t        }\n\t        if ($url.path() === this.location)\n\t            return;\n\t        $url.url(this.location, true);\n\t    };\n\t    /**\n\t     * Internal API.\n\t     *\n\t     * Pushes a new location to the browser history.\n\t     *\n\t     * @internalapi\n\t     * @param urlMatcher\n\t     * @param params\n\t     * @param options\n\t     */\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        var replace = options && !!options.replace;\n\t        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n\t    };\n\t    /**\n\t     * Builds and returns a URL with interpolated parameters\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * matcher = $umf.compile(\"/about/:person\");\n\t     * params = { person: \"bob\" };\n\t     * $bob = $urlRouter.href(matcher, params);\n\t     * // $bob == \"/about/bob\";\n\t     * ```\n\t     *\n\t     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n\t     * @param params An object of parameter values to fill the matcher's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params))\n\t            return null;\n\t        var url = urlMatcher.format(params);\n\t        options = options || { absolute: false };\n\t        var cfg = this._router.urlService.config;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    /**\n\t     * Manually adds a URL Rule.\n\t     *\n\t     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n\t     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n\t     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n\t     *\n\t     * A rule should have a `match` function which returns truthy if the rule matched.\n\t     * It should also have a `handler` function which is invoked if the rule is the best match.\n\t     *\n\t     * @return a function that deregisters the rule\n\t     */\n\t    UrlRouter.prototype.rule = function (rule) {\n\t        var _this = this;\n\t        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n\t            throw new Error(\"invalid rule\");\n\t        rule.$id = this._id++;\n\t        rule.priority = rule.priority || 0;\n\t        this._rules.push(rule);\n\t        this.sort();\n\t        return function () { return _this.removeRule(rule); };\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.removeRule = function (rule) {\n\t        common_1.removeFrom(this._rules, rule);\n\t        this.sort();\n\t    };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.otherwise = function (handler) {\n\t        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n\t            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n\t        }\n\t        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n\t        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n\t        this.sort();\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.when = function (matcher, handler, options) {\n\t        var rule = this.urlRuleFactory.create(matcher, handler);\n\t        if (predicates_1.isDefined(options && options.priority))\n\t            rule.priority = options.priority;\n\t        this.rule(rule);\n\t        return rule;\n\t    };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlRouter.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    ;\n\t    return UrlRouter;\n\t}());\n\texports.UrlRouter = UrlRouter;\n\t//# sourceMappingURL=urlRouter.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\tvar urlMatcher_1 = __webpack_require__(30);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/**\n\t * Creates a [[UrlRule]]\n\t *\n\t * Creates a [[UrlRule]] from a:\n\t *\n\t * - `string`\n\t * - [[UrlMatcher]]\n\t * - `RegExp`\n\t * - [[State]]\n\t * @internalapi\n\t */\n\tvar UrlRuleFactory = (function () {\n\t    function UrlRuleFactory(router) {\n\t        this.router = router;\n\t    }\n\t    UrlRuleFactory.prototype.compile = function (str) {\n\t        return this.router.urlMatcherFactory.compile(str);\n\t    };\n\t    UrlRuleFactory.prototype.create = function (what, handler) {\n\t        var _this = this;\n\t        var makeRule = hof_1.pattern([\n\t            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n\t            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n\t            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n\t            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n\t            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n\t        ]);\n\t        var rule = makeRule(what);\n\t        if (!rule)\n\t            throw new Error(\"invalid 'what' in when()\");\n\t        return rule;\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a UrlMatcher\n\t     *\n\t     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     *\n\t     * ## Handler as UrlMatcher\n\t     *\n\t     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n\t     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n\t     * The url is replaced with the result.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n\t     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n\t     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match); // '/home/123/456'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n\t        var _handler = handler;\n\t        if (predicates_1.isString(handler))\n\t            handler = this.router.urlMatcherFactory.compile(handler);\n\t        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n\t            _handler = function (match) { return handler.format(match); };\n\t        function match(url) {\n\t            var match = urlMatcher.exec(url.path, url.search, url.hash);\n\t            return urlMatcher.validates(match) && match;\n\t        }\n\t        // Prioritize URLs, lowest to highest:\n\t        // - Some optional URL parameters, but none matched\n\t        // - No optional parameters in URL\n\t        // - Some optional parameters, some matched\n\t        // - Some optional parameters, all matched\n\t        function matchPriority(params) {\n\t            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n\t            if (!optional.length)\n\t                return 0.000001;\n\t            var matched = optional.filter(function (param) { return params[param.id]; });\n\t            return matched.length / optional.length;\n\t        }\n\t        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches a state by its url\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromState($state.get('foo'), router);\n\t     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n\t     * var result = rule.handler(match);\n\t     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromState = function (state, router) {\n\t        /**\n\t         * Handles match by transitioning to matched state\n\t         *\n\t         * First checks if the router should start a new transition.\n\t         * A new transition is not required if the current state's URL\n\t         * and the new URL are already identical\n\t         */\n\t        var handler = function (match) {\n\t            var $state = router.stateService;\n\t            var globals = router.globals;\n\t            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n\t                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n\t            }\n\t        };\n\t        var details = { state: state, type: \"STATE\" };\n\t        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n\t    };\n\t    /**\n\t     * A UrlRule which matches based on a regular expression\n\t     *\n\t     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n\t     *\n\t     * ## Handler as a function\n\t     *\n\t     * If `handler` is a function, the function is invoked with:\n\t     *\n\t     * - regexp match array (from `regexp`)\n\t     * - url: the current Url ([[UrlParts]])\n\t     * - router: the router object ([[UIRouter]])\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     *\n\t     * ## Handler as string\n\t     *\n\t     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n\t     * The string is first interpolated using `string.replace()` style pattern.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n\t     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n\t     * var result = rule.handler(match); // '/home/bar'\n\t     * ```\n\t     */\n\t    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n\t        if (regexp.global || regexp.sticky)\n\t            throw new Error(\"Rule RegExp must not be global or sticky\");\n\t        /**\n\t         * If handler is a string, the url will be replaced by the string.\n\t         * If the string has any String.replace() style variables in it (like `$2`),\n\t         * they will be replaced by the captures from [[match]]\n\t         */\n\t        var redirectUrlTo = function (match) {\n\t            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n\t            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t                return match[what === '$' ? 0 : Number(what)];\n\t            });\n\t        };\n\t        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n\t        var match = function (url) {\n\t            return regexp.exec(url.path);\n\t        };\n\t        var details = { regexp: regexp, type: \"REGEXP\" };\n\t        return common_1.extend(new BaseUrlRule(match, _handler), details);\n\t    };\n\t    return UrlRuleFactory;\n\t}());\n\tUrlRuleFactory.isUrlRule = function (obj) {\n\t    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n\t};\n\texports.UrlRuleFactory = UrlRuleFactory;\n\t/**\n\t * A base rule which calls `match`\n\t *\n\t * The value from the `match` function is passed through to the `handler`.\n\t * @internalapi\n\t */\n\tvar BaseUrlRule = (function () {\n\t    function BaseUrlRule(match, handler) {\n\t        var _this = this;\n\t        this.match = match;\n\t        this.type = \"RAW\";\n\t        this.matchPriority = function (match) { return 0 - _this.$id; };\n\t        this.handler = handler || common_1.identity;\n\t    }\n\t    return BaseUrlRule;\n\t}());\n\texports.BaseUrlRule = BaseUrlRule;\n\t//# sourceMappingURL=urlRule.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Internal representation of a UI-Router state.\n\t *\n\t * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n\t *\n\t * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n\t *\n\t * This class prototypally inherits from the corresponding [[StateDeclaration]].\n\t * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n\t */\n\tvar State = (function () {\n\t    function State(config) {\n\t        common_1.extend(this, config);\n\t        // Object.freeze(this);\n\t    }\n\t    /**\n\t     * Returns true if the provided parameter is the same state.\n\t     *\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    State.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @deprecated this does not properly handle dot notation\n\t     * @returns Returns a dot-separated name of the state.\n\t     */\n\t    State.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns The root of this state's tree.\n\t     */\n\t    State.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    /**\n\t     * Gets the state's `Param`eters\n\t     *\n\t     * Gets [[Param]] information that is owned by the state.\n\t     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n\t     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n\t     *\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameters = function (opts) {\n\t        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(common_1.values(this.params))\n\t            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n\t    };\n\t    /**\n\t     * Returns a single [[Param]] that is owned by the state\n\t     *\n\t     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n\t     * @param id the name of the [[Param]] to return\n\t     * @param opts options\n\t     */\n\t    State.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    State.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    return State;\n\t}());\n\texports.State = State;\n\t//# sourceMappingURL=stateObject.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module transition\n\t */ /** for typedoc */\n\tvar interface_1 = __webpack_require__(16);\n\tvar transition_1 = __webpack_require__(14);\n\tvar hookRegistry_1 = __webpack_require__(19);\n\tvar resolve_1 = __webpack_require__(36);\n\tvar views_1 = __webpack_require__(37);\n\tvar url_1 = __webpack_require__(38);\n\tvar redirectTo_1 = __webpack_require__(39);\n\tvar onEnterExitRetain_1 = __webpack_require__(40);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar transitionEventType_1 = __webpack_require__(42);\n\tvar transitionHook_1 = __webpack_require__(17);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * The default [[Transition]] options.\n\t *\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\texports.defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; },\n\t    source: \"unknown\"\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * - Most importantly, it allows global Transition Hooks to be registered.\n\t * - It allows the default transition error handler to be set.\n\t * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n\t *\n\t * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n\t */\n\tvar TransitionService = (function () {\n\t    /** @hidden */\n\t    function TransitionService(_router) {\n\t        /** @hidden */\n\t        this._transitionCount = 0;\n\t        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n\t        this._eventTypes = [];\n\t        /** @hidden The registered transition hooks */\n\t        this._registeredHooks = {};\n\t        /** @hidden The  paths on a criteria object */\n\t        this._criteriaPaths = {};\n\t        this._router = _router;\n\t        this.$view = _router.viewService;\n\t        this._deregisterHookFns = {};\n\t        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n\t            '_definePathType',\n\t            '_defineEvent',\n\t            '_getPathTypes',\n\t            '_getEvents',\n\t            'getHooks',\n\t        ]);\n\t        this._defineDefaultPaths();\n\t        this._defineDefaultEvents();\n\t        this._registerDefaultTransitionHooks();\n\t    }\n\t    /**\n\t     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n\t     *\n\t     * Registers a transition lifecycle hook, which is invoked during transition construction.\n\t     *\n\t     * This low level hook should only be used by plugins.\n\t     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n\t     * The Sticky States plugin uses this hook to modify the treechanges.\n\t     *\n\t     * ### Lifecycle\n\t     *\n\t     * `onCreate` hooks are invoked *while a transition is being constructed*.\n\t     *\n\t     * ### Return value\n\t     *\n\t     * The hook's return value is ignored\n\t     *\n\t     * @internalapi\n\t     * @param criteria defines which Transitions the Hook should be invoked for.\n\t     * @param callback the hook function which will be invoked.\n\t     * @param options the registration options\n\t     * @returns a function which deregisters the hook.\n\t     */\n\t    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n\t    /** @inheritdoc */\n\t    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n\t    /**\n\t     * dispose\n\t     * @internalapi\n\t     */\n\t    TransitionService.prototype.dispose = function (router) {\n\t        delete router.globals.transition;\n\t        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n\t            hook._deregistered = true;\n\t            common_1.removeFrom(hooksArray, hook);\n\t        }); });\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     * It is used internally by the [[StateService]] and should generally not be called by application code.\n\t     *\n\t     * @param fromPath the path to the current state (the from state)\n\t     * @param targetState the target state (destination)\n\t     * @returns a Transition\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new transition_1.Transition(fromPath, targetState, this._router);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultEvents = function () {\n\t        var Phase = interface_1.TransitionHookPhase;\n\t        var TH = transitionHook_1.TransitionHook;\n\t        var paths = this._criteriaPaths;\n\t        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n\t        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n\t        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n\t        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n\t        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n\t        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n\t        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n\t        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineDefaultPaths = function () {\n\t        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n\t        this._definePathType(\"to\", TRANSITION);\n\t        this._definePathType(\"from\", TRANSITION);\n\t        this._definePathType(\"exiting\", STATE);\n\t        this._definePathType(\"retained\", STATE);\n\t        this._definePathType(\"entering\", STATE);\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n\t        this._eventTypes.push(eventType);\n\t        hookRegistry_1.makeEvent(this, this, eventType);\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    TransitionService.prototype._getEvents = function (phase) {\n\t        var transitionHookTypes = predicates_1.isDefined(phase) ?\n\t            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n\t            this._eventTypes.slice();\n\t        return transitionHookTypes.sort(function (l, r) {\n\t            var cmpByPhase = l.hookPhase - r.hookPhase;\n\t            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n\t        });\n\t    };\n\t    /**\n\t     * Adds a Path to be used as a criterion against a TreeChanges path\n\t     *\n\t     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n\t     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n\t     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n\t     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n\t     *\n\t     * @hidden\n\t     */\n\t    TransitionService.prototype._definePathType = function (name, hookScope) {\n\t        this._criteriaPaths[name] = { name: name, scope: hookScope };\n\t    };\n\t    /** * @hidden */\n\t    TransitionService.prototype._getPathTypes = function () {\n\t        return this._criteriaPaths;\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype.getHooks = function (hookName) {\n\t        return this._registeredHooks[hookName];\n\t    };\n\t    /** @hidden */\n\t    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n\t        var fns = this._deregisterHookFns;\n\t        // Wire up redirectTo hook\n\t        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n\t        // Wire up onExit/Retain/Enter state hooks\n\t        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n\t        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n\t        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n\t        // Wire up Resolve hooks\n\t        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n\t        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n\t        // Wire up the View management hooks\n\t        fns.loadViews = views_1.registerLoadEnteringViews(this);\n\t        fns.activateViews = views_1.registerActivateViews(this);\n\t        // After globals.current is updated at priority: 10000\n\t        fns.updateUrl = url_1.registerUpdateUrl(this);\n\t        // Lazy load state trees\n\t        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n\t    };\n\t    return TransitionService;\n\t}());\n\texports.TransitionService = TransitionService;\n\t//# sourceMappingURL=transitionService.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n\t *\n\t * Registered using `transitionService.onStart({}, eagerResolvePath);`\n\t *\n\t * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar eagerResolvePath = function (trans) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .resolvePath(\"EAGER\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerEagerResolvePath = function (transitionService) {\n\t    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n\t *\n\t * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n\t *\n\t * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n\t *\n\t * See [[StateDeclaration.resolve]]\n\t */\n\tvar lazyResolveState = function (trans, state) {\n\t    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n\t        .subContext(state)\n\t        .resolvePath(\"LAZY\", trans)\n\t        .then(common_1.noop);\n\t};\n\texports.registerLazyResolveState = function (transitionService) {\n\t    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n\t};\n\t//# sourceMappingURL=resolve.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] which waits for the views to load\n\t *\n\t * Registered using `transitionService.onStart({}, loadEnteringViews);`\n\t *\n\t * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n\t * In angular 1, this includes loading the templates.\n\t */\n\tvar loadEnteringViews = function (transition) {\n\t    var $q = coreservices_1.services.$q;\n\t    var enteringViews = transition.views(\"entering\");\n\t    if (!enteringViews.length)\n\t        return;\n\t    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n\t};\n\texports.registerLoadEnteringViews = function (transitionService) {\n\t    return transitionService.onFinish({}, loadEnteringViews);\n\t};\n\t/**\n\t * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n\t *\n\t * Registered using `transitionService.onSuccess({}, activateViews);`\n\t *\n\t * After a transition is complete, this hook deactivates the old views from the previous state,\n\t * and activates the new views from the destination state.\n\t *\n\t * See [[ViewService]]\n\t */\n\tvar activateViews = function (transition) {\n\t    var enteringViews = transition.views(\"entering\");\n\t    var exitingViews = transition.views(\"exiting\");\n\t    if (!enteringViews.length && !exitingViews.length)\n\t        return;\n\t    var $view = transition.router.viewService;\n\t    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n\t    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n\t    $view.sync();\n\t};\n\texports.registerActivateViews = function (transitionService) {\n\t    return transitionService.onSuccess({}, activateViews);\n\t};\n\t//# sourceMappingURL=views.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A [[TransitionHookFn]] which updates the URL after a successful transition\n\t *\n\t * Registered using `transitionService.onSuccess({}, updateUrl);`\n\t */\n\tvar updateUrl = function (transition) {\n\t    var options = transition.options();\n\t    var $state = transition.router.stateService;\n\t    var $urlRouter = transition.router.urlRouter;\n\t    // Dont update the url in these situations:\n\t    // The transition was triggered by a URL sync (options.source === 'url')\n\t    // The user doesn't want the url to update (options.location === false)\n\t    // The destination state, and all parents have no navigable url\n\t    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n\t        var urlOptions = { replace: options.location === 'replace' };\n\t        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n\t    }\n\t    $urlRouter.update(true);\n\t};\n\texports.registerUpdateUrl = function (transitionService) {\n\t    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n\t};\n\t//# sourceMappingURL=url.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module hooks */ /** */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar targetState_1 = __webpack_require__(18);\n\t/**\n\t * A [[TransitionHookFn]] that redirects to a different state or params\n\t *\n\t * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n\t *\n\t * See [[StateDeclaration.redirectTo]]\n\t */\n\tvar redirectToHook = function (trans) {\n\t    var redirect = trans.to().redirectTo;\n\t    if (!redirect)\n\t        return;\n\t    var $state = trans.router.stateService;\n\t    function handleResult(result) {\n\t        if (!result)\n\t            return;\n\t        if (result instanceof targetState_1.TargetState)\n\t            return result;\n\t        if (predicates_1.isString(result))\n\t            return $state.target(result, trans.params(), trans.options());\n\t        if (result['state'] || result['params'])\n\t            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n\t    }\n\t    if (predicates_1.isFunction(redirect)) {\n\t        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n\t    }\n\t    return handleResult(redirect);\n\t};\n\texports.registerRedirectToHook = function (transitionService) {\n\t    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n\t};\n\t//# sourceMappingURL=redirectTo.js.map\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * A factory which creates an onEnter, onExit or onRetain transition hook function\n\t *\n\t * The returned function invokes the (for instance) state.onEnter hook when the\n\t * state is being entered.\n\t *\n\t * @hidden\n\t */\n\tfunction makeEnterExitRetainHook(hookName) {\n\t    return function (transition, state) {\n\t        var hookFn = state[hookName];\n\t        return hookFn(transition, state);\n\t    };\n\t}\n\t/**\n\t * The [[TransitionStateHookFn]] for onExit\n\t *\n\t * When the state is being exited, the state's .onExit function is invoked.\n\t *\n\t * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n\t *\n\t * See: [[IHookRegistry.onExit]]\n\t */\n\tvar onExitHook = makeEnterExitRetainHook('onExit');\n\texports.registerOnExitHook = function (transitionService) {\n\t    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onRetain\n\t *\n\t * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n\t *\n\t * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n\t *\n\t * See: [[IHookRegistry.onRetain]]\n\t */\n\tvar onRetainHook = makeEnterExitRetainHook('onRetain');\n\texports.registerOnRetainHook = function (transitionService) {\n\t    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n\t};\n\t/**\n\t * The [[TransitionStateHookFn]] for onEnter\n\t *\n\t * When the state is being entered, the state's .onEnter function is invoked.\n\t *\n\t * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n\t *\n\t * See: [[IHookRegistry.onEnter]]\n\t */\n\tvar onEnterHook = makeEnterExitRetainHook('onEnter');\n\texports.registerOnEnterHook = function (transitionService) {\n\t    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n\t};\n\t//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\t/**\n\t * A [[TransitionHookFn]] that performs lazy loading\n\t *\n\t * When entering a state \"abc\" which has a `lazyLoad` function defined:\n\t * - Invoke the `lazyLoad` function (unless it is already in process)\n\t *   - Flag the hook function as \"in process\"\n\t *   - The function should return a promise (that resolves when lazy loading is complete)\n\t * - Wait for the promise to settle\n\t *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n\t *   - Flag the hook function as \"not in process\"\n\t * - If the hook was successful\n\t *   - Remove the `lazyLoad` function from the state declaration\n\t * - If all the hooks were successful\n\t *   - Retry the transition (by returning a TargetState)\n\t *\n\t * ```\n\t * .state('abc', {\n\t *   component: 'fooComponent',\n\t *   lazyLoad: () => System.import('./fooComponent')\n\t *   });\n\t * ```\n\t *\n\t * See [[StateDeclaration.lazyLoad]]\n\t */\n\tvar lazyLoadHook = function (transition) {\n\t    var router = transition.router;\n\t    function retryTransition() {\n\t        if (transition.originalTransition().options().source !== 'url') {\n\t            // The original transition was not triggered via url sync\n\t            // The lazy state should be loaded now, so re-try the original transition\n\t            var orig = transition.targetState();\n\t            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n\t        }\n\t        // The original transition was triggered via url sync\n\t        // Run the URL rules and find the best match\n\t        var $url = router.urlService;\n\t        var result = $url.match($url.parts());\n\t        var rule = result && result.rule;\n\t        // If the best match is a state, redirect the transition (instead\n\t        // of calling sync() which supersedes the current transition)\n\t        if (rule && rule.type === \"STATE\") {\n\t            var state = rule.state;\n\t            var params = result.match;\n\t            return router.stateService.target(state, params, transition.options());\n\t        }\n\t        // No matching state found, so let .sync() choose the best non-state match/otherwise\n\t        router.urlService.sync();\n\t    }\n\t    var promises = transition.entering()\n\t        .filter(function (state) { return !!state.$$state().lazyLoad; })\n\t        .map(function (state) { return lazyLoadState(transition, state); });\n\t    return coreservices_1.services.$q.all(promises).then(retryTransition);\n\t};\n\texports.registerLazyLoadHook = function (transitionService) {\n\t    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n\t};\n\t/**\n\t * Invokes a state's lazy load function\n\t *\n\t * @param transition a Transition context\n\t * @param state the state to lazy load\n\t * @returns A promise for the lazy load result\n\t */\n\tfunction lazyLoadState(transition, state) {\n\t    var lazyLoadFn = state.$$state().lazyLoad;\n\t    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n\t    var promise = lazyLoadFn['_promise'];\n\t    if (!promise) {\n\t        var success = function (result) {\n\t            delete state.lazyLoad;\n\t            delete state.$$state().lazyLoad;\n\t            delete lazyLoadFn['_promise'];\n\t            return result;\n\t        };\n\t        var error = function (err) {\n\t            delete lazyLoadFn['_promise'];\n\t            return coreservices_1.services.$q.reject(err);\n\t        };\n\t        promise = lazyLoadFn['_promise'] =\n\t            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n\t                .then(updateStateRegistry)\n\t                .then(success, error);\n\t    }\n\t    /** Register any lazy loaded state definitions */\n\t    function updateStateRegistry(result) {\n\t        if (result && Array.isArray(result.states)) {\n\t            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n\t        }\n\t        return result;\n\t    }\n\t    return promise;\n\t}\n\texports.lazyLoadState = lazyLoadState;\n\t//# sourceMappingURL=lazyLoad.js.map\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar transitionHook_1 = __webpack_require__(17);\n\t/**\n\t * This class defines a type of hook, such as `onBefore` or `onEnter`.\n\t * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n\t *\n\t * @interalapi\n\t */\n\tvar TransitionEventType = (function () {\n\t    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n\t        if (reverseSort === void 0) { reverseSort = false; }\n\t        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n\t        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n\t        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n\t        this.name = name;\n\t        this.hookPhase = hookPhase;\n\t        this.hookOrder = hookOrder;\n\t        this.criteriaMatchPath = criteriaMatchPath;\n\t        this.reverseSort = reverseSort;\n\t        this.getResultHandler = getResultHandler;\n\t        this.getErrorHandler = getErrorHandler;\n\t        this.rejectIfSuperseded = rejectIfSuperseded;\n\t    }\n\t    return TransitionEventType;\n\t}());\n\texports.TransitionEventType = TransitionEventType;\n\t//# sourceMappingURL=transitionEventType.js.map\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module view\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar trace_1 = __webpack_require__(15);\n\t/**\n\t * The View service\n\t *\n\t * This service pairs existing `ui-view` components (which live in the DOM)\n\t * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n\t *\n\t * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n\t *   The views from exited states are deactivated via [[deactivateViewConfig]].\n\t *   (See: the [[registerActivateViews]] Transition Hook)\n\t *\n\t * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n\t *\n\t * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n\t * are configured with the matching [[ViewConfig]](s)\n\t *\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this._uiViews = [];\n\t        this._viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this._pluginapi = {\n\t            _rootViewContext: this._rootViewContext.bind(this),\n\t            _viewConfigFactory: this._viewConfigFactory.bind(this),\n\t            _registeredUIViews: function () { return _this._uiViews; },\n\t            _activeViewConfigs: function () { return _this._viewConfigs; },\n\t        };\n\t    }\n\t    ViewService.prototype._rootViewContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    ;\n\t    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (path, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(path, decl);\n\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * Deactivates a ViewConfig.\n\t     *\n\t     * This function deactivates a `ViewConfig`.\n\t     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        common_1.removeFrom(this._viewConfigs, viewConfig);\n\t    };\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this._viewConfigs.push(viewConfig);\n\t    };\n\t    ViewService.prototype.sync = function () {\n\t        var _this = this;\n\t        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t        // Return the number of dots in the fully qualified name\n\t        function uiViewDepth(uiView) {\n\t            return uiView.fqn.split(\".\").length;\n\t        }\n\t        // Return the ViewConfig's context's depth in the context tree.\n\t        function viewConfigDepth(config) {\n\t            var context = config.viewDecl.$context, count = 0;\n\t            while (++count && context.parent)\n\t                context = context.parent;\n\t            return count;\n\t        }\n\t        // Given a depth function, returns a compare function which can return either ascending or descending order\n\t        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t        var matchingConfigPair = function (uiView) {\n\t            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n\t            if (matchingConfigs.length > 1) {\n\t                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n\t                // Sort by depth and return the match from the deepest child\n\t                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n\t                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t            }\n\t            return [uiView, matchingConfigs[0]];\n\t        };\n\t        var configureUIView = function (_a) {\n\t            var uiView = _a[0], viewConfig = _a[1];\n\t            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t            if (_this._uiViews.indexOf(uiView) !== -1)\n\t                uiView.configUpdated(viewConfig);\n\t        };\n\t        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n\t    };\n\t    ;\n\t    /**\n\t     * Registers a `ui-view` component\n\t     *\n\t     * When a `ui-view` component is created, it uses this method to register itself.\n\t     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n\t     *\n\t     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n\t     * and what the view's state context is.\n\t     *\n\t     * Note: There is no corresponding `deregisterUIView`.\n\t     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n\t     *\n\t     * @param uiView The metadata for a UIView\n\t     * @return a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUIView = function (uiView) {\n\t        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this._uiViews;\n\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t        if (uiViews.filter(fqnMatches).length)\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx === -1) {\n\t                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n\t            common_1.removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    ;\n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this._uiViews.map(hof_1.prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * This should be used by a framework implementation to calculate the values for\n\t     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        else if (uiViewContextAnchor === '.') {\n\t            uiViewContextAnchor = context.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    return ViewService;\n\t}());\n\t/**\n\t * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t *\n\t * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t *\n\t * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t *\n\t * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t *\n\t * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t * - the ui-view's name matches the ViewConfig's target name\n\t * - the ui-view's context matches the ViewConfig's anchor\n\t *\n\t * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t * - There exists a parent ui-view where:\n\t *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t *    - the parent ui-view's context matches the ViewConfig's anchor\n\t * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t *\n\t * Example:\n\t *\n\t * DOM:\n\t * <ui-view>                        <!-- created in the root context (name: \"\") -->\n\t *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t *       </ui-view>\n\t *     </ui-view>\n\t *   </ui-view>\n\t * </ui-view>\n\t *\n\t * uiViews: [\n\t *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t * ]\n\t *\n\t * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t *\n\t * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t *\n\t * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t *   the tail of the ui-view's fqn \"default.bar\"\n\t *\n\t * @internalapi\n\t */\n\tViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n\t    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t    if (uiView.$type !== viewConfig.viewDecl.$type)\n\t        return false;\n\t    // Split names apart from both viewConfig and uiView into segments\n\t    var vc = viewConfig.viewDecl;\n\t    var vcSegments = vc.$uiViewName.split(\".\");\n\t    var uivSegments = uiView.fqn.split(\".\");\n\t    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t        return false;\n\t    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t    var negOffset = (1 - vcSegments.length) || undefined;\n\t    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t}; };\n\texports.ViewService = ViewService;\n\t//# sourceMappingURL=view.js.map\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar stateMatcher_1 = __webpack_require__(45);\n\tvar stateBuilder_1 = __webpack_require__(46);\n\tvar stateQueueManager_1 = __webpack_require__(47);\n\tvar common_1 = __webpack_require__(6);\n\tvar hof_1 = __webpack_require__(8);\n\tvar StateRegistry = (function () {\n\t    /** @internalapi */\n\t    function StateRegistry(_router) {\n\t        this._router = _router;\n\t        this.states = {};\n\t        this.listeners = [];\n\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n\t        this._registerRoot();\n\t    }\n\t    /** @internalapi */\n\t    StateRegistry.prototype._registerRoot = function () {\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    };\n\t    /** @internalapi */\n\t    StateRegistry.prototype.dispose = function () {\n\t        var _this = this;\n\t        this.stateQueue.dispose();\n\t        this.listeners = [];\n\t        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n\t    };\n\t    /**\n\t     * Listen for a State Registry events\n\t     *\n\t     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let allStates = registry.get();\n\t     *\n\t     * // Later, invoke deregisterFn() to remove the listener\n\t     * let deregisterFn = registry.onStatesChanged((event, states) => {\n\t     *   switch(event) {\n\t     *     case: 'registered':\n\t     *       states.forEach(state => allStates.push(state));\n\t     *       break;\n\t     *     case: 'deregistered':\n\t     *       states.forEach(state => {\n\t     *         let idx = allStates.indexOf(state);\n\t     *         if (idx !== -1) allStates.splice(idx, 1);\n\t     *       });\n\t     *       break;\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param listener a callback function invoked when the registered states changes.\n\t     *        The function receives two parameters, `event` and `state`.\n\t     *        See [[StateRegistryListener]]\n\t     * @return a function that deregisters the listener\n\t     */\n\t    StateRegistry.prototype.onStatesChanged = function (listener) {\n\t        this.listeners.push(listener);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.listeners)(listener);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Gets the implicit root state\n\t     *\n\t     * Gets the root of the state tree.\n\t     * The root state is implicitly created by UI-Router.\n\t     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n\t     *\n\t     * @return the root [[State]]\n\t     */\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    /**\n\t     * Adds a state to the registry\n\t     *\n\t     * Registers a [[StateDeclaration]] or queues it for registration.\n\t     *\n\t     * Note: a state will be queued if the state's parent isn't yet registered.\n\t     *\n\t     * @param stateDefinition the definition of the state to register.\n\t     * @returns the internal [[State]] object.\n\t     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n\t     *          If the state was only queued, then the object is not fully built.\n\t     */\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    /** @hidden */\n\t    StateRegistry.prototype._deregisterTree = function (state) {\n\t        var _this = this;\n\t        var all = this.get().map(function (s) { return s.$$state(); });\n\t        var getChildren = function (states) {\n\t            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n\t            return children.length === 0 ? children : children.concat(getChildren(children));\n\t        };\n\t        var children = getChildren([state]);\n\t        var deregistered = [state].concat(children).reverse();\n\t        deregistered.forEach(function (state) {\n\t            var $ur = _this._router.urlRouter;\n\t            // Remove URL rule\n\t            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n\t            // Remove state from registry\n\t            delete _this.states[state.name];\n\t        });\n\t        return deregistered;\n\t    };\n\t    /**\n\t     * Removes a state from the registry\n\t     *\n\t     * This removes a state from the registry.\n\t     * If the state has children, they are are also removed from the registry.\n\t     *\n\t     * @param stateOrName the state's name or object representation\n\t     * @returns {State[]} a list of removed states\n\t     */\n\t    StateRegistry.prototype.deregister = function (stateOrName) {\n\t        var _state = this.get(stateOrName);\n\t        if (!_state)\n\t            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n\t        var deregisteredStates = this._deregisterTree(_state.$$state());\n\t        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n\t        return deregisteredStates;\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\texports.StateRegistry = StateRegistry;\n\t//# sourceMappingURL=stateRegistry.js.map\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(7);\n\tvar glob_1 = __webpack_require__(10);\n\tvar common_1 = __webpack_require__(6);\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = predicates_1.isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        else if (isStr) {\n\t            var matches = common_1.values(this._states)\n\t                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n\t            if (matches.length > 1) {\n\t                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n\t            }\n\t            return matches[0];\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\texports.StateMatcher = StateMatcher;\n\t//# sourceMappingURL=stateMatcher.js.map\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar strings_1 = __webpack_require__(12);\n\tvar hof_1 = __webpack_require__(8);\n\tvar resolvable_1 = __webpack_require__(25);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar parseUrl = function (url) {\n\t    if (!predicates_1.isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\tfunction nameBuilder(state) {\n\t    return state.name;\n\t}\n\tfunction selfBuilder(state) {\n\t    state.self.$$state = function () { return state; };\n\t    return state.self;\n\t}\n\tfunction dataBuilder(state) {\n\t    if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t    }\n\t    return state.data;\n\t}\n\tvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n\t    return function urlBuilder(state) {\n\t        var stateDec = state;\n\t        // For future states, i.e., states whose name ends with `.**`,\n\t        // match anything that starts with the url prefix\n\t        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n\t            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n\t        }\n\t        var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t            params: state.params || {},\n\t            paramMap: function (paramConfig, isSearch) {\n\t                if (stateDec.reloadOnSearch === false && isSearch)\n\t                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t                return paramConfig;\n\t            }\n\t        });\n\t        if (!url)\n\t            return null;\n\t        if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t    };\n\t};\n\tvar getNavigableBuilder = function (isRoot) {\n\t    return function navigableBuilder(state) {\n\t        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    };\n\t};\n\tvar getParamsBuilder = function (paramFactory) {\n\t    return function paramsBuilder(state) {\n\t        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n\t        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t};\n\tfunction pathBuilder(state) {\n\t    return state.parent ? state.parent.path.concat(state) : [state];\n\t}\n\tfunction includesBuilder(state) {\n\t    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t    includes[state.name] = true;\n\t    return includes;\n\t}\n\t/**\n\t * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * validates the `resolve` property and converts it to a [[Resolvable]] array.\n\t *\n\t * resolve: input value can be:\n\t *\n\t * {\n\t *   // analyzed but not injected\n\t *   myFooResolve: function() { return \"myFooData\"; },\n\t *\n\t *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n\t *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; \"DependencyName\" dep as string\n\t *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n\t *\n\t *   // Array split; DependencyType dep as token (compared using ===)\n\t *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n\t *\n\t *   // val.$inject used as deps\n\t *   // where:\n\t *   //     corgeResolve.$inject = [\"DependencyName\"];\n\t *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n\t *   // then \"DependencyName\" dep as string\n\t *   myCorgeResolve: corgeResolve,\n\t *\n\t *  // inject service by name\n\t *  // When a string is found, desugar creating a resolve that injects the named service\n\t *   myGraultResolve: \"SomeService\"\n\t * }\n\t *\n\t * or:\n\t *\n\t * [\n\t *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n\t *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n\t *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n\t * ]\n\t */\n\tfunction resolvablesBuilder(state) {\n\t    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n\t    var objects2Tuples = function (resolveObj, resolvePolicies) {\n\t        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n\t    };\n\t    /** fetch DI annotations from a function or ng1-style array */\n\t    var annotate = function (fn) {\n\t        var $injector = coreservices_1.services.$injector;\n\t        // ng1 doesn't have an $injector until runtime.\n\t        // If the $injector doesn't exist, use \"deferred\" literal as a\n\t        // marker indicating they should be annotated when runtime starts\n\t        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n\t    };\n\t    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n\t    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n\t    /** true if the object looks like a provide literal, or a ng2 Provider */\n\t    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n\t    /** true if the object looks like a tuple from obj2Tuples */\n\t    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n\t    /** extracts the token from a Provider or provide literal */\n\t    var token = function (p) { return p.provide || p.token; };\n\t    /** Given a literal resolve or provider object, returns a Resolvable */\n\t    var literal2Resolvable = hof_1.pattern([\n\t        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n\t        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n\t        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n\t        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n\t        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n\t    ]);\n\t    var tuple2Resolvable = hof_1.pattern([\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n\t        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n\t    ]);\n\t    var item2Resolvable = hof_1.pattern([\n\t        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n\t        [isResolveLiteral, literal2Resolvable],\n\t        [isLikeNg2Provider, literal2Resolvable],\n\t        [isTupleFromObj, tuple2Resolvable],\n\t        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n\t    ]);\n\t    // If resolveBlock is already an array, use it as-is.\n\t    // Otherwise, assume it's an object and convert to an Array of tuples\n\t    var decl = state.resolve;\n\t    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n\t    return items.map(item2Resolvable);\n\t}\n\texports.resolvablesBuilder = resolvablesBuilder;\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[State]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[State]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, urlMatcherFactory) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var root = function () { return matcher.find(\"\"); };\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        function parentBuilder(state) {\n\t            if (isRoot(state))\n\t                return null;\n\t            return matcher.find(self.parentName(state)) || root();\n\t        }\n\t        this.builders = {\n\t            name: [nameBuilder],\n\t            self: [selfBuilder],\n\t            parent: [parentBuilder],\n\t            data: [dataBuilder],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [getUrlBuilder(urlMatcherFactory, root)],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [getNavigableBuilder(isRoot)],\n\t            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/statebuilders/views.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [pathBuilder],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [includesBuilder],\n\t            resolvables: [resolvablesBuilder]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent))\n\t            return null;\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        var name = state.name || \"\";\n\t        var segments = name.split('.');\n\t        if (segments.length > 1) {\n\t            if (state.parent) {\n\t                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n\t            }\n\t            var lastSegment = segments.pop();\n\t            if (lastSegment === '**')\n\t                segments.pop();\n\t            return segments.join(\".\");\n\t        }\n\t        if (!state.parent)\n\t            return \"\";\n\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\texports.StateBuilder = StateBuilder;\n\t//# sourceMappingURL=stateBuilder.js.map\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar stateObject_1 = __webpack_require__(34);\n\t/** @internalapi */\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n\t        this.$registry = $registry;\n\t        this.$urlRouter = $urlRouter;\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.listeners = listeners;\n\t        this.queue = [];\n\t    }\n\t    /** @internalapi */\n\t    StateQueueManager.prototype.dispose = function () {\n\t        this.queue = [];\n\t    };\n\t    StateQueueManager.prototype.register = function (config) {\n\t        var _a = this, states = _a.states, queue = _a.queue;\n\t        // Wrap a new object around the state so we can store our private details easily.\n\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n\t            self: config,\n\t            resolve: config.resolve || [],\n\t            toString: function () { return config.name; }\n\t        }));\n\t        if (!predicates_1.isString(state.name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t        queue.push(state);\n\t        this.flush();\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function () {\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var registered = [], // states that got registered\n\t        orphans = [], // states that don't yet have a parent registered\n\t        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\t        while (queue.length > 0) {\n\t            var state = queue.shift();\n\t            var result = builder.build(state);\n\t            var orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                var existingState = this.$registry.get(state.name);\n\t                if (existingState && existingState.name === state.name) {\n\t                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t                }\n\t                if (existingState && existingState.name === state.name + \".**\") {\n\t                    // Remove future state of the same name\n\t                    this.$registry.deregister(existingState);\n\t                }\n\t                states[state.name] = state;\n\t                this.attachRoute(state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                registered.push(state);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[state.name];\n\t            previousQueueLength[state.name] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t                queue.push(state);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        if (registered.length) {\n\t            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function (state) {\n\t        if (state.abstract || !state.url)\n\t            return;\n\t        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n\t    };\n\t    return StateQueueManager;\n\t}());\n\texports.StateQueueManager = StateQueueManager;\n\t//# sourceMappingURL=stateQueueManager.js.map\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module state\n\t */ /** */\n\tvar common_1 = __webpack_require__(6);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar queue_1 = __webpack_require__(11);\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar pathFactory_1 = __webpack_require__(24);\n\tvar node_1 = __webpack_require__(21);\n\tvar transitionService_1 = __webpack_require__(35);\n\tvar rejectFactory_1 = __webpack_require__(13);\n\tvar targetState_1 = __webpack_require__(18);\n\tvar param_1 = __webpack_require__(22);\n\tvar glob_1 = __webpack_require__(10);\n\tvar resolveContext_1 = __webpack_require__(26);\n\tvar lazyLoad_1 = __webpack_require__(41);\n\tvar hof_1 = __webpack_require__(8);\n\t/**\n\t * Provides state related service functions\n\t *\n\t * This class provides services related to ui-router states.\n\t * An instance of this class is located on the global [[UIRouter]] object.\n\t */\n\tvar StateService = (function () {\n\t    /** @internalapi */\n\t    function StateService(router) {\n\t        this.router = router;\n\t        /** @internalapi */\n\t        this.invalidCallbacks = [];\n\t        /** @hidden */\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error && $error$.stack) {\n\t                console.error($error$);\n\t                console.error($error$.stack);\n\t            }\n\t            else if ($error$ instanceof rejectFactory_1.Rejection) {\n\t                console.error($error$.toString());\n\t                if ($error$.detail && $error$.detail.stack)\n\t                    console.error($error$.detail.stack);\n\t            }\n\t            else {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n\t        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        /**\n\t         * The [[Transition]] currently in progress (or null)\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.transition]]\n\t         */\n\t        get: function () { return this.router.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        /**\n\t         * The latest successful state parameters\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.params]]\n\t         */\n\t        get: function () { return this.router.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        /**\n\t         * The current [[StateDeclaration]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.current]]\n\t         */\n\t        get: function () { return this.router.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        /**\n\t         * The current [[State]]\n\t         *\n\t         * This is a passthrough through to [[UIRouterGlobals.$current]]\n\t         */\n\t        get: function () { return this.router.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /** @internalapi */\n\t    StateService.prototype.dispose = function () {\n\t        this.defaultErrorHandler(common_1.noop);\n\t        this.invalidCallbacks = [];\n\t    };\n\t    /**\n\t     * Handler for when [[transitionTo]] is called with an invalid state.\n\t     *\n\t     * Invokes the [[onInvalid]] callbacks, in natural order.\n\t     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n\t     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n\t     *\n\t     * @internalapi\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n\t        var _this = this;\n\t        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t        var globals = this.router.globals;\n\t        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n\t        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof targetState_1.TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid())\n\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t            if (latestThing() !== latest)\n\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n\t            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n\t            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * Registers an Invalid State handler\n\t     *\n\t     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n\t     * has been called with an invalid state reference parameter\n\t     *\n\t     * Example:\n\t     * ```js\n\t     * stateService.onInvalid(function(to, from, injector) {\n\t     *   if (to.name() === 'foo') {\n\t     *     let lazyLoader = injector.get('LazyLoadService');\n\t     *     return lazyLoader.load('foo')\n\t     *         .then(() => stateService.target('foo'));\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @param {function} callback invoked when the toState is invalid\n\t     *   This function receives the (invalid) toState, the fromState, and an injector.\n\t     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n\t     *   If one is returned, it is treated as a redirect.\n\t     *\n\t     * @returns a function which deregisters the callback\n\t     */\n\t    StateService.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t        return function deregisterListener() {\n\t            common_1.removeFrom(this.invalidCallbacks)(callback);\n\t        }.bind(this);\n\t    };\n\t    /**\n\t     * Reloads the current state\n\t     *\n\t     * A method that force reloads the current state, or a partial state hierarchy.\n\t     * All resolves are re-resolved, and components reinstantiated.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * Note: `reload()` is just an alias for:\n\t     *\n\t     * ```js\n\t     * $state.transitionTo($state.current, $state.params, {\n\t     *   reload: true, inherit: false\n\t     * });\n\t     * ```\n\t     *\n\t     * @param reloadState A state name or a state object.\n\t     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * ```\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Transition to a different state or parameters\n\t     *\n\t     * Convenience method for transitioning to a new state.\n\t     *\n\t     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t     * This allows you to easily use an absolute or relative to path and specify\n\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     *\n\t     * @param to Absolute state name, state object, or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n\t     *\n\t     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n\t     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n\t     *\n\t     *    Parameter inheritance only works between common ancestor states, I.e.\n\t     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     *    will get you all current parameters, etc.\n\t     *\n\t     * @param options Transition options\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * - Possible success values:\n\t     *    - $state.current\n\t     *\n\t     * - Possible rejection reasons:\n\t     *   - transition superseded - when a newer transition has been started after this one\n\t     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n\t     *   - transition failed - when a transition hook errors\n\t     *   - resolve error - when a resolve has errored or rejected\n\t     *\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a [[TargetState]]\n\t     *\n\t     * This is a factory method for creating a TargetState\n\t     *\n\t     * This may be returned from a Transition Hook to redirect a transition, for example.\n\t     */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        var reg = this.router.stateRegistry;\n\t        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = reg.matcher.find(identifier, options.relative);\n\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    ;\n\t    StateService.prototype.getCurrentPath = function () {\n\t        var _this = this;\n\t        var globals = this.router.globals;\n\t        var latestSuccess = globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n\t        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t    };\n\t    /**\n\t     * Low-level method for transitioning to a new state.\n\t     *\n\t     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * ```\n\t     *\n\t     * @param to State name or state object.\n\t     * @param toParams A map of the parameters that will be sent to the state,\n\t     *      will populate $stateParams.\n\t     * @param options Transition options\n\t     *\n\t     * @returns A promise representing the state of the new transition. See [[go]]\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var router = this.router;\n\t        var globals = router.globals;\n\t        var transHistory = globals.transitionHistory;\n\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t        var ref = this.target(to, toParams, options);\n\t        var currentPath = this.getCurrentPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return common_1.silentRejection(ref.error());\n\t        /**\n\t         * Special handling for Ignored, Aborted, and Redirected transitions\n\t         *\n\t         * The semantics for the transition.run() promise and the StateService.transitionTo()\n\t         * promise differ. For instance, the run() promise may be rejected because it was\n\t         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n\t         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n\t         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n\t         */\n\t        var rejectedTransitionHandler = function (transition) { return function (error) {\n\t            if (error instanceof rejectFactory_1.Rejection) {\n\t                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n\t                    router.urlRouter.update();\n\t                    return coreservices_1.services.$q.when(globals.current);\n\t                }\n\t                var detail = error.detail;\n\t                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n\t                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n\t                    // by returning the promise for the new (redirect) `Transition.run()`.\n\t                    var redirect = transition.redirect(detail);\n\t                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n\t                }\n\t                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t                    router.urlRouter.update();\n\t                }\n\t            }\n\t            var errorHandler = _this.defaultErrorHandler();\n\t            errorHandler(error);\n\t            return coreservices_1.services.$q.reject(error);\n\t        }; };\n\t        var transition = this.router.transitionService.create(currentPath, ref);\n\t        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n\t        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return common_1.extend(transitionToPromise, { transition: transition });\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *is* the provided state\n\t     *\n\t     * Similar to [[includes]] but only checks for the full state name.\n\t     * If params is supplied then it will be tested for strict equality against the current\n\t     * active params object, so all params must match with none missing and no extras.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     * ```\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * ```html\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Checks if the current state *includes* the provided state\n\t     *\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * #### Example when `$state.$current.name === 'contacts.details.item'`\n\t     * ```js\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     * ```\n\t     *\n\t     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n\t     * ```js\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * ```\n\t     *\n\t     * @param stateOrName A partial name, relative name, glob pattern,\n\t     *   or state object to be searched for within the current state name.\n\t     * @param params A param object, e.g. `{sectionId: section.id}`,\n\t     *   that you'd like to test against the current active state.\n\t     * @param options An options object. The options are:\n\t     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     *     test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (!predicates_1.isDefined(include[state.name]))\n\t            return false;\n\t        if (!params)\n\t            return true;\n\t        var schema = state.parameters({ inherit: true, matchingKeys: params });\n\t        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n\t    };\n\t    ;\n\t    /**\n\t     * Generates a URL for a state and parameters\n\t     *\n\t     * Returns the url for the given state populated with the given params.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * ```\n\t     *\n\t     * @param stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param params An object of parameter values to fill the state's required parameters.\n\t     * @param options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current\n\t        };\n\t        options = common_1.defaults(options, defaultHrefOpts);\n\t        params = params || {};\n\t        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t            absolute: options.absolute\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * Sets or gets the default [[transitionTo]] error handler.\n\t     *\n\t     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n\t     * This includes errors caused by resolves and transition hooks.\n\t     *\n\t     * Note:\n\t     * This handler does not receive certain Transition rejections.\n\t     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n\t     *\n\t     * The built-in default error handler logs the error to the console.\n\t     *\n\t     * You can provide your own custom handler.\n\t     *\n\t     * #### Example:\n\t     * ```js\n\t     * stateService.defaultErrorHandler(function() {\n\t     *   // Do not log transitionTo errors\n\t     * });\n\t     * ```\n\t     *\n\t     * @param handler a global error handler function\n\t     * @returns the current global error handler\n\t     */\n\t    StateService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        var reg = this.router.stateRegistry;\n\t        if (arguments.length === 0)\n\t            return reg.get();\n\t        return reg.get(stateOrName, base || this.$current);\n\t    };\n\t    /**\n\t     * Lazy loads a state\n\t     *\n\t     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n\t     *\n\t     * @param stateOrName the state that should be lazy loaded\n\t     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n\t     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n\t     * This noop transition is not actually run.\n\t     *\n\t     * @returns a promise to lazy load\n\t     */\n\t    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n\t        var state = this.get(stateOrName);\n\t        if (!state || !state.lazyLoad)\n\t            throw new Error(\"Can not lazy load \" + stateOrName);\n\t        var currentPath = this.getCurrentPath();\n\t        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n\t        transition = transition || this.router.transitionService.create(currentPath, target);\n\t        return lazyLoad_1.lazyLoadState(transition, state);\n\t    };\n\t    return StateService;\n\t}());\n\texports.StateService = StateService;\n\t//# sourceMappingURL=stateService.js.map\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @coreapi\n\t * @module core\n\t */ /** */\n\tvar stateParams_1 = __webpack_require__(50);\n\tvar queue_1 = __webpack_require__(11);\n\tvar common_1 = __webpack_require__(6);\n\t/**\n\t * Global router state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, etc.\n\t */\n\tvar Globals = (function () {\n\t    /** @hidden */\n\t    function Globals(transitionService) {\n\t        var _this = this;\n\t        /** @inheritdoc */\n\t        this.params = new stateParams_1.StateParams();\n\t        /** @internalapi */\n\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t        /** @internalapi */\n\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t        // TODO: This probably belongs in a hooks/globals.ts\n\t        var beforeNewTransition = function ($transition$) {\n\t            _this.transition = $transition$;\n\t            _this.transitionHistory.enqueue($transition$);\n\t            var updateGlobalState = function () {\n\t                _this.successfulTransitions.enqueue($transition$);\n\t                _this.$current = $transition$.$to();\n\t                _this.current = _this.$current.self;\n\t                common_1.copy($transition$.params(), _this.params);\n\t            };\n\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t                _this.transition = null; };\n\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t        };\n\t        transitionService.onBefore({}, beforeNewTransition);\n\t    }\n\t    return Globals;\n\t}());\n\texports.Globals = Globals;\n\t//# sourceMappingURL=globals.js.map\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(6);\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        common_1.extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return common_1.extend({}, inherited, newParams);\n\t    };\n\t    ;\n\t    return StateParams;\n\t}());\n\texports.StateParams = StateParams;\n\t//# sourceMappingURL=stateParams.js.map\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @coreapi\n\t * @module url\n\t */ /** */\n\t\"use strict\";\n\tvar coreservices_1 = __webpack_require__(9);\n\tvar common_1 = __webpack_require__(6);\n\t/** @hidden */\n\tvar makeStub = function (keys) {\n\t    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n\t};\n\t/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n\t/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n\t/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n\t/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n\t/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n\t/**\n\t * API for URL management\n\t */\n\tvar UrlService = (function () {\n\t    /** @hidden */\n\t    function UrlService(router, lateBind) {\n\t        if (lateBind === void 0) { lateBind = true; }\n\t        this.router = router;\n\t        this.rules = {};\n\t        this.config = {};\n\t        // proxy function calls from UrlService to the LocationService/LocationConfig\n\t        var locationServices = function () { return router.locationService; };\n\t        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n\t        var locationConfig = function () { return router.locationConfig; };\n\t        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n\t        var umf = function () { return router.urlMatcherFactory; };\n\t        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n\t        var urlRouter = function () { return router.urlRouter; };\n\t        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n\t        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n\t    }\n\t    UrlService.prototype.url = function (newurl, replace, state) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.path = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.search = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.hash = function () { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.onChange = function (callback) { return; };\n\t    ;\n\t    /**\n\t     * Returns the current URL parts\n\t     *\n\t     * This method returns the current URL components as a [[UrlParts]] object.\n\t     *\n\t     * @returns the current url parts\n\t     */\n\t    UrlService.prototype.parts = function () {\n\t        return { path: this.path(), search: this.search(), hash: this.hash() };\n\t    };\n\t    UrlService.prototype.dispose = function () { };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.sync = function (evt) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.listen = function (enabled) { return; };\n\t    ;\n\t    /** @inheritdoc */\n\t    UrlService.prototype.deferIntercept = function (defer) { return; };\n\t    /** @inheritdoc */\n\t    UrlService.prototype.match = function (urlParts) { return; };\n\t    return UrlService;\n\t}());\n\t/** @hidden */\n\tUrlService.locationServiceStub = makeStub(locationServicesFns);\n\t/** @hidden */\n\tUrlService.locationConfigStub = makeStub(locationConfigFns);\n\texports.UrlService = UrlService;\n\t//# sourceMappingURL=urlService.js.map\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(22));\n\t__export(__webpack_require__(31));\n\t__export(__webpack_require__(50));\n\t__export(__webpack_require__(23));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module path */ /** for typedoc */\n\t__export(__webpack_require__(21));\n\t__export(__webpack_require__(24));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module resolve */ /** for typedoc */\n\t__export(__webpack_require__(27));\n\t__export(__webpack_require__(25));\n\t__export(__webpack_require__(26));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(46));\n\t__export(__webpack_require__(34));\n\t__export(__webpack_require__(45));\n\t__export(__webpack_require__(47));\n\t__export(__webpack_require__(44));\n\t__export(__webpack_require__(48));\n\t__export(__webpack_require__(18));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * # Transition subsystem\n\t *\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See:\n\t * - [[TransitionService]]\n\t * - [[Transition]]\n\t * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module transition\n\t */ /** for typedoc */\n\t__export(__webpack_require__(16));\n\t__export(__webpack_require__(20));\n\t__export(__webpack_require__(19));\n\t__export(__webpack_require__(13));\n\t__export(__webpack_require__(14));\n\t__export(__webpack_require__(17));\n\t__export(__webpack_require__(42));\n\t__export(__webpack_require__(35));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(30));\n\t__export(__webpack_require__(29));\n\t__export(__webpack_require__(32));\n\t__export(__webpack_require__(33));\n\t__export(__webpack_require__(51));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(43));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t/**\n\t * # Core classes and interfaces\n\t *\n\t * The classes and interfaces that are core to ui-router and do not belong\n\t * to a more specific subsystem (such as resolve).\n\t *\n\t * @coreapi\n\t * @preferred\n\t * @module core\n\t */ /** for typedoc */\n\t\"use strict\";\n\t/** @internalapi */\n\tvar UIRouterPluginBase = (function () {\n\t    function UIRouterPluginBase() {\n\t    }\n\t    UIRouterPluginBase.prototype.dispose = function (router) { };\n\t    return UIRouterPluginBase;\n\t}());\n\texports.UIRouterPluginBase = UIRouterPluginBase;\n\t//# sourceMappingURL=interface.js.map\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MnViewConfig, Resolvable, ResolveContext, ViewService, hasAnyKey, ref, services, viewConfigId;\n\t\n\tref = __webpack_require__(4), services = ref.services, ViewService = ref.ViewService, ResolveContext = ref.ResolveContext, Resolvable = ref.Resolvable;\n\t\n\tviewConfigId = 0;\n\t\n\thasAnyKey = function(keys, obj) {\n\t  return _.reduce(keys, (function(memo, key) {\n\t    return memo || (obj[key] != null);\n\t  }), false);\n\t};\n\t\n\texports.mnViewsBuilder = function(state) {\n\t  var keys, views, viewsObject;\n\t  if (!state.parent) {\n\t    return;\n\t  }\n\t  keys = ['view', 'controller'];\n\t  views = {};\n\t  viewsObject = state.views || {\n\t    $default: _.pick(state, keys)\n\t  };\n\t  _.each(viewsObject, function(config, name) {\n\t    var normalized;\n\t    name = name || '$default';\n\t    config.resolveAs = config.resolveAs || '$resolve';\n\t    config.$type = 'backbone';\n\t    config.$context = state;\n\t    config.$name = name;\n\t    normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n\t    config.$uiViewName = normalized.uiViewName;\n\t    config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t    return views[name] = config;\n\t  });\n\t  return views;\n\t};\n\t\n\texports.MnViewConfig = MnViewConfig = (function() {\n\t  function MnViewConfig(path, viewDecl) {\n\t    this.path = path;\n\t    this.viewDecl = viewDecl;\n\t    this.loaded = true;\n\t    this.$id = viewConfigId++;\n\t  }\n\t\n\t  MnViewConfig.prototype.load = function() {\n\t    return services.$q.when(this);\n\t  };\n\t\n\t  return MnViewConfig;\n\n\t})();\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(62));\n\t//# sourceMappingURL=vanilla.js.map\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * Naive, pure JS implementation of core ui-router services\n\t *\n\t *\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\t__export(__webpack_require__(63));\n\t__export(__webpack_require__(64));\n\t__export(__webpack_require__(65));\n\t__export(__webpack_require__(67));\n\t__export(__webpack_require__(68));\n\t__export(__webpack_require__(69));\n\t__export(__webpack_require__(70));\n\t__export(__webpack_require__(71));\n\t__export(__webpack_require__(72));\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t/**\n\t * An angular1-like promise api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This API provides native ES6 promise support wrapped as a $q-like API.\n\t * Internally, UI-Router uses this $q object to perform promise operations.\n\t * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n\t *\n\t * $q-like promise api\n\t */\n\texports.$q = {\n\t    /** Normalizes a value as a promise */\n\t    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n\t    /** Normalizes a value as a promise rejection */\n\t    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n\t    /** @returns a deferred object, which has `resolve` and `reject` functions */\n\t    defer: function () {\n\t        var deferred = {};\n\t        deferred.promise = new Promise(function (resolve, reject) {\n\t            deferred.resolve = resolve;\n\t            deferred.reject = reject;\n\t        });\n\t        return deferred;\n\t    },\n\t    /** Like Promise.all(), but also supports object key/promise notation like $q */\n\t    all: function (promises) {\n\t        if (index_1.isArray(promises)) {\n\t            return new Promise(function (resolve, reject) {\n\t                var results = [];\n\t                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n\t                    .then(function () { resolve(results); }, reject);\n\t            });\n\t        }\n\t        if (index_1.isObject(promises)) {\n\t            // Convert promises map to promises array.\n\t            // When each promise resolves, map it to a tuple { key: key, val: val }\n\t            var chain = Object.keys(promises)\n\t                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n\t            // Then wait for all promises to resolve, and convert them back to an object\n\t            return exports.$q.all(chain).then(function (values) {\n\t                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n\t            });\n\t        }\n\t    }\n\t};\n\t//# sourceMappingURL=$q.js.map\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\t// globally available injectables\n\tvar globals = {};\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t/**\n\t * A basic angular1-like injector api\n\t *\n\t * This object implements four methods similar to the\n\t * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n\t *\n\t * UI-Router evolved from an angular 1 library to a framework agnostic library.\n\t * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n\t *\n\t * This object provides a naive implementation of a globally scoped dependency injection system.\n\t * It supports the following DI approaches:\n\t *\n\t * ### Function parameter names\n\t *\n\t * A function's `.toString()` is called, and the parameter names are parsed.\n\t * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n\t *\n\t * ```js\n\t * function injectedFunction(FooService, BarService) {\n\t *   // FooService and BarService are injected\n\t * }\n\t * ```\n\t *\n\t * ### Function annotation\n\t *\n\t * A function may be annotated with an array of dependency names as the `$inject` property.\n\t *\n\t * ```js\n\t * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n\t * function injectedFunction(fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }\n\t * ```\n\t *\n\t * ### Array notation\n\t *\n\t * An array provides the names of the dependencies to inject (as strings).\n\t * The function is the last element of the array.\n\t *\n\t * ```js\n\t * [ 'FooService', 'BarService', function (fs, bs) {\n\t *   // FooService and BarService are injected as fs and bs parameters\n\t * }]\n\t * ```\n\t *\n\t * @type {$InjectorLike}\n\t */\n\texports.$injector = {\n\t    /** Gets an object from DI based on a string token */\n\t    get: function (name) { return globals[name]; },\n\t    /** Returns true if an object named `name` exists in global DI */\n\t    has: function (name) { return exports.$injector.get(name) != null; },\n\t    /**\n\t     * Injects a function\n\t     *\n\t     * @param fn the function to inject\n\t     * @param context the function's `this` binding\n\t     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n\t     */\n\t    invoke: function (fn, context, locals) {\n\t        var all = index_1.extend({}, globals, locals || {});\n\t        var params = exports.$injector.annotate(fn);\n\t        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n\t        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n\t        if (index_1.isFunction(fn))\n\t            return fn.apply(context, args);\n\t        else\n\t            return fn.slice(-1)[0].apply(context, args);\n\t    },\n\t    /**\n\t     * Returns a function's dependencies\n\t     *\n\t     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n\t     * @return an array of `string`s\n\t     */\n\t    annotate: function (fn) {\n\t        if (!index_1.isInjectable(fn))\n\t            throw new Error(\"Not an injectable function: \" + fn);\n\t        if (fn && fn.$inject)\n\t            return fn.$inject;\n\t        if (index_1.isArray(fn))\n\t            return fn.slice(0, -1);\n\t        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n\t        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n\t        return result || [];\n\t    }\n\t};\n\t//# sourceMappingURL=$injector.js.map\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */ /** */\n\t\"use strict\";\n\tvar utils_1 = __webpack_require__(66);\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A base `LocationServices` */\n\tvar BaseLocationServices = (function () {\n\t    function BaseLocationServices(router, fireAfterUpdate) {\n\t        var _this = this;\n\t        this.fireAfterUpdate = fireAfterUpdate;\n\t        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n\t        this._listeners = [];\n\t        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n\t        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n\t        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n\t        this._location = window && window.location;\n\t        this._history = window && window.history;\n\t    }\n\t    BaseLocationServices.prototype.url = function (url, replace) {\n\t        if (replace === void 0) { replace = true; }\n\t        if (predicates_1.isDefined(url) && url !== this._get()) {\n\t            this._set(null, null, url, replace);\n\t            if (this.fireAfterUpdate) {\n\t                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n\t                this._listeners.forEach(function (cb) { return cb(evt_1); });\n\t            }\n\t        }\n\t        return utils_1.buildUrl(this);\n\t    };\n\t    BaseLocationServices.prototype.onChange = function (cb) {\n\t        var _this = this;\n\t        this._listeners.push(cb);\n\t        return function () { return common_1.removeFrom(_this._listeners, cb); };\n\t    };\n\t    BaseLocationServices.prototype.dispose = function (router) {\n\t        common_1.deregAll(this._listeners);\n\t    };\n\t    return BaseLocationServices;\n\t}());\n\texports.BaseLocationServices = BaseLocationServices;\n\t//# sourceMappingURL=baseLocationService.js.map\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar index_1 = __webpack_require__(5);\n\tvar common_1 = __webpack_require__(6);\n\tvar beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\texports.splitHash = beforeAfterSubstr(\"#\");\n\texports.splitQuery = beforeAfterSubstr(\"?\");\n\texports.splitEqual = beforeAfterSubstr(\"=\");\n\texports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\n\texports.keyValsToObjectR = function (accum, _a) {\n\t    var key = _a[0], val = _a[1];\n\t    if (!accum.hasOwnProperty(key)) {\n\t        accum[key] = val;\n\t    }\n\t    else if (index_1.isArray(accum[key])) {\n\t        accum[key].push(val);\n\t    }\n\t    else {\n\t        accum[key] = [accum[key], val];\n\t    }\n\t    return accum;\n\t};\n\texports.getParams = function (queryString) {\n\t    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n\t};\n\tfunction parseUrl(url) {\n\t    var orEmptyString = function (x) { return x || \"\"; };\n\t    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n\t    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n\t    return { path: path, search: search, hash: hash, url: url };\n\t}\n\texports.parseUrl = parseUrl;\n\texports.buildUrl = function (loc) {\n\t    var path = loc.path();\n\t    var searchObject = loc.search();\n\t    var hash = loc.hash();\n\t    var search = Object.keys(searchObject).map(function (key) {\n\t        var param = searchObject[key];\n\t        var vals = index_1.isArray(param) ? param : [param];\n\t        return vals.map(function (val) { return key + \"=\" + val; });\n\t    }).reduce(common_1.unnestR, []).join(\"&\");\n\t    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n\t};\n\tfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n\t    return function (router) {\n\t        var service = router.locationService = new serviceClass(router);\n\t        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n\t        function dispose(router) {\n\t            router.dispose(service);\n\t            router.dispose(configuration);\n\t        }\n\t        return { name: name, service: service, configuration: configuration, dispose: dispose };\n\t    };\n\t}\n\texports.locationPluginFactory = locationPluginFactory;\n\t//# sourceMappingURL=utils.js.map\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\n\tvar HashLocationService = (function (_super) {\n\t    __extends(HashLocationService, _super);\n\t    function HashLocationService(router) {\n\t        var _this = _super.call(this, router, false) || this;\n\t        window.addEventListener('hashchange', _this._listener, false);\n\t        return _this;\n\t    }\n\t    HashLocationService.prototype._get = function () {\n\t        return utils_1.trimHashVal(this._location.hash);\n\t    };\n\t    HashLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._location.hash = url;\n\t    };\n\t    HashLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener('hashchange', this._listener);\n\t    };\n\t    return HashLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.HashLocationService = HashLocationService;\n\t//# sourceMappingURL=hashLocationService.js.map\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/** A `LocationServices` that gets/sets the current location from an in-memory object */\n\tvar MemoryLocationService = (function (_super) {\n\t    __extends(MemoryLocationService, _super);\n\t    function MemoryLocationService(router) {\n\t        return _super.call(this, router, true) || this;\n\t    }\n\t    MemoryLocationService.prototype._get = function () {\n\t        return this._url;\n\t    };\n\t    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n\t        this._url = url;\n\t    };\n\t    return MemoryLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.MemoryLocationService = MemoryLocationService;\n\t//# sourceMappingURL=memoryLocationService.js.map\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar utils_1 = __webpack_require__(66);\n\tvar baseLocationService_1 = __webpack_require__(65);\n\t/**\n\t * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n\t *\n\t * Uses `history.pushState` and `history.replaceState`\n\t */\n\tvar PushStateLocationService = (function (_super) {\n\t    __extends(PushStateLocationService, _super);\n\t    function PushStateLocationService(router) {\n\t        var _this = _super.call(this, router, true) || this;\n\t        _this._config = router.urlService.config;\n\t        window.addEventListener(\"popstate\", _this._listener, false);\n\t        return _this;\n\t    }\n\t    ;\n\t    PushStateLocationService.prototype._get = function () {\n\t        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n\t        search = utils_1.splitQuery(search)[1]; // strip ? if found\n\t        hash = utils_1.splitHash(hash)[1]; // strip # if found\n\t        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n\t    };\n\t    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n\t        var _a = this, _config = _a._config, _history = _a._history;\n\t        var fullUrl = _config.baseHref() + url;\n\t        if (replace) {\n\t            _history.replaceState(state, title, fullUrl);\n\t        }\n\t        else {\n\t            _history.pushState(state, title, fullUrl);\n\t        }\n\t    };\n\t    PushStateLocationService.prototype.dispose = function (router) {\n\t        _super.prototype.dispose.call(this, router);\n\t        window.removeEventListener(\"popstate\", this._listener);\n\t    };\n\t    return PushStateLocationService;\n\t}(baseLocationService_1.BaseLocationServices));\n\texports.PushStateLocationService = PushStateLocationService;\n\t//# sourceMappingURL=pushStateLocationService.js.map\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(7);\n\tvar common_1 = __webpack_require__(6);\n\t/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\n\tvar MemoryLocationConfig = (function () {\n\t    function MemoryLocationConfig() {\n\t        var _this = this;\n\t        this._baseHref = '';\n\t        this._port = 80;\n\t        this._protocol = \"http\";\n\t        this._host = \"localhost\";\n\t        this._hashPrefix = \"\";\n\t        this.port = function () { return _this._port; };\n\t        this.protocol = function () { return _this._protocol; };\n\t        this.host = function () { return _this._host; };\n\t        this.baseHref = function () { return _this._baseHref; };\n\t        this.html5Mode = function () { return false; };\n\t        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n\t        this.dispose = common_1.noop;\n\t    }\n\t    return MemoryLocationConfig;\n\t}());\n\texports.MemoryLocationConfig = MemoryLocationConfig;\n\t//# sourceMappingURL=memoryLocationConfig.js.map\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar predicates_1 = __webpack_require__(7);\n\t/** A `LocationConfig` that delegates to the browser's `location` object */\n\tvar BrowserLocationConfig = (function () {\n\t    function BrowserLocationConfig(router, _isHtml5) {\n\t        if (_isHtml5 === void 0) { _isHtml5 = false; }\n\t        this._isHtml5 = _isHtml5;\n\t        this._baseHref = undefined;\n\t        this._hashPrefix = \"\";\n\t    }\n\t    BrowserLocationConfig.prototype.port = function () {\n\t        return parseInt(location.port);\n\t    };\n\t    BrowserLocationConfig.prototype.protocol = function () {\n\t        return location.protocol;\n\t    };\n\t    BrowserLocationConfig.prototype.host = function () {\n\t        return location.host;\n\t    };\n\t    BrowserLocationConfig.prototype.html5Mode = function () {\n\t        return this._isHtml5;\n\t    };\n\t    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n\t        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n\t    };\n\t    ;\n\t    BrowserLocationConfig.prototype.baseHref = function (href) {\n\t        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n\t    };\n\t    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n\t        var baseTags = document.getElementsByTagName(\"base\");\n\t        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n\t    };\n\t    BrowserLocationConfig.prototype.dispose = function () { };\n\t    return BrowserLocationConfig;\n\t}());\n\texports.BrowserLocationConfig = BrowserLocationConfig;\n\t//# sourceMappingURL=browserLocationConfig.js.map\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * @internalapi\n\t * @module vanilla\n\t */\n\t/** */\n\tvar browserLocationConfig_1 = __webpack_require__(71);\n\tvar hashLocationService_1 = __webpack_require__(67);\n\tvar utils_1 = __webpack_require__(66);\n\tvar pushStateLocationService_1 = __webpack_require__(69);\n\tvar memoryLocationService_1 = __webpack_require__(68);\n\tvar memoryLocationConfig_1 = __webpack_require__(70);\n\tvar _injector_1 = __webpack_require__(64);\n\tvar _q_1 = __webpack_require__(63);\n\tvar coreservices_1 = __webpack_require__(9);\n\tfunction servicesPlugin(router) {\n\t    coreservices_1.services.$injector = _injector_1.$injector;\n\t    coreservices_1.services.$q = _q_1.$q;\n\t    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n\t}\n\texports.servicesPlugin = servicesPlugin;\n\t/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\n\texports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\n\texports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n\t/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\n\texports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n\t//# sourceMappingURL=plugins.js.map\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, ResolveContext, UIViewMarionette, id,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tid = 0;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tResolveContext = __webpack_require__(4).ResolveContext;\n\t\n\texports.UIViewMarionette = UIViewMarionette = (function(superClass) {\n\t  extend(UIViewMarionette, superClass);\n\t\n\t  function UIViewMarionette() {\n\t    return UIViewMarionette.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UIViewMarionette.prototype.initialize = function(router, mnLayout, mnRegion, mnRegionName) {\n\t    var name, parentContext, parentFqn, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n\t    this.router = router;\n\t    this.mnRegion = mnRegion;\n\t    console.log('new uiview ' + mnRegionName);\n\t    this.listenTo(mnLayout, \"before:destroy\", this.destroy);\n\t    name = mnRegionName || '$default';\n\t    parentContext = mnLayout != null ? (ref = mnLayout.parent) != null ? (ref1 = ref.uiView) != null ? (ref2 = ref1.activeUIView.config) != null ? (ref3 = ref2.viewDecl) != null ? ref3.$context : void 0 : void 0 : void 0 : void 0 : void 0;\n\t    parentFqn = mnLayout != null ? (ref4 = mnLayout.parent) != null ? (ref5 = ref4.uiView) != null ? (ref6 = ref5.activeUIView) != null ? ref6.fqn : void 0 : void 0 : void 0 : void 0;\n\t    return this.activeUIView = {\n\t      $type: 'backbone',\n\t      id: id++,\n\t      name: name,\n\t      fqn: parentFqn ? parentFqn + \".\" + name : name,\n\t      creationContext: parentContext || this.router.stateRegistry.root(),\n\t      configUpdated: (function(_this) {\n\t        return function(config) {\n\t          return _this.onConfigUpdated(config);\n\t        };\n\t      })(this),\n\t      config: void 0\n\t    };\n\t  };\n\t\n\t  UIViewMarionette.prototype.register = function() {\n\t    return this.deregister = this.router.viewService.registerUIView(this.activeUIView);\n\t  };\n\t\n\t  UIViewMarionette.prototype.onConfigUpdated = function(newConfig) {\n\t    if (!newConfig) {\n\t      return this.clearPreviousConfig();\n\t    }\n\t    if (newConfig.viewDecl.$type !== 'backbone') {\n\t      return;\n\t    }\n\t    if (this.activeUIView.config === newConfig) {\n\t      return;\n\t    }\n\t    return this.updateView(newConfig);\n\t  };\n\t\n\t  UIViewMarionette.prototype.updateView = function(newConfig) {\n\t    var controller, resolved, view;\n\t    this.activeUIView.config = newConfig;\n\t    resolved = this.getResolved(newConfig);\n\t    view = this.getView(newConfig, {\n\t      resolved: resolved\n\t    });\n\t    controller = this.getController(newConfig, {\n\t      resolved: resolved,\n\t      view: view\n\t    });\n\t    if (view != null) {\n\t      this.mnRegion.show(view);\n\t      if (controller != null) {\n\t        return this.listenToOnce(view, \"destroy\", function() {\n\t          return controller.destroy();\n\t        });\n\t      }\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getResolved = function(config) {\n\t    var context, i, key, keys, len, resolved;\n\t    context = new ResolveContext(config.path);\n\t    resolved = {};\n\t    keys = _.filter(context.getTokens(), function(token) {\n\t      return typeof token === 'string';\n\t    });\n\t    for (i = 0, len = keys.length; i < len; i++) {\n\t      key = keys[i];\n\t      resolved[key] = context.getResolvable(key).data;\n\t    }\n\t    return resolved;\n\t  };\n\t\n\t  UIViewMarionette.prototype.getView = function(config, viewOptions) {\n\t    var ref, view;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.view : void 0 : void 0) != null) {\n\t      return view = new config.viewDecl.view(viewOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.getController = function(config, controllerOptions) {\n\t    var ref;\n\t    if ((config != null ? (ref = config.viewDecl) != null ? ref.controller : void 0 : void 0) != null) {\n\t      return new config.viewDecl.controller(controllerOptions);\n\t    }\n\t  };\n\t\n\t  UIViewMarionette.prototype.clearPreviousConfig = function() {\n\t    var ref;\n\t    this.mnRegion.empty();\n\t    (this.activeUIView.view != null) && ((ref = this.activeUIView.controller) != null ? ref.triggerMethod('view:destroyed') : void 0);\n\t    return this.activeUIView.config = void 0;\n\t  };\n\t\n\t  UIViewMarionette.prototype.onBeforeDestroy = function() {\n\t    return typeof this.deregister === \"function\" ? this.deregister() : void 0;\n\t  };\n\t\n\t  return UIViewMarionette;\n\t\n\t})(Mn.Object);\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UIRouterMarionette, UISref, UISrefActive,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tUIRouterMarionette = __webpack_require__(3).UIRouterMarionette;\n\t\n\texports.UISref = UISref = (function(superClass) {\n\t  extend(UISref, superClass);\n\t\n\t  function UISref() {\n\t    return UISref.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISref.prototype.ui = {\n\t    sref: '[ui-sref]'\n\t  };\n\t\n\t  UISref.prototype.events = {\n\t    'click @ui.ref': 'onClickLink'\n\t  };\n\t\n\t  UISref.prototype.onClickLink = function() {};\n\t\n\t  UISref.prototype.onAttach = function() {\n\t    var router;\n\t    router = UIRouterMarionette.getInstance();\n\t    return this.ui.sref.each(function(i, e) {\n\t      var params, state, url;\n\t      e = $(e);\n\t      state = e.attr('ui-sref');\n\t      try {\n\t        params = JSON.parse(e.attr('ui-sparams'));\n\t      } catch (undefined) {}\n\t      url = router.stateService.href(state, params);\n\t      return e.attr('href', url);\n\t    });\n\t  };\n\t\n\t  return UISref;\n\t\n\t})(Mn.Behavior);\n\t\n\texports.UISrefActive = UISrefActive = (function(superClass) {\n\t  extend(UISrefActive, superClass);\n\t\n\t  function UISrefActive() {\n\t    return UISrefActive.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  UISrefActive.prototype.ui = {\n\t    active: '[ui-sref-active]'\n\t  };\n\t\n\t  UISrefActive.prototype.defaults = {\n\t    activeClasses: 'ui-state-active'\n\t  };\n\t\n\t  UISrefActive.prototype.initialize = function() {\n\t    this.router = UIRouterMarionette.getInstance();\n\t    return this.deregister = this.router.transitionService.onSuccess({}, (function(_this) {\n\t      return function(transition) {\n\t        return _this.onStateChange();\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onRender = function() {\n\t    return this.onStateChange();\n\t  };\n\t\n\t  UISrefActive.prototype.onStateChange = function() {\n\t    return this.ui.active.each((function(_this) {\n\t      return function(i, el) {\n\t        var $el, classFn, compareState, params;\n\t        $el = $(el);\n\t        params = $el.attr('ui-sparams');\n\t        if (params) {\n\t          params = JSON.parse(params);\n\t        }\n\t        compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref');\n\t        classFn = _this.router.stateService.includes(compareState, params) ? 'addClass' : 'removeClass';\n\t        return $el[classFn](_this.options.activeClasses);\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  UISrefActive.prototype.onBeforeDestroy = function() {\n\t    return this.deregister();\n\t  };\n\t\n\t  UISrefActive.prototype.removeListeners = function() {\n\t    return this.ui.active.off('ui:state:change');\n\t  };\n\t\n\t  return UISrefActive;\n\t\n\t})(Mn.Behavior);\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Mn, UILayoutMn2, UIRouterMarionette, UIViewMarionette,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\t\n\tUIViewMarionette = __webpack_require__(73).UIViewMarionette;\n\t\n\tUIRouterMarionette = __webpack_require__(3).UIRouterMarionette;\n\t\n\tMn = __webpack_require__(74);\n\t\n\tmodule.exports = UILayoutMn2 = (function(superClass) {\n\t  extend(UILayoutMn2, superClass);\n\t\n\t  function UILayoutMn2() {\n\t    UILayoutMn2.__super__.constructor.apply(this, arguments);\n\t    this.on(\"attach\", this.onAttachUI);\n\t    this.on(\"before:destroy\", this.onBeforeDestroyUI);\n\t  }\n\t\n\t  UILayoutMn2.prototype.regions = {\n\t    \"$default\": \"[ui-view]\"\n\t  };\n\t\n\t  UILayoutMn2.prototype.onAttachUI = function(me, parentRegion) {\n\t    var ref, region, regionName;\n\t    this.parent = parentRegion;\n\t    ref = this.regions;\n\t    for (regionName in ref) {\n\t      if (!hasProp.call(ref, regionName)) continue;\n\t      region = ref[regionName];\n\t      this[regionName].uiView = new UIViewMarionette(UIRouterMarionette.getInstance(), this, this[regionName], regionName);\n\t      this[regionName].uiView.register();\n\t    }\n\t  };\n\t\n\t  UILayoutMn2.prototype.onBeforeDestroyUI = function() {\n\t    return this.parent = null;\n\t  };\n\t\n\t  return UILayoutMn2;\n\t\n\t})(Mn.LayoutView);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ui-router-marionette.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fbbb5f460b2da7b44954","_ = require('underscore')\n{\n  $q\n  UIViewMarionette\n  UIRouterMarionette\n} = require('./router')\n\n{\n  UISref\n  UISrefActive\n} = require('./router/marionette/behaviors')\n\nUILayoutMn2 = require('./router/ui_layout_mn2')\n\n\n_.extend exports, {\n  UIRouterMarionette\n  UISref\n  UISrefActive\n  UILayoutMn2\n  UIViewMarionette\n  $q\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}\n// module id = 2\n// module chunks = 0 1","{ UIRouter, $q } = require('ui-router-core')\n{ mnViewsBuilder, MnViewConfig } = require('./state_views_builder')\n{ hashLocationPlugin, servicesPlugin } = require('ui-router-core/lib/vanilla')\n{ UIViewMarionette } = require('./uiview')\n\nrouterInstance = null\n\nviewConfigFactory = (node, config) ->\n  new MnViewConfig(node, config)\n\n\nclass UIRouterMarionette extends UIRouter\n  @getInstance: ->\n    routerInstance or= new @\n\n  constructor: ->\n    super\n    @_started = false\n    @viewService._pluginapi._viewConfigFactory('backbone', viewConfigFactory)\n    @plugin(servicesPlugin)\n    @plugin(hashLocationPlugin)\n\n    @stateRegistry.decorator(\"views\", mnViewsBuilder)\n    routerInstance = @\n\n  start: (@rootRegion) ->\n    throw new Error(\"Router was already started\") if @_started\n\n    @rootRegion.uiView = new UIViewMarionette(@, null, @rootRegion, \"\")\n    @rootRegion.uiView.register()\n\n    @urlMatcherFactory.$get()\n    @urlService.listen()\n    @urlService.sync()\n    @_started = true\n    return @\n\n\n\nexports.UIViewMarionette = UIViewMarionette\nexports.UIRouterMarionette = UIRouterMarionette\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/index.coffee","/**\n * @coreapi\n * @module common\n */ /** */\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./common/index\"));\n__export(require(\"./params/index\"));\n__export(require(\"./path/index\"));\n__export(require(\"./resolve/index\"));\n__export(require(\"./state/index\"));\n__export(require(\"./transition/index\"));\n__export(require(\"./url/index\"));\n__export(require(\"./view/index\"));\n__export(require(\"./globals\"));\n__export(require(\"./router\"));\n__export(require(\"./interface\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/index.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module common */ /** for typedoc */\n__export(require(\"./common\"));\n__export(require(\"./coreservices\"));\n__export(require(\"./glob\"));\n__export(require(\"./hof\"));\n__export(require(\"./predicates\"));\n__export(require(\"./queue\"));\n__export(require(\"./strings\"));\n__export(require(\"./trace\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/index.js\n// module id = 5\n// module chunks = 0 1","/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar hof_1 = require(\"./hof\");\nvar coreservices_1 = require(\"./coreservices\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = angular.extend || _extend;\nexports.equals = angular.equals || _equals;\nexports.identity = function (x) { return x; };\nexports.noop = function () { return undefined; };\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    if (opts === void 0) { opts = {}; }\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var defaults = merge.apply(null, [{}].concat(defaultsList));\n    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n}\nexports.defaults = defaults;\n/**\n * Merges properties from the list of objects to the destination object.\n * If a property already exists in the destination object, then it is not overwritten.\n */\nfunction merge(dst) {\n    var objs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objs[_i - 1] = arguments[_i];\n    }\n    exports.forEach(objs, function (obj) {\n        exports.forEach(obj, function (value, key) {\n            if (!dst.hasOwnProperty(key))\n                dst[key] = value;\n        });\n    });\n    return dst;\n}\nexports.merge = merge;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\nfunction pickOmitImpl(predicate, obj) {\n    var keys = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        keys[_i - 2] = arguments[_i];\n    }\n    var objCopy = {};\n    for (var key in obj) {\n        if (predicate(keys, key))\n            objCopy[key] = obj[key];\n    }\n    return objCopy;\n}\n/** Return a copy of the object only containing the whitelisted properties. */\nfunction pick(obj) {\n    return pickOmitImpl.apply(null, [exports.inArray].concat(restArgs(arguments)));\n}\nexports.pick = pick;\n/** Return a copy of the object omitting the blacklisted properties. */\nfunction omit(obj) {\n    var notInArray = function (array, item) { return !exports.inArray(array, item); };\n    return pickOmitImpl.apply(null, [notInArray].concat(restArgs(arguments)));\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var arrayArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrayArgs[_i] = arguments[_i];\n    }\n    if (arrayArgs.length === 0)\n        return [];\n    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _copyProps(to, from) {\n    Object.keys(from).forEach(function (key) { return to[key] = from[key]; });\n    return to;\n}\nfunction _extend(toObj) {\n    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n}\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function (a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/common.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */ /** */\nvar hof_1 = require(\"./hof\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/predicates.js\n// module id = 7\n// module chunks = 0 1","/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\n\"use strict\";\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/hof.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/coreservices.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** @deprecated whats the point? */\n    Glob.is = function (text) {\n        return text.indexOf('*') > -1;\n    };\n    /** @deprecated whats the point? */\n    Glob.fromString = function (text) {\n        if (!this.is(text))\n            return null;\n        return new Glob(text);\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/glob.js\n// module id = 10\n// module chunks = 0 1","/**\n * @module common\n */ /** for typedoc */\n\"use strict\";\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/queue.js\n// module id = 11\n// module chunks = 0 1","/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\n\"use strict\";\nvar predicates_1 = require(\"./predicates\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar common_1 = require(\"./common\");\nvar hof_1 = require(\"./hof\");\nvar transition_1 = require(\"../transition/transition\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/strings.js\n// module id = 12\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var type = this.type, message = this.message, detail = detailString(this.detail);\n        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isTransitionRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n    };\n    /** Returns a TransitionRejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a TransitionRejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a TransitionRejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a TransitionRejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a TransitionRejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        // TODO think about how to encapsulate an Error() object\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/rejectFactory.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar hookBuilder_1 = require(\"./hookBuilder\");\nvar node_1 = require(\"../path/node\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar param_1 = require(\"../params/param\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar router_1 = require(\"../router\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /**\n         * Checks if this transition is currently active/running.\n         */\n        this.isActive = function () { return _this === _this._options.current(); };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this.hookBuilder().buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.runAllHooks(onCreateHooks);\n        this.applyViewConfigs(router);\n        this.applyRootResolvables(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathFactory.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    Transition.prototype.applyRootResolvables = function (router) {\n        var _this = this;\n        var rootResolvables = [\n            new resolvable_1.Resolvable(router_1.UIRouter, function () { return router; }, [], undefined, router),\n            new resolvable_1.Resolvable(Transition, function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$transition$', function () { return _this; }, [], undefined, this),\n            new resolvable_1.Resolvable('$stateParams', function () { return _this.params(); }, [], undefined, this.params())\n        ];\n        var rootNode = this._treeChanges.to[0];\n        var context = new resolveContext_1.ResolveContext(this._treeChanges.to);\n        context.addResolvables(rootResolvables, rootNode.state);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathFactory.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless  the target state explicitly specifies location)\n        if (this.options().source === 'url') {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = node_1.PathNode.matching(redirectEnteringNodes, originalEnteringNodes)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.length === 0;\n    };\n    /**\n     * @hidden\n     */\n    Transition.prototype.hookBuilder = function () {\n        return new hookBuilder_1.HookBuilder(this);\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        var hookBuilder = this.hookBuilder();\n        var globals = this.router.globals;\n        globals.transitionHistory.enqueue(this);\n        var onBeforeHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.BEFORE);\n        var syncResult = transitionHook_1.TransitionHook.runOnBeforeHooks(onBeforeHooks);\n        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n            syncResult.catch(function () { return 0; }); // issue #2676\n            var rejectReason = syncResult._transitionRejection;\n            this._deferred.reject(rejectReason);\n            return this.promise;\n        }\n        if (!this.valid()) {\n            var error = new Error(this.error());\n            this._deferred.reject(error);\n            return this.promise;\n        }\n        if (this.ignored()) {\n            trace_1.trace.traceTransitionIgnored(this);\n            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n            return this.promise;\n        }\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            var onSuccessHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.SUCCESS);\n            runAllHooks(onSuccessHooks);\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            var onErrorHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ERROR);\n            runAllHooks(onErrorHooks);\n        };\n        trace_1.trace.traceTransitionStart(this);\n        // Chain the next hook off the previous\n        var appendHookToChain = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        // Run the hooks, then resolve or reject the overall deferred in the .then() handler\n        var asyncHooks = hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.ASYNC);\n        asyncHooks.reduce(appendHookToChain, syncResult)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transition.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"./strings\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Started  -> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": Ignored  <> \" + transitionStr);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, pathStr = path && path.toString();\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":         Resolving \" + pathStr + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Rejected \" + transitionStr + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        var tid = trans && trans.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(trans);\n        console.log(\"Transition #\" + tid + \" r\" + trans.router.$id + \": <- Success  \" + transitionStr + \", final state: \" + state);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/common/trace.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"ASYNC\"] = 2] = \"ASYNC\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/interface.js\n// module id = 16\n// module chunks = 0 1","\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.stateService = function () { return _this.transition.router.stateService; };\n        this.rejectIfSuperseded = function () {\n            return _this.registeredHook.eventType.rejectIfSuperseded && _this.options.current() !== _this.options.transition;\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n    }\n    TransitionHook.prototype.invokeHook = function () {\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        if (this.rejectIfSuperseded()) {\n            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n        }\n        var cb = hook.callback;\n        var bind = this.options.bind;\n        var trans = this.transition;\n        var state = this.stateContext;\n        var errorHandler = hook.eventType.getErrorHandler(this);\n        var resultHandler = hook.eventType.getResultHandler(this);\n        resultHandler = resultHandler || common_1.identity;\n        if (!errorHandler) {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        try {\n            return resultHandler(cb.call(bind, trans, state));\n        }\n        catch (error) {\n            return errorHandler(error);\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.rejectIfSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess the resolved value\n            return result.then(this.handleHookResult.bind(this));\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and start a redirected Transition (to the TargetState).\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n     * Should any hook return a Rejection synchronously, the remaining hooks will not run.\n     *\n     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n     */\n    TransitionHook.runOnBeforeHooks = function (hooks) {\n        var results = [];\n        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {\n            var hook = hooks_1[_i];\n            var hookResult = hook.invokeHook();\n            if (rejectFactory_1.Rejection.isTransitionRejectionPromise(hookResult)) {\n                // Break on first thrown error or false/TargetState\n                return hookResult;\n            }\n            results.push(hookResult);\n        }\n        return results\n            .filter(predicates_1.isPromise)\n            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n    };\n    return TransitionHook;\n}());\nTransitionHook.HANDLE_RESULT = function (hook) {\n    return function (result) {\n        return hook.handleHookResult(result);\n    };\n};\nTransitionHook.IGNORE_RESULT = function (hook) {\n    return function (result) { return undefined; };\n};\nTransitionHook.LOG_ERROR = function (hook) {\n    return function (error) {\n        return (hook.stateService().defaultErrorHandler()(error), undefined);\n    };\n};\nTransitionHook.REJECT_ERROR = function (hook) {\n    return function (error) {\n        return rejectFactory_1.Rejection.errored(error).toPromise();\n    };\n};\nTransitionHook.THROW_ERROR = function (hook) {\n    return undefined;\n};\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionHook.js\n// module id = 17\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[State]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/targetState.js\n// module id = 18\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar glob_1 = require(\"../common/glob\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookRegistry.js\n// module id = 19\n// module chunks = 0 1","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n        this.treeChanges = transition.treeChanges();\n        this.transitionOptions = transition.options();\n        this.toState = common_1.tail(this.treeChanges.to).state;\n        this.fromState = common_1.tail(this.treeChanges.from).state;\n        this.$transitions = transition.router.transitionService;\n        this.baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        return this.$transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var _this = this;\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, this.treeChanges);\n        if (!matchingHooks)\n            return [];\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(_this.treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, _this.baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state : null;\n                var transitionHook = new transitionHook_1.TransitionHook(_this.transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var registries = isCreate ? [this.$transitions] : [this.transition, this.$transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/hookBuilder.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\n/** @module path */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar param_1 = require(\"../params/param\");\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrPath) {\n        if (stateOrPath instanceof PathNode) {\n            var node = stateOrPath;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrPath;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, keys) {\n        var _this = this;\n        if (keys === void 0) { keys = this.paramSchema.map(function (p) { return p.id; }); }\n        var paramValsEq = function (key) {\n            return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]);\n        };\n        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    /**\n     * Returns a new path which is a subpath of the first path which matched the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * Nodes are compared using their state property and parameter values.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param ignoreDynamicParams don't compare dynamic parameter values\n     */\n    PathNode.matching = function (pathA, pathB, ignoreDynamicParams) {\n        if (ignoreDynamicParams === void 0) { ignoreDynamicParams = true; }\n        var matching = [];\n        for (var i = 0; i < pathA.length && i < pathB.length; i++) {\n            var a = pathA[i], b = pathB[i];\n            if (a.state !== b.state)\n                break;\n            var changedParams = param_1.Param.changed(a.paramSchema, a.paramValues, b.paramValues)\n                .filter(function (param) { return !(ignoreDynamicParams && param.dynamic); });\n            if (changedParams.length)\n                break;\n            matching.push(a);\n        }\n        return matching;\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=node.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/node.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n    });\n}\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config, });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var $$getDefaultValue = function () {\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            return defaultValue;\n        };\n        var $replace = function (val) {\n            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n            return replacement.length ? replacement[0] : val;\n        };\n        value = $replace(value);\n        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/param.js\n// module id = 22\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramType.js\n// module id = 23\n// module chunks = 0 1","/** @module path */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar targetState_1 = require(\"../state/targetState\");\nvar node_1 = require(\"../path/node\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathFactory = (function () {\n    function PathFactory() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathFactory.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathFactory.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new node_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathFactory.buildToPath = function (fromPath, targetState) {\n        var toPath = PathFactory.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathFactory.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathFactory.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new node_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var staticParams = function (state) {\n            return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));\n        };\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, staticParams(node1.state));\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = node_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathFactory.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathFactory;\n}());\n/** Gets the raw parameter values from a path */\nPathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\nexports.PathFactory = PathFactory;\n//# sourceMappingURL=pathFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/pathFactory.js\n// module id = 24\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar trace_1 = require(\"../common/trace\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (r) {\n                return r.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolvable.js\n// module id = 25\n// module chunks = 0 1","\"use strict\";\n/** @module resolve */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar interface_1 = require(\"./interface\");\nvar resolvable_1 = require(\"./resolvable\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar strings_1 = require(\"../common/strings\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Depenency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathFactory.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathFactory.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/resolveContext.js\n// module id = 26\n// module chunks = 0 1","\"use strict\";\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/interface.js\n// module id = 27\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = require(\"./url/urlMatcherFactory\");\nvar urlRouter_1 = require(\"./url/urlRouter\");\nvar transitionService_1 = require(\"./transition/transitionService\");\nvar view_1 = require(\"./view/view\");\nvar stateRegistry_1 = require(\"./state/stateRegistry\");\nvar stateService_1 = require(\"./state/stateService\");\nvar globals_1 = require(\"./globals\");\nvar common_1 = require(\"./common/common\");\nvar predicates_1 = require(\"./common/predicates\");\nvar urlService_1 = require(\"./url/urlService\");\nvar trace_1 = require(\"./common/trace\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */\n        this.$id = _routerInstance++;\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.Globals(this.transitionService);\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._disposables = [];\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(this.stateRegistry);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/router.js\n// module id = 28\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar param_1 = require(\"../params/param\");\nvar paramTypes_1 = require(\"../params/paramTypes\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcherFactory.js\n// module id = 29\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar param_1 = require(\"../params/param\");\nvar strings_1 = require(\"../common/strings\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this], parent: null, pattern: null };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(hof_1.prop('_params')));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        var parent = this._cache.parent;\n        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n            (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n            null);\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var _this = this;\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        return common_1.pairs(params || {}).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return validParamVal(_this.parameter(key), val);\n        }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        if (!this.validates(values))\n            return null;\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []);\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []);\n        /**\n         * Given a Param,\n         * Applies the parameter value, then returns details about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a Param.  Fetch details about the parameter value\n            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (param) {\n            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        var splitOnSlash = strings_1.splitOnDelim('/');\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         */\n        var segments = function (matcher) {\n            return matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                .reduce(common_1.unnestR, [])\n                .reduce(strings_1.joinNeighborsR, [])\n                .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                .reduce(common_1.unnestR, []);\n        };\n        var aSegments = segments(a), bSegments = segments(b);\n        // console.table( { aSegments, bSegments });\n        // Sort slashes first, then static strings, the Params\n        var weight = hof_1.pattern([\n            [hof_1.eq(\"/\"), hof_1.val(1)],\n            [predicates_1.isString, hof_1.val(2)],\n            [hof_1.is(param_1.Param), hof_1.val(3)]\n        ]);\n        var pairs = common_1.arrayTuples(aSegments.map(weight), bSegments.map(weight));\n        // console.table(pairs);\n        return pairs.reduce(function (cmp, weightPair) { return cmp !== 0 ? cmp : weightPair[0] - weightPair[1]; }, 0);\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlMatcher.js\n// module id = 30\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, \"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\");\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/paramTypes.js\n// module id = 31\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar hof_1 = require(\"../common/hof\");\nvar urlRule_1 = require(\"./urlRule\");\nvar targetState_1 = require(\"../state/targetState\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash()\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        if (!urlMatcher.validates(params))\n            return null;\n        var url = urlMatcher.format(params);\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this.sort();\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n        this.sort();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () { return this._rules.slice(); };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n            throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n        }\n        var handlerFn = predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this.sort();\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\n//# sourceMappingURL=urlRouter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRouter.js\n// module id = 32\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar stateObject_1 = require(\"../state/stateObject\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[State]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [hof_1.is(stateObject_1.State), function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlRule.js\n// module id = 33\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[State]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar State = (function () {\n    function State(config) {\n        common_1.extend(this, config);\n        // Object.freeze(this);\n    }\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    State.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    State.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    State.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param`eters\n     *\n     * Gets [[Param]] information that is owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] information.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    State.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]] information.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    State.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    State.prototype.toString = function () {\n        return this.fqn();\n    };\n    return State;\n}());\nexports.State = State;\n//# sourceMappingURL=stateObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateObject.js\n// module id = 34\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar transition_1 = require(\"./transition\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar resolve_1 = require(\"../hooks/resolve\");\nvar views_1 = require(\"../hooks/views\");\nvar url_1 = require(\"../hooks/url\");\nvar redirectTo_1 = require(\"../hooks/redirectTo\");\nvar onEnterExitRetain_1 = require(\"../hooks/onEnterExitRetain\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar transitionEventType_1 = require(\"./transitionEventType\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineDefaultPaths();\n        this._defineDefaultEvents();\n        this._registerDefaultTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        delete router.globals.transition;\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, false, TH.IGNORE_RESULT, TH.THROW_ERROR, false);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to, false, TH.HANDLE_RESULT);\n        this._defineEvent(\"onStart\", Phase.ASYNC, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.ASYNC, 100, paths.exiting, true);\n        this._defineEvent(\"onRetain\", Phase.ASYNC, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.ASYNC, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.ASYNC, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, false, TH.IGNORE_RESULT, TH.LOG_ERROR, false);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineDefaultPaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerDefaultTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionService.js\n// module id = 35\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state)\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/resolve.js\n// module id = 36\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/views.js\n// module id = 37\n// module chunks = 0 1","\"use strict\";\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/url.js\n// module id = 38\n// module chunks = 0 1","\"use strict\";\n/** @module hooks */ /** */\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar targetState_1 = require(\"../state/targetState\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/redirectTo.js\n// module id = 39\n// module chunks = 0 1","\"use strict\";\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var hookFn = state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/onEnterExitRetain.js\n// module id = 40\n// module chunks = 0 1","\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/hooks/lazyLoad.js\n// module id = 41\n// module chunks = 0 1","\"use strict\";\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, rejectIfSuperseded) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (rejectIfSuperseded === void 0) { rejectIfSuperseded = true; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.rejectIfSuperseded = rejectIfSuperseded;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/transitionEventType.js\n// module id = 42\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar trace_1 = require(\"../common/trace\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return the number of dots in the fully qualified name\n        function uiViewDepth(uiView) {\n            return uiView.fqn.split(\".\").length;\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/view.js\n// module id = 43\n// module chunks = 0 1","/**\n * @coreapi\n * @module state\n */ /** for typedoc */\n\"use strict\";\nvar stateMatcher_1 = require(\"./stateMatcher\");\nvar stateBuilder_1 = require(\"./stateBuilder\");\nvar stateQueueManager_1 = require(\"./stateQueueManager\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[State]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[State]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[State]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {State[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateRegistry.js\n// module id = 44\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar predicates_1 = require(\"../common/predicates\");\nvar glob_1 = require(\"../common/glob\");\nvar common_1 = require(\"../common/common\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base) {\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr) {\n            var matches = common_1.values(this._states)\n                .filter(function (state) { return new glob_1.Glob(state.name).matches(name); });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateMatcher.js\n// module id = 45\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[State]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[State]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent))\n            return null;\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateBuilder.js\n// module id = 46\n// module chunks = 0 1","\"use strict\";\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar stateObject_1 = require(\"./stateObject\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (config) {\n        var _a = this, states = _a.states, queue = _a.queue;\n        // Wrap a new object around the state so we can store our private details easily.\n        // @TODO: state = new State(extend({}, config, { ... }))\n        var state = common_1.inherit(new stateObject_1.State(), common_1.extend({}, config, {\n            self: config,\n            resolve: config.resolve || [],\n            toString: function () { return config.name; }\n        }));\n        if (!predicates_1.isString(state.name))\n            throw new Error(\"State must have a valid name\");\n        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n            throw new Error(\"State '\" + state.name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = this.$registry.get(state.name);\n                if (existingState && existingState.name === state.name) {\n                    throw new Error(\"State '\" + state.name + \"' is already defined\");\n                }\n                if (existingState && existingState.name === state.name + \".**\") {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingState);\n                }\n                states[state.name] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[state.name];\n            previousQueueLength[state.name] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateQueueManager.js\n// module id = 47\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar queue_1 = require(\"../common/queue\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar node_1 = require(\"../path/node\");\nvar transitionService_1 = require(\"../transition/transitionService\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar targetState_1 = require(\"./targetState\");\nvar param_1 = require(\"../params/param\");\nvar glob_1 = require(\"../common/glob\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[State]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathFactory.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid())\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            if (latestThing() !== latest)\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false\n        });\n    };\n    ;\n    /**\n     * Transition to a different state or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n     * This allows you to easily use an absolute or relative to path and specify\n     * only the parameters you'd like to update (while letting unspecified parameters\n     * inherit from the currently active ancestor states).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     *\n     * @param to Absolute state name, state object, or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from currently defined parameters (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters specified in a parent state.\n     *\n     *    Parameter inheritance only works between common ancestor states, I.e.\n     *    transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     *    will get you all current parameters, etc.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * - Possible success values:\n     *    - $state.current\n     *\n     * - Possible rejection reasons:\n     *   - transition superseded - when a newer transition has been started after this one\n     *   - transition aborted - when the transition is cancelled by a Transition Hook returning `false`\n     *   - transition failed - when a transition hook errors\n     *   - resolve error - when a resolve has errored or rejected\n     *\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new node_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        var transHistory = globals.transitionHistory;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    router.urlRouter.update();\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    router.urlRouter.update();\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n            absolute: options.absolute\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathFactory.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/stateService.js\n// module id = 48\n// module chunks = 0 1","\"use strict\";\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = require(\"./params/stateParams\");\nvar queue_1 = require(\"./common/queue\");\nvar common_1 = require(\"./common/common\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar Globals = (function () {\n    /** @hidden */\n    function Globals(transitionService) {\n        var _this = this;\n        /** @inheritdoc */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n        // TODO: This probably belongs in a hooks/globals.ts\n        var beforeNewTransition = function ($transition$) {\n            _this.transition = $transition$;\n            _this.transitionHistory.enqueue($transition$);\n            var updateGlobalState = function () {\n                _this.successfulTransitions.enqueue($transition$);\n                _this.$current = $transition$.$to();\n                _this.current = _this.$current.self;\n                common_1.copy($transition$.params(), _this.params);\n            };\n            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n                _this.transition = null; };\n            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n        };\n        transitionService.onBefore({}, beforeNewTransition);\n    }\n    return Globals;\n}());\nexports.Globals = Globals;\n//# sourceMappingURL=globals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/globals.js\n// module id = 49\n// module chunks = 0 1","\"use strict\";\n/** @module params */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/stateParams.js\n// module id = 50\n// module chunks = 0 1","/**\n * @coreapi\n * @module url\n */ /** */\n\"use strict\";\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/urlService.js\n// module id = 51\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./param\"));\n__export(require(\"./paramTypes\"));\n__export(require(\"./stateParams\"));\n__export(require(\"./paramType\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/params/index.js\n// module id = 52\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module path */ /** for typedoc */\n__export(require(\"./node\"));\n__export(require(\"./pathFactory\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/path/index.js\n// module id = 53\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/** @module resolve */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./resolvable\"));\n__export(require(\"./resolveContext\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/resolve/index.js\n// module id = 54\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./stateBuilder\"));\n__export(require(\"./stateObject\"));\n__export(require(\"./stateMatcher\"));\n__export(require(\"./stateQueueManager\"));\n__export(require(\"./stateRegistry\"));\n__export(require(\"./stateService\"));\n__export(require(\"./targetState\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/state/index.js\n// module id = 55\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./hookBuilder\"));\n__export(require(\"./hookRegistry\"));\n__export(require(\"./rejectFactory\"));\n__export(require(\"./transition\"));\n__export(require(\"./transitionHook\"));\n__export(require(\"./transitionEventType\"));\n__export(require(\"./transitionService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/transition/index.js\n// module id = 56\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./urlMatcher\"));\n__export(require(\"./urlMatcherFactory\"));\n__export(require(\"./urlRouter\"));\n__export(require(\"./urlRule\"));\n__export(require(\"./urlService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/url/index.js\n// module id = 57\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./view\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/view/index.js\n// module id = 58\n// module chunks = 0 1","/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\n\"use strict\";\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/interface.js\n// module id = 59\n// module chunks = 0 1","# state->view logic specific to backbone (marionette)\n# ref: ui-router-ng1/statebuilders/views.ts\n\n# guess there's some missing magic here\n\n{ services, ViewService, ResolveContext, Resolvable } = require('ui-router-core')\n# AppLayout = require('javascripts/lib/views/layout')\nviewConfigId = 0\n\nhasAnyKey = (keys, obj) ->\n  # unused, copied from ui-router for ng1\n  _.reduce keys, ((memo, key) -> memo or obj[key]?), false\n\n\n\nexports.mnViewsBuilder = (state) ->\n  return if not state.parent\n\n  keys = ['view', 'controller']\n\n  views = {}\n  viewsObject = state.views or {$default: _.pick(state, keys)}\n\n  _.each viewsObject, (config, name) ->\n    name = name or '$default'\n\n    config.resolveAs = config.resolveAs or '$resolve'\n    config.$type = 'backbone'\n    config.$context = state\n    config.$name = name\n\n    normalized = ViewService.normalizeUIViewTarget config.$context, config.$name\n    config.$uiViewName = normalized.uiViewName\n    config.$uiViewContextAnchor = normalized.uiViewContextAnchor\n    views[name] = config\n\n  return views\n\n\n\nexports.MnViewConfig = class MnViewConfig\n  constructor: (@path, @viewDecl) ->\n    @loaded = true\n    @$id = viewConfigId++\n\n  load: ->\n    services.$q.when(@)\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/state_views_builder.coffee","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./vanilla/index\"));\n//# sourceMappingURL=vanilla.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla.js\n// module id = 61\n// module chunks = 0 1","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n/**\n * Naive, pure JS implementation of core ui-router services\n *\n *\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(require(\"./$q\"));\n__export(require(\"./$injector\"));\n__export(require(\"./baseLocationService\"));\n__export(require(\"./hashLocationService\"));\n__export(require(\"./memoryLocationService\"));\n__export(require(\"./pushStateLocationService\"));\n__export(require(\"./memoryLocationConfig\"));\n__export(require(\"./browserLocationConfig\"));\n__export(require(\"./plugins\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/index.js\n// module id = 62\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return new Promise(function (resolve, reject) {\n                var results = [];\n                promises.reduce(function (wait4, promise) { return wait4.then(function () { return promise.then(function (val) { return results.push(val); }); }); }, exports.$q.when())\n                    .then(function () { resolve(results); }, reject);\n            });\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=$q.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$q.js\n// module id = 63\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `ui-router-core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=$injector.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/$injector.js\n// module id = 64\n// module chunks = 0 1","/**\n * @internalapi\n * @module vanilla\n */ /** */\n\"use strict\";\nvar utils_1 = require(\"./utils\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/baseLocationService.js\n// module id = 65\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\nvar common_1 = require(\"../common/common\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/utils.js\n// module id = 66\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/hashLocationService.js\n// module id = 67\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationService.js\n// module id = 68\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/pushStateLocationService.js\n// module id = 69\n// module chunks = 0 1","\"use strict\";\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/memoryLocationConfig.js\n// module id = 70\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = require(\"../common/predicates\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        return parseInt(location.port);\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol;\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/browserLocationConfig.js\n// module id = 71\n// module chunks = 0 1","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = require(\"./browserLocationConfig\");\nvar hashLocationService_1 = require(\"./hashLocationService\");\nvar utils_1 = require(\"./utils\");\nvar pushStateLocationService_1 = require(\"./pushStateLocationService\");\nvar memoryLocationService_1 = require(\"./memoryLocationService\");\nvar memoryLocationConfig_1 = require(\"./memoryLocationConfig\");\nvar _injector_1 = require(\"./$injector\");\nvar _q_1 = require(\"./$q\");\nvar coreservices_1 = require(\"../common/coreservices\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = _injector_1.$injector;\n    coreservices_1.services.$q = _q_1.$q;\n    return { name: \"vanilla.services\", $q: _q_1.$q, $injector: _injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ui-router-core/lib/vanilla/plugins.js\n// module id = 72\n// module chunks = 0 1","id = 0\nMn = require('backbone.marionette')\n{ ResolveContext } = require('ui-router-core')\n\n\n\nexports.UIViewMarionette = class UIViewMarionette extends Mn.Object\n  # Side note:\n  # If Marionette provided a way to use custom Region subclasses on a per-View\n  # basis I could register ui-views directly in the Region constructor instead\n  # of having this separate UIViewMarionette class and a custom\n  # LayoutView subclass, but I don't want to do that globally and attempt to\n  # register regions that aren't going to be managed by ui-router.\n\n  initialize: (@router, mnLayout, @mnRegion, mnRegionName) ->\n    console.log 'new uiview ' + mnRegionName\n    # Leverage Marionette's view lifecycle to know when to unregister\n    # the ui-view\n    @listenTo mnLayout, \"before:destroy\", @destroy\n\n    # Except for the top-level region passed to router.start(), a name should\n    # always be provided (even if it is '$default')\n    name = mnRegionName || '$default'\n    # TBH I'm not entirely sure what the context is for.\n    parentContext = mnLayout?.parent?.uiView?.activeUIView.config?.viewDecl?.$context\n    # nested FQNs will end up as something like\n    # '$default.$default.myNamedUIView.$default'\n    parentFqn = mnLayout?.parent?.uiView?.activeUIView?.fqn\n\n    @activeUIView =\n      $type: 'backbone'\n      id: id++\n      name: name\n      fqn: if parentFqn then \"#{parentFqn}.#{name}\" else name\n      creationContext: parentContext || @router.stateRegistry.root()\n      configUpdated: (config) => @onConfigUpdated(config)\n      config: undefined\n\n  register: ->\n    @deregister = @router.viewService.registerUIView(@activeUIView)\n\n  onConfigUpdated: (newConfig) ->\n    # If no config was provided (which happens right after registering this view\n    # or or when entering a state that has nothing to put in this slot), we want\n    # to make sure that the ui-view element is empty.\n    return @clearPreviousConfig() if not newConfig\n\n    # We somehow got a config for a different framework's ui-router integration\n    # (I imagine this is mainly an angular 1 to 2 migration thing?)\n    return if newConfig.viewDecl.$type isnt 'backbone'\n\n    # Got the currently active view config again.\n    return if @activeUIView.config is newConfig\n\n    @updateView(newConfig)\n\n  updateView: (newConfig) ->\n    @activeUIView.config = newConfig\n\n    # Create view and controller instances if they were specified in the\n    # state config.\n    resolved = @getResolved(newConfig)\n    view = @getView(newConfig, resolved: resolved)\n    controller = @getController(newConfig, resolved: resolved, view: view)\n\n    if view?\n      @mnRegion.show view\n      if controller?\n        @listenToOnce view, \"destroy\", -> controller.destroy()\n\n  getResolved: (config) ->\n    # Map all resolved objects (plus $stateParams and $transition$)\n    # to a plain object to pass to the view and controller\n    context = new ResolveContext(config.path)\n    resolved = {}\n    keys = _.filter context.getTokens(), (token) -> typeof token is 'string'\n    resolved[key] = context.getResolvable(key).data for key in keys\n\n    return resolved\n\n  getView: (config, viewOptions) ->\n    if config?.viewDecl?.view?\n      view = new config.viewDecl.view(viewOptions)\n\n  getController: (config, controllerOptions) ->\n    if config?.viewDecl?.controller?\n      return new config.viewDecl.controller(controllerOptions)\n\n  clearPreviousConfig: ->\n    @mnRegion.empty()\n    @activeUIView.view? && @activeUIView.controller?.triggerMethod('view:destroyed')\n    @activeUIView.config = undefined\n\n  onBeforeDestroy: ->\n    @deregister?()\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/uiview.coffee","module.exports = __WEBPACK_EXTERNAL_MODULE_74__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Marionette\",\"amd\":\"backbone.marionette\",\"commonjs2\":\"backbone.marionette\",\"commonjs\":\"backbone.marionette\"}\n// module id = 74\n// module chunks = 0 1","Mn = require('backbone.marionette')\n{ UIRouterMarionette } = require('../index')\n\n\n# A helper behavior for linking to states with or without state parameters.\n# Element attributes:\n#   ui-sref=\"app.state.substate\"\n#   ui-sparams='{\"client_id\": 5}' - optional if state doesn't need params or\n#                                   you're linking to a sibling/child state\n#                                   with the same parameters.\n#                                   The value should be HTML-encoded JSON.\n#                                   A template helper method is helpful here.\n# Behavior options: none\n#\nexports.UISref = class UISref extends Mn.Behavior\n  ui:\n    sref: '[ui-sref]'\n\n  events:\n    'click @ui.ref': 'onClickLink'\n\n  onClickLink: ->\n    # maybe parse and navigate to state if this element was inserted after\n    # original dom insertion (through data binding or whatever)\n\n  onAttach: ->\n    # Go through all the ui-sref links and turn their ui-sref and HTML-escaped\n    # ui-sparams attributes into a functioning app state link\n    router = UIRouterMarionette.getInstance()\n    @ui.sref.each (i, e) ->\n      e = $(e)\n      state = e.attr('ui-sref')\n      try\n        params = JSON.parse(e.attr 'ui-sparams')\n      url = router.stateService.href(state, params)\n\n      e.attr('href', url)\n\n\n\n# A behavior to toggle CSS classes on an element when a particular state\n# (with or without specific state parameters) is active.\n# Targets elements with a ui-sref-active attribute.\n# ui-sref-active can optionally have a value selecting the specific state\n# you want to watch for. If no value is provided, it will look to the state\n# referenced by ui-sref.\n# To help with lists that point at the same state with different state params,\n# the behavior will also compare the contents of ui-sparams, if present.\n# The default class is 'ui-state-active' but this can be customized in the\n# behavior options:\n# class MyView extends Marionette.ItemView\n#   behaviors:\n#     UISref: {}\n#     UISrefActive: {activeClasses: 'state-is-active'}\n#\nexports.UISrefActive = class UISrefActive extends Mn.Behavior\n  ui:\n    active: '[ui-sref-active]'\n\n  defaults:\n    activeClasses: 'ui-state-active'\n\n  initialize: ->\n    @router = UIRouterMarionette.getInstance()\n    @deregister = @router.transitionService.onSuccess {}, (transition) => @onStateChange()\n\n  onRender: ->\n    @onStateChange()\n\n  onStateChange: ->\n    @ui.active.each (i, el) =>\n      $el = $(el)\n      params = $el.attr('ui-sparams')\n      if params\n        params = JSON.parse(params)\n      compareState = $el.attr('ui-sref-active') || $el.attr('ui-sref') # fall back to the state in ui-sref if the ui-sref-active attribute is present but empty\n      classFn = if @router.stateService.includes(compareState, params) then 'addClass' else 'removeClass'\n      $el[classFn](@options.activeClasses)\n\n  onBeforeDestroy: ->\n    @deregister()\n\n  removeListeners: ->\n    @ui.active.off('ui:state:change')\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/marionette/behaviors.coffee","{ UIViewMarionette } = require('./uiview')\n{ UIRouterMarionette } = require('./index')\nMn = require('backbone.marionette')\n# A layout view for Marionette 2.x apps.\n# When the regions are created they also get registered as UIViews.\nmodule.exports = class UILayoutMn2 extends Mn.LayoutView\n  constructor: ->\n    super\n\n    @on \"attach\", @onAttachUI\n\n    @on \"before:destroy\", @onBeforeDestroyUI\n\n  regions:\n    # Register the first element with a ui-view attribute as the\n    # default region and UIView.\n    \"$default\": \"[ui-view]\"\n\n  onAttachUI: (me, parentRegion) ->\n    @parent = parentRegion\n    for own regionName, region of @regions\n      @[regionName].uiView = new UIViewMarionette UIRouterMarionette.getInstance(), @, @[regionName], regionName\n      @[regionName].uiView.register()\n    return\n\n  onBeforeDestroyUI: ->\n    @parent = null\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/ui_layout_mn2.coffee"],"sourceRoot":""}